<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CS 246 Notes</title>
      <link href="/2024/09/05/CS246%20Object-Oriented%20Software%20Dev/"/>
      <url>/2024/09/05/CS246%20Object-Oriented%20Software%20Dev/</url>
      
        <content type="html"><![CDATA[<h1 id="CS246-Object-Oriented-Software-Dev"><a href="#CS246-Object-Oriented-Software-Dev" class="headerlink" title="CS246 Object-Oriented Software Dev"></a>CS246 Object-Oriented Software Dev</h1><p>OOP from three perspectives:</p><ol><li><strong>Programmer’s perspective</strong> - How to structure programs correctly, how to lower the risk of bugs.</li><li><strong>Compiler’s perspective</strong> - What do our constructors actually means, and what must the compiler do to support them.</li><li><strong>Designer’s perspective</strong> - How to use OOP tools (encapsulation, inheritance, polymorphism, etc.) to build systems.</li></ol><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><u>Introduction</u></h2><h4 id="Comparison-between-C-and-C"><a href="#Comparison-between-C-and-C" class="headerlink" title="Comparison between C and C++:"></a>Comparison between C and C++:</h4><p>C:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;iostream&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note:</p><ul><li><p>import, like <code>#include</code>, brings <u>names</u> and <u>definitions</u> from other files, libraries, or module into our code.</p><ul><li><p><code>import</code>, was C++’s new <u>module system</u>, more about modules in future lectures.</p></li><li><p><code>#include &lt;iostream&gt;</code> works. However module system is preferred in CS 246.</p></li></ul></li><li><p>function <code>main()</code> must return int, <code>void main() &#123;...&#125;</code> is not legal in C++</p></li><li><p>return statement returns a <u>status code</u> to OS</p><ul><li>can be omitted from main-default to <code>return 0;</code></li></ul></li><li><p><code>cout</code> and <code>&lt;&lt;</code> are how you write to stdout.</p><ul><li>this is the preferred way to do <strong>I&#x2F;O</strong> in C++</li><li>stdio.h and printf are still available in C++</li></ul></li><li><p><code>using namespace std</code></p><ul><li>called a <u>using directive</u></li><li>C++ organizes names into namespaces</li><li>without <code>using namespace std</code>, you need to write <ul><li><code>std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl</code></li></ul></li></ul></li><li><p>most C programs work in C++ (or minimal changes is required)</p></li></ul><h4 id="Input-x2F-Output"><a href="#Input-x2F-Output" class="headerlink" title="Input&#x2F;Output"></a><strong>Input&#x2F;Output</strong></h4><p>Basic Info</p><p>​C++ comes with 3 built-in I&#x2F;O streams:</p><p>​<code>cout</code> - for writing to <code>stdout</code></p><p>​<code>cerr</code> - for writing to <code>stderr</code></p><p>​<code>cin</code> - for reading from <code>stdin</code></p><p>​Built-in Operators:</p><p>​<code>&lt;&lt;</code> “put to”, insertion operator (output)</p><p>​<code>&gt;&gt;</code> “get from”, extraction operator (input)</p><p><code>&lt;&lt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; ____ &lt;&lt; ____ &lt;&lt; ____ &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>[^]: dates, expressions, literals<br>[^]: <code>endl</code> outputs an end of line char, and flushes the output buffer.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; X<span class="comment">// Operator &quot;point&quot; in the direction of data flow</span></span><br><span class="line">cerr &lt;&lt; X<span class="comment">// Never buffered</span></span><br><span class="line"> cin &gt;&gt; X<span class="comment">// Extract a value from stdin and put it into X.</span></span><br></pre></td></tr></table></figure><p>Example: Read 2 ints and print their sum</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;iostream&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    cout &lt;&lt; x + y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note:</p><ul><li>The <code>&gt;&gt;</code> operator tries to interpret the input data, according to the type of variable being read into.<ul><li>In this case, <strong>x</strong> is an <strong>int</strong>, so <strong>&gt;&gt;</strong> will expect to read chars that look like an int: <u>“123”</u> or <u>“-42”</u> and assemble those chars into an int <u>value</u>.</li></ul></li><li>it’ll stop reading when it sees a character that is not part of an integer (letter or space)</li><li><code>cin &gt;&gt;</code> ignores leading whitespaces (spaces, tabs, newlines)</li><li>when reading from the keyboard, the program will pause waiting for the user input.</li><li>pressing <u>Enter</u> causes the entered text to be submitted to the program</li><li>pressing <u>^D</u> signals end of file, or end of input</li></ul><p><u>What if bad things happen?</u></p><ul><li><p>input doesn’t contain an int</p></li><li><p>input is too large to fit in the variable</p></li><li><p>input is exhausted (not enough data) and get 2 ints</p></li></ul><p><u>The input operation fails, how can we test for this in our program?</u></p><ul><li><p>if read failed (for whatever reasons): <code>cin.fail()</code> will return true</p></li><li><p>if EOF: <code>cin.eof()</code> will also return true</p></li><li><p>But not until attempted read fails</p></li></ul><p>Example: read all int from <code>stdin</code>, echo to <code>stdout</code>, one per line, stop at EOF or bad input.</p><p>Example 1:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">        <span class="keyword">if</span> (cin.<span class="built_in">fail</span>()) <span class="keyword">break</span>; <span class="comment">// Check for failure</span></span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">        <span class="keyword">if</span> (!cin) <span class="keyword">break</span>; <span class="comment">// cin variable is being implicitly converted to a boolean value</span></span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cin</code> converts to:</p><ul><li><code>true</code> if all good</li><li><code>false</code> if the stream has had a read failure</li><li><code>&gt;&gt;</code> means right bit shift operator in C&#x2F;C++</li><li>a, b are int, a <code>&gt;&gt;</code> b a’s bits to the right for b spots.<ul><li>21 &#x3D; 10101</li><li>21 &gt;&gt; 3 &#x3D; 10<del>101</del> &#x3D; 10 &#x3D; 2</li></ul></li></ul><p><strong>Question</strong>: How do the program knows whether <code>&gt;&gt;</code> is <u>shifting bits</u> or <u>get from operator</u>?</p><p><strong>Answer</strong>: They depends on the provided arguments!</p><ul><li>when LHS is from <code>&lt;iostream&gt;</code> (<code>cin</code>), <code>&gt;&gt;</code> is “get from”</li><li>when LHS is int, <code>&gt;&gt;</code> is “shifting bits”</li><li>this is the very first example of function overloading:<ul><li>same function&#x2F;operator has multiple, different implementations &amp; meanings.<ul><li>the compiler choose wisely based on the provided <strong>number</strong> and <strong>type</strong> of the arguments, which are done at compile time.</li></ul></li></ul></li></ul><p><code>&gt;&gt;</code></p><p><code>cin &gt;&gt; i;</code></p><p>Let’s take a closer look at the <code>&gt;&gt;</code> operator:</p><ul><li>The <code>&gt;&gt;</code> operator has 2 operands:<ul><li><code>cin</code>, which is a stream</li><li><code>i</code>, a variable to receive the input data.</li></ul></li><li>And it returns on result:<ul><li><code>cin</code>, the same stream used as the first operand</li><li>it also has a <u>side effect</u></li></ul></li></ul><p>The fact that <u>it returns a stream (<code>cin</code>)</u>, is why we can chain a series of these together</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> cin &gt;&gt; x &gt;&gt; y &gt;&gt; z</span><br><span class="line">[cin &gt;&gt; x] -&gt; cin</span><br><span class="line">    = cin &gt;&gt; y &gt;&gt; z</span><br><span class="line">    [cin &gt;&gt; y] -&gt; cin</span><br><span class="line">     = cin &gt;&gt; z</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// READ Example v3:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(cin &gt;&gt; i)) <span class="keyword">break</span>; <span class="comment">// Reading into i and checking for failure</span></span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// READ Example v4:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; i) &#123; <span class="comment">// if we cannot get anymore input, then cin &gt;&gt; i is false</span></span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read all ints from stdin, echo them to stdout until EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// V1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">cin &gt;&gt; i;</span><br><span class="line"><span class="keyword">if</span> (cin.<span class="built_in">eof</span>()) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cin.<span class="built_in">fail</span>()) &#123; <span class="comment">// 1. Proper - print 2. EOF - break 3. Bad input - skip</span></span><br><span class="line">cin.<span class="built_in">clear</span>();  <span class="comment">// Reset the stream&#x27;s failure flag, the stream will not function after failure until you do this.</span></span><br><span class="line">cin.<span class="built_in">ignore</span>(); <span class="comment">// Removes the offending character from the stream.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">// 1. Proper - print 2. EOF - break 3. Bad input - skip</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cin &gt;&gt; i) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; hex &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; dec &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cin.<span class="built_in">eof</span>()) <span class="keyword">break</span>; <span class="comment">// Done - EOF</span></span><br><span class="line">        </span><br><span class="line">        cin.<span class="built_in">clear</span>();</span><br><span class="line">        cin.<span class="built_in">ignore</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note:</p><ul><li><code>clear()</code> must come before <code>ignore()</code>, called<code>ignore()</code> on a failed stream does nothing.</li><li><code>ignore()</code> removes 1 char from the stream.</li><li><code>ignore(count)</code> removes count chars from stream</li><li><code>ignore(count, &#39;\n&#39;)</code> removes count chars <u>or</u> everything up to and including the newline char, whatever comes first.</li></ul><p><u>Formatted Output</u></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="number">95</span> &lt;&lt; endl; <span class="comment">// Prints &quot;95&quot;</span></span><br><span class="line">cout &lt;&lt; hex &lt;&lt; <span class="number">95</span> &lt;&lt; endl; <span class="comment">// Prints 5F (95 in hexadecimal)</span></span><br></pre></td></tr></table></figure><p><code>hex</code>: I&#x2F;O manipulator - puts the stream into “hex mode” all subsequent integers are printed in hex.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; dec; <span class="comment">// switches the stream back to decimal mode.</span></span><br></pre></td></tr></table></figure><p>Example: print a dollar amount with leading asterisks in a width of 10 characters</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> m = <span class="number">10.9</span>;</span><br><span class="line"><span class="comment">// cout &lt;&lt; setprecision(2) &lt;&lt; 10.912345678 &lt;&lt; endl; Output: 11</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; right &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; m &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: *****10.90</span></span><br></pre></td></tr></table></figure><p>Note: Use import <code>&lt;iomanip&gt;;</code></p><ul><li>Manipulators set flags in the stream. These are effectively global variables. Changes you make affect the program from that point on.</li><li>Changes to the stream only lives to the end of the program. i.e. Once restart the program, stream is renewed.</li></ul><hr><h2 id="C-Features"><a href="#C-Features" class="headerlink" title="C++ Features"></a><u>C++ Features</u></h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>C strings: An array of <code>char</code> (<code>char *</code> or <code>char[]</code>) terminated by a <code>null char</code> (\0)</p><ul><li>must explicitly manage memory - allocate more memory as strings get bigger</li><li>easy to overwrite the \0 at the end.</li><li>one of the biggest sources of security vulnerabilities</li></ul><p>C++ strings: GOOD NEWS, built-in string data type.</p><ul><li>intuitive, easy-to-use</li><li>string grow as needed (no need to manage memory explicitly)</li><li>safer to manipulate.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">string s3 = s1 + <span class="string">&quot; &quot;</span> + s2;</span><br></pre></td></tr></table></figure><p>Note: C++ Strings are created from C string on initialization.</p><p>String operations:</p><ul><li>equality&#x2F;inequality: &#x3D;&#x3D;, !&#x3D;<code>s1 == s2</code> | <code>s1 != s2</code></li><li>comparisons: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, etc. (lexicographic by default)</li><li>length: <code>s.length()</code>. →  O(1) time. “String structure stores each string’s length”</li><li>concat: <code>s3 = s1 + s2;</code> <code>s3 += s1;</code> ← s3 need to be pre-defined.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (s1 == s2) cout &lt;&lt; <span class="string">&quot;same&quot;</span> &lt;&lt; endl; <span class="comment">// comparing strings NOT memory addresses</span></span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;not same&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li>individual chars:<ul><li><code>s[0]</code> - returns first char</li><li><code>s[1]</code> - returns second char</li></ul></li><li>mutable<ul><li><code>s[0] = &#39;h&#39;;</code></li></ul></li></ul><p>Example: Read Strings</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s; <span class="comment">// Skip leading whitespace, start reading, then stop at consequent whitespace.</span></span><br></pre></td></tr></table></figure><p>What if we want the whitespace?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin, s); <span class="comment">// getline(stream, string variable name)</span></span><br><span class="line"> <span class="comment">// Reads from current position up to next \n into s. (Excluding \n)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line">cin.<span class="built_in">get</span>(c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(cin.<span class="built_in">get</span>(c)) &#123;</span><br><span class="line">    cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Streams are an <u>abstraction</u>. “<em>They wrap an interface of “getting &amp; putting items” around the keyboard &amp; screen.</em>“</p><p>Are there other kinds of “<u>things</u>“ that could support the “<u>getting and putting</u>“ interface?</p><hr><h3 id="File-Stream-x2F-1"><a href="#File-Stream-x2F-1" class="headerlink" title="File Stream&#x2F;1"></a>File Stream&#x2F;1</h3><ul><li>read and write a file instead of stdin&#x2F;stdout.<ul><li><code>std::ifstream</code> - a file stream for reading</li><li><code>std::ofstream</code> - a file stream for writing</li><li>must import <code>&lt;fstream&gt;;</code></li></ul></li></ul><p>File access in C:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *f = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">char</span> s[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">fscanf</span>(f, <span class="string">&quot;%255s&quot;</span>, s);</span><br><span class="line">        <span class="keyword">if</span> (feof(f)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>File access in C++:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;iostream&gt;;</span><br><span class="line"><span class="keyword">import</span> &lt;fstream&gt;;</span><br><span class="line"><span class="keyword">import</span> &lt;string&gt;; <span class="comment">// import and compile string lastly!</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    ifstream f &#123;<span class="string">&quot;file.txt&quot;</span>&#125;; <span class="comment">// Declares and initializes the istream variable f. And opens the file.</span></span><br><span class="line">    <span class="keyword">while</span> (f &gt;&gt; s) &#123;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// File is closed automatically when the f variable goes out of scope: End of main().</span></span><br></pre></td></tr></table></figure><p>Note:</p><ul><li>Anything you can do with <code>cin</code>&#x2F;<code>cout</code>, you can do with an <code>ifstream</code>&#x2F;<code>ofstream</code>.</li></ul><h3 id="String-x2F-2"><a href="#String-x2F-2" class="headerlink" title="String&#x2F;2"></a>String&#x2F;2</h3><ul><li><code>import &lt;string&gt;;</code></li><li>Extract data from chars in a string: <code>std::istringstream</code>.</li><li>Send data to a string as chars: <code>std::ostringstream</code>.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;sstream&gt;;</span><br><span class="line"><span class="keyword">import</span> &lt;string&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// E.g. -&gt; convert int to string</span></span><br><span class="line"><span class="function">string <span class="title">intToString</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    ostringstream sock; <span class="comment">// stream that writes to a string</span></span><br><span class="line">    sock &lt;&lt; n;</span><br><span class="line">    <span class="keyword">return</span> sock.<span class="built_in">str</span>(); <span class="comment">//extract the string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s = <span class="built_in">intToString</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// E.g. -&gt; convert string to number</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Enter a number&quot;</span> &lt;&lt; endl;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s; <span class="comment">// Input the string</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (istringstream sock&#123;s&#125;; sock &gt;&gt; n) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I said, &quot;</span>; <span class="comment">// keep asking for new num until provided.</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You entered &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Compare the two implementations:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Earlier Version</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// if false, then something bad happened -&gt; EOF, bad input</span></span><br><span class="line"><span class="keyword">if</span> (! (cin &gt;&gt; i)) &#123;</span><br><span class="line"><span class="keyword">if</span> (cin.<span class="built_in">EOF</span>()) <span class="keyword">break</span>;</span><br><span class="line">cin.<span class="built_in">clear</span>(); <span class="comment">// resets stream (must be cleared before another read)</span></span><br><span class="line">cin.<span class="built_in">ignore</span>(); <span class="comment">// removes offensive character from the stream</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl; <span class="comment">// will be default printed as a decimal</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// E.g. -&gt; Echo all numbers, skip all non-numbers</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s) &#123; <span class="comment">// Only fail when EOF</span></span><br><span class="line">    <span class="comment">// ignores whitespace, read until the largest input</span></span><br><span class="line"><span class="comment">// read as a string</span></span><br><span class="line"><span class="comment">// read until hit whitespace or EOF</span></span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> (istringstream sock&#123;s&#125;; sock &gt;&gt; n) &#123;</span><br><span class="line"><span class="comment">// convert s into input string stream, then convert to int</span></span><br><span class="line">        <span class="comment">// local scope, every new iteration will clear off fail flags</span></span><br><span class="line">            cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// Else just continue the loop</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ex. 3.1415 is all read in cin, then we use it as an istringstream, but then </span></span><br><span class="line"><span class="comment">// we only print out 3 because the . after that isn&#x27;t an int so it stops</span></span><br><span class="line"></span><br><span class="line">abc123</span><br><span class="line">EX<span class="number">.1</span> -&gt; <span class="number">123</span>          EX<span class="number">.2</span> -&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">3.1415</span></span><br><span class="line">EX<span class="number">.1</span> -&gt;              EX<span class="number">.2</span> -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1415</span>            </span><br><span class="line"></span><br><span class="line"><span class="number">123</span>abc</span><br><span class="line">EX<span class="number">.1</span> -&gt; <span class="number">123</span>          EX<span class="number">.2</span> -&gt; <span class="number">123</span></span><br></pre></td></tr></table></figure><h3 id="Command-Line-Arguments"><a href="#Command-Line-Arguments" class="headerlink" title="Command Line Arguments"></a>Command Line Arguments</h3><p>To accept command line arguments in C or C++, always give main the following parameters:</p><p><code>int main(int argc, char *argv[]) &#123;...&#125;</code> where:</p><ul><li><code>int argc</code> stands for # of CMD Line Args<ul><li><code>argc</code> &gt;&#x3D; 1, where first value is the program name itself.</li></ul></li><li><code>char *argv[]</code> is an array of C-style strings<ul><li><code>argv[0]</code> &#x3D; program name</li><li><code>argv[1]</code> &#x3D; first arg</li><li><code>argv[2]</code> &#x3D; second arg</li><li>…</li><li><code>argv[argc]</code> &#x3D; NULL TERMINATOR</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example: ./myprog abc 123</span></span><br><span class="line"><span class="comment">// The program name is not a command line arguments, hence argc = 3 but 2 CLA</span></span><br><span class="line"></span><br><span class="line">argv = <span class="number">0</span> [] -&gt; <span class="string">&quot;. / m y p r o g \0&quot;</span></span><br><span class="line">       <span class="number">1</span> [] -&gt; <span class="string">&quot;a b c \0&quot;</span></span><br><span class="line">       <span class="number">2</span> [] -&gt; <span class="string">&quot;1 2 3 \0&quot;</span></span><br><span class="line">       <span class="number">3</span> [] -&gt; <span class="string">&quot;\0&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Recommendation: Convert to C++ style strings before processing</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>(<span class="type">int</span> argc, <span class="type">char</span> *argv[]) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">string arg = argv[i];</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// E.g. Print the sum of all numeric args on the cmd line.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        string arg = argv[i];</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> (istringstream sock&#123;args&#125;; sock &gt;&gt; n) sum += n;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// E.g. ./myprog &lt; input.txt</span></span><br><span class="line"><span class="comment">// redirection of data -&gt; treating it as it is input from the keyboard so 0</span></span><br><span class="line"><span class="comment">// command line arguments</span></span><br><span class="line"><span class="comment">// same as running ./myprog and typing it input -&gt; 0 command line arguments as</span></span><br><span class="line"><span class="comment">// well since program name isn&#x27;t a command line argument but argc = 1</span></span><br></pre></td></tr></table></figure><h3 id="Default-Function-Parameters"><a href="#Default-Function-Parameters" class="headerlink" title="Default Function Parameters"></a>Default Function Parameters</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFile</span><span class="params">(string name = <span class="string">&quot;file.txt&quot;</span>)</span> </span>&#123;</span><br><span class="line">    ifstream f &#123;name&#125;;</span><br><span class="line">    <span class="keyword">for</span> (string s; f &gt;&gt; s;) cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printFile</span>();<span class="comment">// Print &quot;file.txt&quot;</span></span><br><span class="line">    <span class="built_in">printFile</span>(<span class="string">&quot;othername.txt&quot;</span>);<span class="comment">// Print &quot;othename.txt&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note about behavior:</p><ul><li>optional parameters must be <u>last</u></li><li><code>int f(int n = 2, int y = 3, int z = 4) &#123; &#125;</code><ul><li><code>f(0)</code> → <code>f(0, 3, 4)</code></li><li><code>f(1, 2)</code> → <code>f(1, 2, 4)</code></li><li><code>f()</code> → <code>f(2, 3, 4)</code></li></ul></li></ul><p><u>Also note</u>: the missing parameter is supplied by the <u>caller</u>, not the <u>function</u>.</p><p><u>WHY</u>: </p><ul><li><p>The caller passes params by pushing them onto the stack.</p></li><li><p>The function fetches params by reading them from the stack from where they are expected to be.</p><ul><li>If an argument is missing, the function has no ways of knowing that.</li><li><u><strong>It would interpret whatever is in that part of the stack as the <code>arg</code>.</strong></u></li></ul></li><li><p>So instead, the <u><strong>caller</strong></u> must supply the extra param if it is missing.</p></li><li><p>Therefore, when writing <code>printFile();</code></p><ul><li><p>The compiler replaces this with <code>printFile(&quot;file.txt&quot;);</code></p><ul><li>Compiler do the duty for us, Function is duty-less.</li></ul></li><li><p><code>printFile();</code> → <code>printFile(&quot;file.txt&quot;);</code> → stack frame</p><p> write code          compilerun time</p></li></ul></li><li><p>For this reason, default arguments are part of a function’s <u>interface</u>, rather than its implementation.</p></li><li><p>If you are doing <u>separate compile</u>, defaults go in the <u>interface</u> file, not the <u>implementation</u> file.</p></li></ul><h3 id="Overloading"><a href="#Overloading" class="headerlink" title="Overloading"></a>Overloading</h3><p>In C:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">negInt</span><span class="params">(<span class="type">int</span> n)</span> &#123;<span class="keyword">return</span> -n;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">negBool</span><span class="params">(<span class="type">bool</span> t)</span> &#123;<span class="keyword">return</span> !b;&#125;</span><br></pre></td></tr></table></figure><p>In C++;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">neg</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;<span class="keyword">return</span> -n;&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">neg</span><span class="params">(<span class="type">bool</span> b)</span> </span>&#123;<span class="keyword">return</span> !b;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>The idea of having same function name for different implementations is called <u><strong>OVERLOADING</strong></u>.</p></li><li><p>Simplifies the code because reusing function with different # and types of parameters inside parameter lists is legit.</p></li><li><p>The <u>compiler</u> chooses the correct version of <code>neg()</code>, for each function call, at <u>compile-time</u>.</p><ul><li>Based on the # or types of the <code>args</code> in the function call.</li></ul></li></ul><p>Hence, <u><strong>OVERLOAD</strong></u> must differ in # or types of arguments</p><ul><li>Just differing return type is not enough.<ul><li>Example (Already seen): <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>+</code><ul><li>Their behavior depends on types of arguments.</li></ul></li></ul></li></ul><h3 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h3><p>In C++;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next; <span class="comment">// No need to say struct Node *next;</span></span><br><span class="line">&#125;; <span class="comment">// Don&#x27;t forget the semicolon</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WHY?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125; n1, n2, n3; <span class="comment">// You can initialize instances of Node after declaring the Node.</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">Node next; <span class="comment">// This is wrong</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Constants"><a href="#Constants" class="headerlink" title="Constants"></a>Constants</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> passingGrade = <span class="number">50</span>; <span class="comment">// Must be initialized</span></span><br></pre></td></tr></table></figure><ul><li>Declare as many things <code>const</code> as you can, it help catches errors.</li></ul><p>Constant Node</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node n &#123;<span class="number">5</span>, <span class="literal">nullptr</span>&#125;; <span class="comment">// Syntax for null ptrs in C++</span></span><br><span class="line"><span class="comment">// Don&#x27;t say NULL or 0 in C++!</span></span><br></pre></td></tr></table></figure><p>Interesting notes:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span></span>;  <span class="comment">// Taking int</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> *p)</span></span>; <span class="comment">// Taking ptr</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>Use the null pointer to indicate nullity.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Node n2 = n; <span class="comment">// Immutable copy of n</span></span><br><span class="line">   <span class="comment">// n mutable, n2 not mutable</span></span><br></pre></td></tr></table></figure><h3 id="Parameter-Passing"><a href="#Parameter-Passing" class="headerlink" title="Parameter Passing"></a>Parameter Passing</h3><p>Recall:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pass a value</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; ++n; &#125;</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">inc</span>(x);</span><br><span class="line">cout &lt;&lt; x;</span><br><span class="line"><span class="comment">// Print 5</span></span><br><span class="line"><span class="comment">// Consequence of Pass-by-Value</span></span><br><span class="line"><span class="comment">// inc gets a copy of x, mutates the copy</span></span><br><span class="line"><span class="comment">// the original is unchanged</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A Solution would be -- As in CS136</span></span><br><span class="line"><span class="comment">// Pass a pointer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span> <span class="params">(<span class="type">int</span> *n)</span> </span>&#123;++*n;&#125;</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">inc</span>(&amp;x); <span class="comment">// x&#x27;s address, inc changes the data at that address</span></span><br><span class="line">cout &lt;&lt; x;</span><br><span class="line"><span class="comment">// Print 6</span></span><br><span class="line"><span class="comment">// Consequence of Pass-by-Reference</span></span><br><span class="line"><span class="comment">// Visible to the caller.</span></span><br></pre></td></tr></table></figure><p>Q: Why <code>cin&gt;&gt;x</code> and not <code>cin &gt;&gt; &amp;x</code>?</p><p>A: <strong>C++ has another pointer-like type - <u>references</u></strong></p><h4 id="References-Important"><a href="#References-Important" class="headerlink" title="References - Important"></a><u>References</u> - <strong>Important</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;z = y; <span class="comment">// z is an lvalue reference to y</span></span><br><span class="line"><span class="comment">// imagine z as a const ptr</span></span><br><span class="line"><span class="comment">// similar to int *const z = &amp;y</span></span><br></pre></td></tr></table></figure><p>References are like const pointers with automatic dereferencing.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z = <span class="number">12</span> (Not *z = <span class="number">12</span>) <span class="comment">// now y == 12</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = &amp;z;</span><br></pre></td></tr></table></figure><p>In all cases, z behaves <u>exactly</u> like y.z is an <u>alias</u> (another name) for y.</p><p><strong>Question</strong>: How can we tell when &amp; means “reference” vs. “address of”</p><p>[^]: Overloading, but how??</p><p><strong>Answer</strong>: Whenever &amp; occurs as part of type (e.g. <code>int &amp;z</code>), it always means <strong>references</strong>. When &amp; occurs in an expression (e.g. <code>inc(&amp;z)</code>), it means <strong>address of</strong> (or bitwise-and).</p><p>Things you can’t do with lvalue references</p><ul><li>Leave them <strong>uninitialized</strong>e.g. <code>int &amp;z</code> - Illegal<ul><li>must be initialized with something that has an address (an lvalue), since refs and ptrs.<ul><li>x &#x3D; y<ul><li>y &#x3D; right value (interested in actual value)</li><li>x &#x3D; left value (interested in its location)<ul><li>Has to denote a location (Has an address)</li></ul></li></ul></li></ul></li><li><code>int &amp;x = 3;</code> is illegal<ul><li>3 doesn’t has an address</li></ul></li><li><code>int &amp;x = y+z;</code> is illegal<ul><li>y + z doesn’t has an address</li></ul></li><li><code>int &amp;x = y</code>; legal<ul><li>y has an address (lvalue)</li></ul></li></ul></li><li>create a <strong>pointer to a reference</strong><ul><li><code>int &amp;* p;</code> illegal<ul><li>a pointer to a reference to an int</li></ul></li><li><code>int *&amp; p;</code> legal<ul><li>a reference to a pointer to an int</li></ul></li></ul></li><li>create a <strong>reference to a reference</strong><ul><li><code>int &amp;&amp; r = ...</code> illegal<ul><li>perhaps simply use a reference directly to the value</li><li>will compile!<ul><li>&amp;&amp; means something different (later)</li></ul></li></ul></li></ul></li><li>create an <strong>array of references</strong><ul><li><code>int &amp;r[] = &#123;_, _, _&#125;;</code> illegal</li></ul></li></ul><p>Things that you can do</p><ul><li>Pass as <strong>function parameters</strong><ul><li><code>void inc(int &amp;n) &#123;++n;&#125; // No pointer deref</code><ul><li>const ptr to the arg (x), changes will affect x</li><li><code>int x = 5; inc(x); count &lt;&lt; x; // 6</code></li></ul></li></ul></li></ul><p>Then why does <code>cin &gt;&gt; x</code> work?Takes x as a reference</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;<span class="keyword">operator</span> &gt;&gt; (istream &amp;in, <span class="type">int</span> &amp;x);</span><br></pre></td></tr></table></figure><p><strong>Question:</strong> Why is the stream being taken &amp; returned as a ref? And what does returning by ref mean?</p><p><strong>Answer:</strong> Need a better understanding of the cost of parameter passing.</p><p>Pass-by-value, e.g. <code>int f(int n) &#123;...&#125;</code> copies the arguments.</p><ul><li>if the arguments are big, copy is <strong>expensive</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReallyBig</span>&#123;......&#125; <span class="comment">// Very big structure</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span> <span class="params">(ReallyBig rb)</span> </span>&#123;...&#125; <span class="comment">// this is a copy - this is slow</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span> <span class="params">(ReallyBig &amp;rb)</span> </span>&#123;...&#125; <span class="comment">// this is an alias - this is fast / Could change rb in the caller</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">h</span> <span class="params">(<span class="type">const</span> ReallyBig &amp;rb)</span> </span>&#123;...&#125; <span class="comment">// alias - this is fast / Could not change rb in the caller</span></span><br></pre></td></tr></table></figure><p>If applicable, Pick reference over pointers</p><ul><li>Const - Can’t change where reference points to</li><li>References can never be null - no need to worry</li></ul><p>What if a function <u>does</u> want to make changes to <code>rb</code> locally, but does not want these changes visible to the caller? (Being fast)</p><p>Then the function must make a local copy of rb:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">k</span><span class="params">(<span class="type">const</span> ReallyBig &amp;rb)</span> </span>&#123;</span><br><span class="line">ReallyBig rb2 = rb; <span class="comment">// Copy rb to rb2, still slow isn&#x27;t it</span></span><br><span class="line">    <span class="comment">// Mutate rb2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>But if you have to make a copy anyway, it’s better to just use <u>pass-by-value</u> and have the compiler make it for you - maybe it can optimize something.</p><p><u>Advice</u>:</p><ul><li>Prefer <u>pass-by-const-ref</u> over <u>pass-by-value</u> for  anything larger than a pointer, unless the function needs to make a copy anyway - then just use <u>pass-by-value</u>.</li></ul><p><u>Also</u>: <code>int f(int &amp;n);</code><code>int g(const int &amp;n);</code></p><ul><li><code>f(5);</code> illegal, can’t initialize an lvalue ref (n) to a literal value (non-lvalue)<ul><li><u>if n changes, can’t change the literal 5.</u></li></ul></li><li><code>g(5);</code> legal, since n can never be changed ↑, the <strong>compiler allows this</strong>.<ul><li><strong><u>HOW?</u></strong> <u>important</u> - the 5 is stored in a <u>temporary</u> location (<strong>stack</strong>)<ul><li>so the ref has something to point to → towards somewhere in the stack<ul><li>example putting const makes function more applicable</li></ul></li></ul></li></ul></li></ul><p>So, in the case of</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;<span class="keyword">operator</span> &gt;&gt; (istream &amp;in, <span class="type">int</span> &amp;x);</span><br></pre></td></tr></table></figure><p>the <code>istream</code> is passed and returned by reference to save copying.</p><p><strong>IMPORTANT</strong>: because stream variable are <u>not allowed</u> to be copied.</p><h3 id="Dynamic-Memory"><a href="#Dynamic-Memory" class="headerlink" title="Dynamic Memory"></a>Dynamic Memory</h3><p>In C:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="built_in">malloc</span>(# * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">...</span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">// DON&#x27;T USE THESE IN C++!</span></span><br></pre></td></tr></table></figure><p>In C++: <u>new&#x2F;delete</u> - type-aware, less error-prone</p><ul><li>knew the memories, doesn’t have to manually allocate</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example</span></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">// Creates an int object on the heap</span></span><br><span class="line">*p = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">// Deallocates the memory of the int. pis still a &quot;dangling pointer&quot;.</span></span><br><span class="line">p = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;...&#125;;</span><br><span class="line"><span class="comment">// Create</span></span><br><span class="line">Node *np = <span class="keyword">new</span> Node; <span class="comment">// Creates a Node object on the heap. Returns a pointer to it.</span></span><br><span class="line"><span class="comment">// Delete</span></span><br><span class="line"><span class="keyword">delete</span> np; <span class="comment">// Deallocates memory. np is dangling pointer</span></span><br><span class="line">np = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;...&#125;</span><br><span class="line">Node *np = <span class="keyword">new</span> Node; <span class="comment">// keyword new, want a Node, it gets space from type defn</span></span><br><span class="line"><span class="comment">// np is stored on the stack, the node np points to is on the heap</span></span><br><span class="line"></span><br><span class="line">stackheap</span><br><span class="line">__________________________</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">_____________</span><br><span class="line">p: <span class="type">int</span>* ----------&gt; <span class="type">int</span>: <span class="number">10</span>    </span><br><span class="line"></span><br><span class="line">np: node* --------&gt; node: []</span><br><span class="line">  []</span><br><span class="line">__________________________</span><br><span class="line"></span><br><span class="line"><span class="comment">// later on we need to delete np;</span></span><br><span class="line"><span class="comment">// delete only deallocate the memories on the heap</span></span><br><span class="line"><span class="comment">// p and np remains on stack as dangling pointers</span></span><br></pre></td></tr></table></figure><p>All <u>local</u> variables and <u>function parameters</u> reside on the the stack</p><ul><li>they are deallocated automatically when they go out of the scope (<u>stack</u> is popped)<ul><li>if they are pointers, the memory they point to is <u>not</u> deallocated automatically (require manual delete).</li></ul></li><li><code>new</code> allocated memory resides on the <u>heap</u></li><li>remains allocated until delete is called<ul><li>if don’t delete all allocated memory → Memory Leak.</li></ul></li><li>Calling <u>delete</u> on the same pointer more than once is an error.<ul><li>Program will crash: SEGV</li></ul></li><li>Calling <u>delete</u> on a <code>nullptr</code> is harmless - safe and acceptable.</li><li>Never call <u>delete</u> on a stack-allocated object  → program will crash</li></ul><h3 id="Methods-of-returning-values"><a href="#Methods-of-returning-values" class="headerlink" title="Methods of returning values"></a>Methods of returning values</h3><p>Return by value:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Okay</span></span><br><span class="line"><span class="function">Node <span class="title">getmeANode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node n;-------&gt; Stack <span class="keyword">for</span> getmeANode</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">Node n1 = <span class="built_in">getmeANode</span>(); -------&gt; Stack <span class="keyword">for</span> calling function</span><br><span class="line"><span class="comment">// Copying</span></span><br></pre></td></tr></table></figure><p>Return by pointer:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BAD</span></span><br><span class="line"><span class="function">Node *<span class="title">getmeANode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node n;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> &amp;n;</span><br><span class="line">&#125;</span><br><span class="line">Node *n1 = <span class="built_in">getmeANode</span>(); <span class="comment">// BAD: We are returning a pointer to a stack-allocated data which is DEAD on return.</span></span><br></pre></td></tr></table></figure><p>Return by reference:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BAD</span></span><br><span class="line"><span class="function">Node &amp;<span class="title">getmeANode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node n;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">Node &amp;n1 = <span class="built_in">getmeANode</span>(); <span class="comment">// Also BAD, returning a reference which is an alias to a DEAD data on return.</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recall example in operator &gt;&gt;</span></span><br><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;in, <span class="type">int</span> &amp;n) &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> in; <span class="comment">// GOOD since in is outside of function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Return by Pointer (Fixed):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">getmeANode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node *np = <span class="keyword">new</span> Node; <span class="comment">// New a node onto heap</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> np; <span class="comment">// return address of np</span></span><br><span class="line">&#125;</span><br><span class="line">Node *n1 = <span class="built_in">getmeANode</span>(); <span class="comment">// n1 stores a copy of address of the node on the heap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This version transfers ownership of that allocated memory to the caller of the function (or other function). The caller is responsible for calling delete. </span></span><br></pre></td></tr></table></figure><ul><li><p>Why is it okay to return a reference here? </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;operator&gt;&gt;(istream &amp;in, int &amp;n)</span><br></pre></td></tr></table></figure><ul><li>main: <code>cin &gt;&gt; n</code></li><li>the argument istream &amp;in was already available to the caller of operator &gt;&gt; so returning a reference back to it is okay</li><li>cin and n are in main so when you return the istream, you are returning it in main, not out of scope when istream is finished</li></ul></li></ul><h3 id="Operator-Overloading"><a href="#Operator-Overloading" class="headerlink" title="Operator Overloading"></a>Operator Overloading</h3><p>Recall from earlier how the <code>&lt;&lt;</code>and <code>&gt;&gt;</code> operators were overloaded to be used for input&#x2F;output, We can actually overload any operator to have customized behavior for certain input types. Most notably, this includes user-defined types (<code>struct</code>s and <code>class</code>es).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;return_type&gt; <span class="built_in">operator</span>&lt;op&gt;(...&lt;<span class="built_in">input</span> (s)&gt;...) &#123;</span><br><span class="line">... <span class="comment">// Perform computation</span></span><br><span class="line"><span class="keyword">return</span> &lt;return_value&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let’s consider a custom structure</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line">Vec <span class="keyword">operator</span>+(<span class="type">const</span> Vec &amp;v1, <span class="type">const</span> Vec &amp;v2) &#123;</span><br><span class="line">    Vec v &#123;v1.x + v2.x, v1.y + v2.y&#125;;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line">Vec <span class="keyword">operator</span>*(<span class="type">const</span> Vec &amp;v, <span class="type">const</span> <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;v.x * k, v.y * k&#125;; <span class="comment">// Compiler knows we&#x27;re talking about Vec structure</span></span><br><span class="line">&#125;</span><br><span class="line">Vec <span class="keyword">operator</span>*(<span class="type">const</span> <span class="type">int</span> k, <span class="type">const</span> Vec &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> v * k;</span><br><span class="line">&#125; <span class="comment">// This fixes v5&#x27;s problem</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vec v1&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    Vec v2&#123;<span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    Vec v3 = v1 + v2; <span class="comment">// Uses operator + function</span></span><br><span class="line">    Vec v4 = v1 * <span class="number">10</span>; <span class="comment">// Uses the operator * function</span></span><br><span class="line">    Vec v5 = <span class="number">10</span> * v1; <span class="comment">// Does not work yet!</span></span><br><span class="line">    Vec v6 = (v1 + v2) * <span class="number">5</span>; <span class="comment">// Chaining them together</span></span><br><span class="line">    Vec v7 = v1 + v2 * <span class="number">5</span> <span class="comment">// First * then -, precedence remains after overloading.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Example:</strong> Overloading <code>&gt;&gt;</code> and <code>&lt;&lt;</code> operators</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; v1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> Vec &amp;v) &#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; v.x &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; v.y &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream *in, Vec &amp;v) &#123; <span class="comment">// Can&#x27;t be a const Vec</span></span><br><span class="line">    <span class="type">char</span> p1, c, p2;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    in &gt;&gt; p1 &gt;&gt; x &gt;&gt; c &gt;&gt; y &gt;&gt; p2;</span><br><span class="line">    <span class="comment">// Check that data is was formatted correctly</span></span><br><span class="line">    <span class="keyword">if</span> (!in.<span class="built_in">fail</span>() &amp;&amp; p1 == <span class="string">&#x27;(&#x27;</span> &amp;&amp; c == <span class="string">&#x27;,&#x27;</span> &amp;&amp; p2 == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">        v.x = x;</span><br><span class="line">        v.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vec v;</span><br><span class="line">    cin &gt;&gt; v; <span class="comment">// read in Vector v</span></span><br><span class="line">    cout &lt;&lt; v; <span class="comment">// write out Vector v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>When programming, we can split our programs into multiple modules, where each module provides both: an <strong>interface</strong> and an <strong>implementation</strong>.</p><ul><li><strong>Interface (<code>.h</code>):</strong> Declaration, Type definitions and prototypes for functions.</li><li><strong>Implementation (<code>.cc</code>):</strong> Full definitions for every provided function.</li></ul><p><strong>Interface File (Vec.cc):</strong> New syntax for C++20 and is NOT backward-compatible with <code>#include</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example Interface (Vec.cc)</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> Vec; <span class="comment">// This tells the compiler that this is the module interface file. We can only have one per module.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">struct</span> <span class="title class_">Vec</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> Vec <span class="keyword">operator</span>+(<span class="type">const</span> Vec &amp;v1, <span class="type">const</span> Vec&amp;v2);</span><br><span class="line"><span class="keyword">export</span> Vec <span class="keyword">operator</span>*(<span class="type">const</span> Vec &amp;v, <span class="type">const</span> <span class="type">int</span> k);</span><br></pre></td></tr></table></figure><p><strong>Implementation File (<code>Vec-impl.cc</code>)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Implementations</span></span><br><span class="line"><span class="keyword">module</span> Vec;</span><br><span class="line"></span><br><span class="line">Vec <span class="keyword">operator</span>+(<span class="type">const</span> Vec&amp; v1, <span class="type">const</span> Vec&amp; v2) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;v1.x + v2.x, v1.y + v2.y&#125;;</span><br><span class="line">&#125; </span><br><span class="line">Vec <span class="keyword">operator</span>*(<span class="type">const</span> Vec&amp; v, <span class="type">const</span> <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;v.x * k, v.y * k&#125;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>Client Code (<code>main.cc</code>)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client</span></span><br><span class="line"><span class="keyword">import</span> Vec; <span class="comment">// Importing the module, no &lt;&gt; since this is user module not a system module.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vec v1&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    Vec v2 = v1 + v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note:</p><ul><li>Interface file starts with export module (______);</li><li>Implementation files starts with module (______);</li><li>Client files use import (______);</li><li>These lines must be the first line</li></ul><h3 id="Separate-Compilation"><a href="#Separate-Compilation" class="headerlink" title="Separate Compilation"></a>Separate Compilation</h3><p>Speed up compilation by only compiling what’s necessary.</p><p>Files are compiled in dependency order:</p><ol><li>Interface files first</li><li>Implementation &#x2F; Client code second</li></ol><p>Separate Compilation in dependency order:</p><p><code>-c</code>: Produces an Object file (<code>.o</code>); Only compiling the file without linking, neither create an executable.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++<span class="number">20</span> -c Vec.cc <span class="comment">// Creates Vec.o</span></span><br><span class="line">g++<span class="number">20</span> -c Vec-impl.cc</span><br><span class="line">g++<span class="number">20</span> -c main.cc</span><br></pre></td></tr></table></figure><p>The command to link all the object files and produces an executable is:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++<span class="number">20</span> Vec.o Vec-impl.o main.o -o main</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++<span class="number">20</span> Vec-impl.o main.o -o main <span class="comment">// Omitting Vec.o is Valid, compiler knows which interface file is corresponding from gcm.cache.</span></span><br></pre></td></tr></table></figure><p>Now the executable file can be run as</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br></pre></td></tr></table></figure><p>We must compile interface files in C++ unlike in C where we only include header files (<code>.h</code>) inside the implementation files.</p><p>We must always compile system libraries&#x2F;modules before compiling any user-defined modules.</p><p><img src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202409241210809.jpg" alt="Module Graph"></p><p><code>A -&gt; B</code> means A <u>depends on</u> B. If we were compiling, we would need to compile B <u>first</u>.</p><h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p>Classes are the main difference between C and C++.</p><p>Simply speaking, a <code>class</code> is a <code>struct</code> with functions in it.</p><p><strong>Example:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student.cc</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="type">int</span> assignments, midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">grade</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student-impl.cc</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Student::grade</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> assignments * <span class="number">0.4</span> + midterm * <span class="number">0.2</span> + <span class="keyword">final</span> * <span class="number">0.4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s&#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;;</span><br><span class="line">    cout &lt; s.grade &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Implementation of a class function can be either in interface file (inside the struct) or in implementation file. Writing in implementation file is recommended.</p><p><code>Student</code> is a class. The functions in it gives the struct <u>behavior</u>.</p><p><code>s</code> is an object - a particular instance of a class.</p><p><code>assignments</code> <code>midterm</code> and <code>final</code> are called <u>data members</u>, or <u>member fields</u> or (<u>fields</u>), or <u>member variables</u>.</p><p><code>::</code> - “scope resolution operator”. Locate the context. Define a function inside a class, also provide namespace.</p><p><code>Student::grade</code> is a “member function” or “method”. (Meaning grade in the context of class Student)</p><p>The fields: assignments, midterm, and final are fields of the <u>receiver object</u> - the object upon which the grade method was called.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.<span class="built_in">grade</span>(); <span class="comment">// method call | uses s1&#x27;s data members.</span></span><br></pre></td></tr></table></figure><p>Question: What do assignments, midterm, final mean inside of Student::grade?</p><ul><li>They are fields of the receiver object - the object upon which graded was called.</li><li>How do we know which data in the structure’s field corresponds to which receiver object?</li></ul><p>Formally, every <u>method</u> has a hidden extra parameter called <u><code>this</code></u>, which is a <u>pointer</u> (not a reference) to the receiver object. (It is a pointer to the object that the method was called on)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We write</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">grade</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">          assignments * <span class="number">0.4</span></span><br><span class="line">        + midterm * <span class="number">0.2</span></span><br><span class="line">        + <span class="keyword">final</span> * <span class="number">0.4</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">grade</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compiler re-writes as</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">grade</span><span class="params">(Student *<span class="keyword">this</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">          <span class="keyword">this</span>-&gt;assignments * <span class="number">0.4</span></span><br><span class="line">        + <span class="keyword">this</span>-&gt;midterm * <span class="number">0.2</span></span><br><span class="line">        + <span class="keyword">this</span>-&gt;<span class="keyword">final</span> * <span class="number">0.4</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">grade</span>();</span><br></pre></td></tr></table></figure><p>Inside the function, <code>&lt;var&gt;</code> and <code>this-&gt;&lt;var&gt;</code> is the same thing, so they can be used interchangeably, when <code>&lt;var&gt;</code> is any fields inside the class&#x2F;struct.</p><h2 id="Big-Five"><a href="#Big-Five" class="headerlink" title="Big Five"></a><u>Big Five</u></h2><p>These are methods you may have to implement in your classes.</p><ol><li>Constructors (<code>ctor</code>)</li><li>Copy Constructors (<code>cctor</code>, copy <code>ctor</code>)</li><li>Destructors (<code>dtor</code>)</li><li>Copy assignment operators</li><li>move constructors</li><li>move assignment operator</li></ol><h3 id="Constructors-Initializing-Objects"><a href="#Constructors-Initializing-Objects" class="headerlink" title="Constructors (Initializing Objects)"></a>Constructors (Initializing Objects)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student s1 &#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;  <span class="comment">// Ok but limited</span></span><br><span class="line">Student s2 &#123;<span class="number">-100</span>, <span class="number">1000</span>&#125;; <span class="comment">// Valid, but doesn&#x27;t create a valid Student</span></span><br></pre></td></tr></table></figure><p>To control how objects are created, write a constructor (<u>ctor</u>). Constructors have no return type and have the same name as the class&#x2F;struct.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student.cc</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> assns, mt, <span class="keyword">final</span>;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">grade</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> assns, <span class="type">int</span> mt, <span class="type">int</span> <span class="keyword">final</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student-impl.cc</span></span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="type">int</span> assns, <span class="type">int</span> mt, <span class="type">int</span> <span class="keyword">final</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span> -&gt; assns = assns;</span><br><span class="line">    <span class="keyword">this</span> -&gt; mt = mt;</span><br><span class="line">    <span class="keyword">this</span> -&gt; <span class="keyword">final</span> = <span class="keyword">final</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cc</span></span><br><span class="line">Student s &#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;; <span class="comment">// Much Better</span></span><br><span class="line">Student s = Student&#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125; <span class="comment">// Equivalent to above line</span></span><br><span class="line">Student *p = <span class="keyword">new</span> Student&#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;; <span class="comment">// Heap initialization</span></span><br></pre></td></tr></table></figure><p>When there is a constructor, program passes the arguments to the constructor. When there is not, then this is C-style field-by-field initialization. C-style struct initialization is only available if you have not written a constructor.</p><p>The major benefits of constructors is that they are functions and can thus be customized as such:</p><ul><li>Argument bounds checking</li><li>Default parameters</li><li>Overloading</li><li>Sanity checks</li></ul><p>Any constructor that can be called with 0 arguments is a “default constructor”. This can be either the constructor has no arguments or because it has default parameters. If we do not write any constructors, then the compiler provides the default constructor.</p><p>Compiler-provided default constructor:</p><ul><li>Primitive fields(<code>bool</code>, <code>int, </code>char&#96;, pointers) - left uninitialized</li><li>Object fields(<code>class</code>, <code>struct</code>) - calls the object’s default constructor</li></ul><p><strong>Example:</strong> Class with default constructor</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> [</span><br><span class="line"><span class="type">int</span> assns, mt, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> assns = <span class="number">0</span>, <span class="type">int</span> mt = <span class="number">0</span>, <span class="type">int</span> <span class="keyword">final</span> = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span> -&gt; assns = assns; <span class="keyword">this</span> -&gt; mt = mt; <span class="keyword">this</span> -&gt; <span class="keyword">final</span> = <span class="keyword">final</span>;</span><br><span class="line">    &#125;</span><br><span class="line">] </span><br><span class="line"></span><br><span class="line">Student s2&#123;<span class="number">70</span>, <span class="number">80</span>&#125;; <span class="comment">// 70, 80, 0 &quot;final&quot; is left as 0 by the ctor</span></span><br><span class="line">Student newKid; <span class="comment">// 0, 0, 0 (0-argument ctor invoked)</span></span><br><span class="line">Student newKid&#123;&#125;; <span class="comment">// Both this and above calls ctor</span></span><br></pre></td></tr></table></figure><p>Whenever an object is created, a constructor is always called.</p><p>If we do not have a default constructor for a class, that can cause issues with any classes containing classes without default constructor. Remember this is only an issue when we provide our own custom  constructor as compiler provides a default constructor by default.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec</span> &#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Vec</span>(intx, <span class="type">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">this</span> -&gt; x = x;</span><br><span class="line">        <span class="keyword">this</span> -&gt; y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Vec v&#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// OK</span></span><br><span class="line">Vec vl  <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Basis</span> &#123;</span><br><span class="line">Vec v1, v2; <span class="comment">// Note Vec doesn&#x27;t has a default ctor</span></span><br><span class="line">&#125;;</span><br><span class="line">Basis b;</span><br></pre></td></tr></table></figure><p>The built-in default <code>ctor</code> for Basis would attempt to default-construct all fields that are objects: v1 and v2 are objects. Since they have no default <code>ctor</code>, Basis cannot have a built-in default <code>ctor</code>.</p><p>Providing a default constructor might seem to work but it actually does not solve the issue.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Basis</span> &#123;</span><br><span class="line">    Vec v1, v2; <span class="comment">// v1 and v2 are already first constructed here</span></span><br><span class="line">    <span class="built_in">Basis</span>() &#123;</span><br><span class="line">        v1 = Vec&#123;<span class="number">1</span>, <span class="number">0</span>&#125;; <span class="comment">// Too late</span></span><br><span class="line">        v2 = Vec&#123;<span class="number">0</span>, <span class="number">1</span>&#125;; <span class="comment">// Too late</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>NOTE:</strong> Whenever we have a usable object in C++, it has been constructed at some point.</p><p>The body of the <code>ctor</code> can contain arbitrary code, so the <strong>fields</strong> of the class are expected to be constructed &amp; ready to use before the <code>ctor</code> body runs.</p><p>Steps for object creation:</p><ol><li>Enough space is allocated</li><li>Fields are constructed in declaration order (i.e. <code>ctor</code> run for fields that are objects)</li><li><code>ctor</code> body runs</li></ol><p>Initialization of v1, v2 must happen in step 2, not step 3. How to accomplish that?</p><p>We can fix this issue with a <strong>Member Initialization List (MIL)</strong>. The MIL provides default values to initialize the fields with in step 2 instead of using the default constructor.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student::<span class="built_in">Student</span>(<span class="type">int</span> assns, <span class="type">int</span> mt, <span class="type">int</span> <span class="keyword">final</span>):</span><br><span class="line">assns&#123;assns&#125;, mt&#123;mt&#125;, <span class="keyword">final</span>&#123;<span class="keyword">final</span>&#125; &#123;&#125; <span class="comment">// var: fields, &#123;var&#125;: parameters</span></span><br></pre></td></tr></table></figure><p><strong>NOTE</strong>: We can initialize any field this way, not just object fields.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For Basis</span></span><br><span class="line">Basis::<span class="built_in">Basis</span>(): v1&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, v2&#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#123;&#125;</span><br></pre></td></tr></table></figure><p>More generally:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struc Basis&#123;</span><br><span class="line">Vec v1, v2;</span><br><span class="line"><span class="built_in">Basis</span>(<span class="type">const</span> Vec &amp;v1, <span class="type">const</span> Vec &amp;v2):</span><br><span class="line">v1&#123;v1&#125;, v2&#123;v2&#125; &#123;&#125; <span class="comment">// Sth to think about: What ctor is running here?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>NOTE:</strong> The MIL is <strong>ONLY</strong> provided in the interface file.</p><p>For something like the <code>Basis</code> class, we generally want 2 different constructors:</p><ol><li>Default Constructor</li><li>Custom Constructor (user provides all fields)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Option 1: Providing default values in the default constructor</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Basis</span>&#123;</span><br><span class="line">    Vec v1, v2;</span><br><span class="line">    <span class="built_in">Basis</span>(): v1&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, v2&#123;<span class="number">0</span>, <span class="number">1</span>&#125; &#123;&#125;</span><br><span class="line">    <span class="built_in">Basis</span>(<span class="type">const</span> vec&amp; v1, <span class="type">const</span> vec&amp; v2): v1&#123;v1&#125;, v2&#123;v2&#125; &#123;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Option 2: Providing default values in the declaration</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Basis</span>&#123;</span><br><span class="line">    Vec v1&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, v2&#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">Basis</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Basis</span>(<span class="type">const</span> vec&amp; v1, <span class="type">const</span> vec&amp; v2): v1&#123;v1&#125;, v2&#123;v2&#125; &#123;&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>If there’s no MIL provided, then the default values provided during declaration are used. Fields are initialized <u>based on the order in which they were declared in the class</u>, even if the MIL order them differently. The order of the fields in the MIL doesn’t matter.</p><p>Using the MIL is sometimes more efficient than setting fields in the <code>ctor</code> body. Since for the constructor body, each object needs to be default constructed first before it’s overwritten is reset to the provided value. This causes extra memory write cycles. Hence it is recommended to use MIL whenever possible.</p><p>Consider:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> assns, mt, <span class="keyword">final</span>; <span class="comment">// not objects</span></span><br><span class="line">    string name; <span class="comment">// object</span></span><br><span class="line">    <span class="built_in">Student</span> (<span class="type">int</span> assns, <span class="type">int</span> mt, <span class="type">int</span> <span class="keyword">final</span>, string name) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;assns = assns;</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">this</span>-&gt;name = name; <span class="comment">// name is default constructed to an empty string in Step 2, and reassigned here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Versus MIL:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stuent</span> &#123;</span><br><span class="line"><span class="built_in">Student</span> (<span class="type">int</span> assns, <span class="type">int</span> mt, <span class="type">int</span> <span class="keyword">final</span>, string name): assns&#123;assns&#125;, mt&#123;mt&#125;, <span class="keyword">final</span>&#123;<span class="keyword">final</span>&#125;, name&#123;name&#125; &#123;&#125; <span class="comment">// name is initialized to the correct value in step 2. No reassignment in step 3. More efficient.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>An MIL <strong>must</strong> be used for any fields that satisfy any of these conditions:</p><ol><li>objects with no default constructor</li><li>const or references</li></ol><h3 id="Copy-Constructors"><a href="#Copy-Constructors" class="headerlink" title="Copy Constructors"></a>Copy Constructors</h3><p>Consider:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> assns, mt, <span class="keyword">final</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Student s&#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;;</span><br><span class="line">Student r&#123;s&#125;;</span><br><span class="line">Student s2 = s;</span><br></pre></td></tr></table></figure><p>Examples shown above invoke the copy constructor that we get for free. It creates an object from another of the same type. By default, the compiler-provided constructor copies each field from the original object into the object being constructed.</p><p>Note: Every class comes with</p><ol><li>Constructors (default-constructs all fields that are objects)<ol><li>lost if you write any custom constructor</li></ol></li><li>Destructors (frees up memory when the object is created)</li><li>Copy Constructors (just copies all fields)</li><li>Copy assignment operators</li><li>move constructors</li><li>move assignment operator</li></ol><p><strong>Example:</strong> Copy constructor for Student class</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> assns, mt, <span class="keyword">final</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> Student &amp;other): assns&#123;other.assns&#125;, mt&#123;other.mt&#125;, <span class="keyword">final</span>&#123;other.<span class="keyword">final</span>&#125; &#123;&#125;</span><br><span class="line">    <span class="comment">// Equivalent to built-in copy constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It is important to note that adding ANY constructor (including a copy or more constructor) will remove the compiler-provided default constructor.</p><p>Example: When we cannot use the compiler provided copy constructor</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line">Node *n = <span class="keyword">new</span> Node &#123;<span class="number">1</span>, <span class="keyword">new</span> Node&#123;<span class="number">2</span>, <span class="keyword">new</span> Node&#123;<span class="number">3</span>, <span class="literal">nullptr</span>&#125;&#125;&#125;;</span><br><span class="line">Node m = *n;</span><br><span class="line">Node *p = <span class="keyword">new</span> Node&#123;*n&#125;;</span><br><span class="line"><span class="comment">// last two are copy ctor</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202409261507897.jpg" alt="Copy_Constructor_fig_1"></p><p>In this case, only the first node is actually copied. This is an example of shallow copy, where only first layer is copied over. Instead we want a deep copy, where we will end up with 3 identical but still independent lists.</p><p>In order to do that, we must write our own copy ctor.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">    <span class="built_in">Node</span> (<span class="type">const</span> Node &amp;other): data&#123;other.data&#125;, next&#123;other.next? <span class="keyword">new</span> Node&#123;*other.next&#125;: <span class="literal">nullptr</span>&#125; &#123;&#125;</span><br><span class="line">    <span class="comment">// Note that following is wrong</span></span><br><span class="line">    <span class="built_in">Node</span> (Node other): ... &#123;&#125;</span><br><span class="line">    <span class="comment">// Taking &#x27;other&#x27; by value implies that &#x27;other&#x27; is being copied, leading to infinite recursion.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>The above example will perform a recursive deep copy, and when called on a linked list, will produce another that is identical but completely separate.</p><p>The copy constructor is called in the following situation:</p><ol><li>Constructing (initialized) one object from another of the same type</li><li>Object is passed by value</li><li>Object is returned by value</li></ol><p>The truth is more nuanced, as we will see.</p><h4 id="Explicit-x2F-Implicit-Constructors"><a href="#Explicit-x2F-Implicit-Constructors" class="headerlink" title="Explicit &#x2F; Implicit Constructors"></a>Explicit &#x2F; Implicit Constructors</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="built_in">Node</span> (<span class="type">int</span> data, Node *next=<span class="literal">nullptr</span>): data&#123;data&#125;, next&#123;next&#125; &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Single argument constructors allow implicit conversions. For example with the Node class shown above, we can construct it by just providing a single integer. Thus, the following behavior make sense:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node n&#123;<span class="number">4</span>&#125;;</span><br><span class="line">Node n = <span class="number">4</span>; <span class="comment">// Implicit conversion from int to node</span></span><br></pre></td></tr></table></figure><p>We have experienced this with C++ string initialization:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="comment">// A variable of type std::string is being initialized witha const char* value.</span></span><br></pre></td></tr></table></figure><p>This is allowed because there is a single argument constructor for std::string that tales in a const char*.</p><p>However, implicit conversions also allow for some unintuitive behavior:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Node n)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Do something with n</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(Node&#123;<span class="number">4</span>&#125;); <span class="comment">// Make sense</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">4</span>); <span class="comment">// Doesn&#x27;t make sense but works</span></span><br></pre></td></tr></table></figure><p>In the example shown above, the constructor for Node is called, which takes in an int. Once a Node is constructed, it is passed to f.</p><p>Implicit conversions can be dangerous:</p><ul><li>Accidentally passing an int to a function expecting a Node</li><li>silen conversion</li><li>compiler does not signal an error</li><li>potential errors not caught</li></ul><p>In order to not letting you compiler helping you, disable the implicit conversion by prefixing the constructor with the <code>explicit</code> keyword:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Node</span><span class="params">(<span class="type">int</span> data, Node *next=<span class="literal">nullptr</span>)</span>: data&#123;</span>data&#125;, next&#123;next&#125; &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node n&#123;<span class="number">4</span>&#125;; <span class="comment">// Works</span></span><br><span class="line">Node n = <span class="number">4</span>; <span class="comment">// Won&#x27;t compile</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Node n)</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(Node&#123;<span class="number">4</span>&#125;); <span class="comment">// Works</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">4</span>); <span class="comment">// Won&#x27;t compile</span></span><br></pre></td></tr></table></figure><h3 id="Destructors"><a href="#Destructors" class="headerlink" title="Destructors"></a>Destructors</h3><ol><li>Called when a stack-allocated object is popped off the stack, or when <code>delete</code> is called on heap allocated memory.</li><li>A special method that runs when an object is destroyed.</li></ol><p>The default compiler-provided destructor calls the destructor on all constituent objects, and does nothing to non-objects.</p><p>Steps of C++ object destruction:</p><ol><li>Destructor body runs</li><li>Field’s destructors are invoked (destructor runs for all object fields) [In reverse declaration order]</li><li>space is deallocated</li></ol><p><strong>Reasons for writing custom destructors:</strong></p><p>Similar to with constructors, custom classes for data structures, especially those that references themselves will need a custom constructor. Let’s see why using the <code>Node</code> class as an example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Here, <code>next</code> is a <code>Node *</code> or <code>Node</code> pointer. Thus it is not an object and no destructor will run for it. When we call <code>delete</code> on a node in a linked list, only that node will be deleted, and all the subsequent nodes will remain in memory but inaccessible, causing a memory leak.</p><p><strong>Example:</strong> <code>Node</code> class with destructor.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    ... <span class="comment">// Fields and constructors</span></span><br><span class="line">~<span class="built_in">Node</span>() &#123;<span class="keyword">delete</span> next;&#125; <span class="comment">// Recursively calls destructor</span></span><br><span class="line">    <span class="comment">// Name for dtor is ~&lt;name&gt;, has no args or return type</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>NOTE:</strong> The base case running <code>delete nullptr;</code> is guaranteed safe and does nothing more. Hence the recursion stops.</p><h3 id="Copy-Assignment-Operator"><a href="#Copy-Assignment-Operator" class="headerlink" title="Copy Assignment Operator"></a>Copy Assignment Operator</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student s1&#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;;</span><br><span class="line">Student s2 = s1; <span class="comment">// Copy ctor</span></span><br><span class="line"></span><br><span class="line">Student s3; <span class="comment">// Default ctor</span></span><br><span class="line">Student s3 = s1; <span class="comment">// Copy Assignment operator</span></span><br></pre></td></tr></table></figure><p>Copy assignment operator runs when we assign a value to another of the same type (that already exist). The compiler-supplied default version assigns each field of the object.</p><p>Similar to constructors and destructors, this may not work for many custom classes, especially those that have <u>recursive pointers</u> and&#x2F;or are <u>needed for data storage</u>.</p><p><strong>Example:</strong> Copy Assignment Operator for <code>Node</code> class (Version 1 - Dangerous):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    Node &amp;<span class="keyword">operator</span> = (<span class="type">const</span> Node &amp;other)&#123;</span><br><span class="line">        data = other.data;</span><br><span class="line">        <span class="keyword">delete</span> next;</span><br><span class="line">        next = other.next ? <span class="keyword">new</span> Node &#123;*other.next&#125; : <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// For chaining</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>The above code works for almost all cases, but it’ll cause a runtime error when assigning a node to itself (<code>n = n</code>), known as self assignment.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Noded n&#123;<span class="number">1</span>, <span class="keyword">new</span> Node &#123;<span class="number">2</span>, <span class="keyword">new</span> Node &#123;<span class="number">3</span>, <span class="literal">nullptr</span>&#125;&#125;&#125;;</span><br><span class="line">n = n; <span class="comment">// Deletes n and tries to copy n to n - Undefined behaviour</span></span><br></pre></td></tr></table></figure><p>When writing <code>operator=</code>,  ALWAYS make sure it works well in the case of self-assignment:</p><p><strong>Example:</strong> Copy Assignment Operator for <code>Node</code> class (Version 2 - Better)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">...</span><br><span class="line">    Node &amp;<span class="keyword">operator</span>= (<span class="type">const</span> node &amp;other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        data = other.data;</span><br><span class="line">        <span class="keyword">delete</span> next;</span><br><span class="line">        next = other.next ? <span class="keyword">new</span> Node &#123;*other.next&#125; : <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// For chaining</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Question</strong>: How big of a deal is self-assignment? How likely am I to write n &#x3D; n?</p><p><strong>Answer</strong>: Not that likely, but considering <code>*p = *q</code> if p &amp; q point to the same location. Or <code>a[i] = a[j]</code> if i &amp; j happen to be equal (say in a loop). Because of aliasing, it is a big deal.</p><p>This version is better, but we can make a better implementation. Remember <code>new</code> could fail for not having enough space to allocate. Since when <code>new</code> fails, it aborts immediately instead of returning a <code>nullptr</code>. This causes <code>next</code> to be deleted but not reassigned, and then <code>next</code> will points to freed memories.</p><p><strong>Example:</strong> Copy Assignment Operator for <code>Node</code> class (Version 3 - Final)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Node &amp;Node::<span class="keyword">operator</span>= (<span class="type">const</span> Node &amp;other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// Exit if self-assignment occurs</span></span><br><span class="line">    Node *tmp = next;</span><br><span class="line">    next = other.next ? <span class="keyword">new</span> Node &#123;*other.next&#125; : <span class="literal">nullptr</span>;</span><br><span class="line">    data = other.data;</span><br><span class="line">    <span class="keyword">delete</span> tmp;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;; <span class="comment">// if new fails, we still have the old list.</span></span><br></pre></td></tr></table></figure><p><u>Alternate</u>: copy-and-swap idiom.</p><h3 id="Copy-x2F-Swap-Idiom"><a href="#Copy-x2F-Swap-Idiom" class="headerlink" title="Copy&#x2F;Swap Idiom"></a>Copy&#x2F;Swap Idiom</h3><p>There’s another method to implement copy assignment.</p><p>A function called <code>std::swap</code> in <code>&lt;utility&gt;</code> library. Running <code>swap(a, b);</code> will swap the values of <code>a</code> and <code>b</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;utility&gt;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Node &amp;other)</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(data,other.data);</span><br><span class="line">        std::<span class="built_in">swap</span>(next, other.next);</span><br><span class="line">    &#125;</span><br><span class="line">    Node &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Node &amp;other) &#123;</span><br><span class="line">        Node tmp = other; <span class="comment">// Deep copy other to tmp</span></span><br><span class="line">        swap tmp; <span class="comment">// I became tmp</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// tmp goes out of scope, dtor handle it</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Move-Constructors"><a href="#Move-Constructors" class="headerlink" title="Move Constructors"></a>Move Constructors</h3><p><u>R-values &amp; R-value references</u></p><p>Recall:</p><ul><li>an lvalue is anything with an address</li><li>an lvalue reference(&amp;) is like a <code>const ptr</code> with auto-dereference - always initialized to an lvalue.</li><li>they don’t bind with temporary values</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">oddsOrEvens</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node odds&#123;<span class="number">1</span>, <span class="keyword">new</span> Node&#123;<span class="number">3</span>, <span class="keyword">new</span> Node &#123;<span class="number">5</span>, <span class="literal">nullptr</span>&#125;&#125;&#125;;</span><br><span class="line">    Node evens&#123;<span class="number">2</span>, <span class="keyword">new</span> Node &#123;<span class="number">4</span>, <span class="keyword">new</span> Node &#123;<span class="number">6</span>, <span class="literal">nullptr</span>&#125;&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> evens;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> odds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node n = <span class="built_in">oddsOrEvens</span>(); <span class="comment">// Copy construction</span></span><br><span class="line"><span class="comment">// oddsOrEvens() returns by value and is the &#x27;other&#x27; as the argument of the copy ctor. But what is it referencing to?</span></span><br></pre></td></tr></table></figure><ul><li>Compiler creates a <u>temporary object</u> to hold the result of <code>oddsOrEvens()</code></li><li>other is a reference to this temporary<ul><li>copy constructor deep-copies the data from this temporary</li></ul></li></ul><p><u>BUT</u> - the temporary is just going to be discarded anyways, as soon as the <code>struct Node n = oddsOrEvens()</code>, is done.</p><ul><li>Wasteful to have to copy the data from the temp.<ul><li>Why not just steal it instead? - Save the cost of copying</li></ul></li></ul><p>We need to be able to tell whether <code>other</code> is a reference to a temporary object (where stealing would work), or a standalone object (perform a deep copy).</p><p><code>Node &amp;&amp;</code> - rvalue reference. Can bind to temporary values. It is a reference to a temporary object (<code>rvalue</code>) of type Node.</p><p><strong>Example:</strong> Move constructors for the <code>Node</code> class:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">Node</span>(Node &amp;&amp;other): data&#123;other.data&#125;, next&#123;other.next&#125; &#123;</span><br><span class="line">        other.next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// Remove other&#x27;s access to the remaining nodes so the destructor</span></span><br><span class="line">        <span class="comment">// does not delete the rest of the linked list when other gets destroyed</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Nothing was copied&#x2F;changed here except for the ownership of the data.</p><h3 id="Move-Assignment-Operator"><a href="#Move-Assignment-Operator" class="headerlink" title="Move Assignment Operator"></a>Move Assignment Operator</h3><p>This is similar to the move constructor, except that it is used when reassigning the value of a variable that has already been initialized.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node m;</span><br><span class="line">m = <span class="built_in">oddsOrEvens</span>(); <span class="comment">// Assignment from temporary</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"> <span class="comment">// Steal other&#x27;s data | Destroy old data | Swap without copy</span></span><br><span class="line">Node &amp;<span class="keyword">operator</span>=(Node &amp;&amp; other) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(data, other.data);</span><br><span class="line">        std::<span class="built_in">swap</span>(next, other.next);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// The temp will be destroyed &amp; take our old data with it</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>If <code>other</code> is a temporary (rvalue), the move constructor or move assignment oerator is called instead of copying resources. If you only write the copy constructor &#x2F; assignment operator, only these will be used.</p><h3 id="Copy-x2F-Move-Elision"><a href="#Copy-x2F-Move-Elision" class="headerlink" title="Copy&#x2F;Move Elision"></a>Copy&#x2F;Move Elision</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec <span class="title">makeAVec</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;; <span class="comment">// Invoke basic Vec ctor</span></span><br><span class="line">&#125;</span><br><span class="line">Vec v = <span class="built_in">makeAVec</span>(); <span class="comment">// What runs? copy ctor? move ctor?</span></span><br></pre></td></tr></table></figure><p>Answer: This only uses basic constructor. There is no copy constructor nor move constructor. In certain cases, the compiler is required to skip calling copy&#x2F;move constructors.</p><p>Compiler writes the value directly to <code>main</code> itself and stores it inside the space occupied by v, instead of making a <code>Vec</code> in <code>makeAVec()</code> and moving it to <code>main</code>. This is called Copy&#x2F;Move Elision.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// E.g</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(Vec v)</span></span>; <span class="comment">// pass-by-value, copy or move ctor</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">doSomething</span>(<span class="built_in">makeAVec</span>()); <span class="comment">// result of makeAvec written directly into the parameter</span></span><br><span class="line"><span class="comment">// There is no copy or move</span></span><br></pre></td></tr></table></figure><p>This happens even if dropping constructor calls would change the behavior of the program (e.g. if constructors print anything).</p><p>We are not expected to know exactly when elision happens, just that it is possible to happen.</p><h3 id="Summary-Rule-of-5-Big-5"><a href="#Summary-Rule-of-5-Big-5" class="headerlink" title="Summary: Rule of 5 (Big 5)"></a>Summary: Rule of 5 (Big 5)</h3><p>If you need to write any one of the Big 5 (destructor, copy constructor, copy assignment operator, move constructor, move assignment operator): then you should probably write them all out.</p><p>However, many classes wouldn’t need any of these, and try to avoid reinventing the wheels possible, and using the default implementations are fine.</p><p>Recall three important indicative understanding of CS246:</p><ol><li>References</li><li>Stack &amp; Heap</li><li>Ownership</li></ol><p>The Big 5 are usually necessary for classes that manages resources (i.e. memories, files).</p><h2 id="Features-of-Objects"><a href="#Features-of-Objects" class="headerlink" title="Features of Objects"></a><u>Features of Objects</u></h2><h3 id="Member-Operators"><a href="#Member-Operators" class="headerlink" title="Member Operators"></a>Member Operators</h3><p><u>Notice:</u> <code>operator=</code> is a member function of the class (method). Previous operators like <code>operator+()</code> have been standalone functions.</p><p>When an operator is declared as a member function, <code>*this</code> plays the role of the first (left) operand.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec</span>&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">    ...</span><br><span class="line">    Vec <span class="keyword">operator</span>+(<span class="type">const</span> Vec &amp;other) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + other.x, y + other.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Vec <span class="keyword">operator</span>*(<span class="type">const</span> <span class="type">int</span> k) &#123; <span class="comment">// This only works for v * 5 and not 5 * v</span></span><br><span class="line">        <span class="keyword">return</span> &#123;x * k, y * k&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>How do we implement k * v? This can’t be a member function (method) since the first argument is not Vec, thus it must be external (standalone) function.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vec <span class="keyword">operator</span>*(<span class="type">const</span> <span class="type">int</span> k, <span class="type">const</span> Vec &amp;v) &#123;</span><br><span class="line"><span class="keyword">return</span> v * k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>Advice</u>: If  you overload arithmetic operators, overload the assignment versions of these as well, and implement the former in terms of the latter (reuse logic from arithmetic methods):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vec &amp;<span class="keyword">operator</span> += (Vec &amp;v1, <span class="type">const</span> Vec &amp;v2) &#123;</span><br><span class="line">    v1.x += v2.x;</span><br><span class="line">    v1.y += v2.y;</span><br><span class="line">    <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br><span class="line">Vec <span class="keyword">operator</span>+(<span class="type">const</span> Vec &amp;v1, <span class="type">const</span> Vec &amp;v2) &#123;</span><br><span class="line">    Vec tmp = v1;</span><br><span class="line">    <span class="keyword">return</span> tmpt+=v2; <span class="comment">// Reuse += to implement +</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Some operator overloads must be member functions (methods):</p><ul><li><code>operator=</code></li><li><code>operator[]</code></li><li><code>operator-&gt;</code></li><li><code>operator()</code></li><li><code>operatorT</code> (where T is a type)</li></ul><p>Some must not:</p><p><u>I&#x2F;O Operators:</u></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out) &#123;</span><br><span class="line">        <span class="keyword">return</span> out &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>What is wrong? This makes <code>Vec</code> become the first operand, not the second. View it as <code>v &lt;&lt; cout</code>, this is morally and semantically wrong, while compiler will actually allow this to happen.</p><p>So always define <code>&lt;&lt;</code>, <code>&gt;&gt;</code> as standalone functions.</p><h3 id="Arrays-of-Objects"><a href="#Arrays-of-Objects" class="headerlink" title="Arrays of Objects"></a>Arrays of Objects</h3><p>Let’s consider <code>Vec</code> object again:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Vec</span>(<span class="type">int</span> x, <span class="type">int</span> y): x&#123;x&#125;, y&#123;y&#125; &#123;&#125;</span><br><span class="line">    <span class="comment">// Notice this eliminates the default constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// We make an array of Vec objects</span></span><br><span class="line">Vec *vp = <span class="keyword">new</span> Vec[<span class="number">10</span>];</span><br><span class="line">Vec moreVecs[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>The above lines of codes will lead to compilation errors. This is because when creating an object in C++, it need to be initialized. When making an array of <code>Vec</code>s, they all needs to be initialized. However there is no default constructor, which leads to an error.</p><p><u>Options</u>:</p><ol><li><p>Provide a default constructor to the object.</p><ul><li>Not a good idea (i.e. Student class &#x2F; Empty name), unless it makes sense for the class to have a default constructor.</li></ul></li><li><p>For stack arrays, provide value during initialization.</p><ul><li><code>vec moreVecs[3] = &#123;&#123;0, 0&#125;, &#123;1, 1&#125;, &#123;2, 4&#125;&#125;;</code></li><li>This method works, but the use cases is limited</li></ul></li><li><p>For heap arrays, use an array of pointers to objects.</p><p><code>Vec **vp = new Vec*[5];</code></p><p><code>vp[0] = new Vec&#123;...&#125;;</code></p><p><code>vp[1] = new Vec&#123;...&#125;;</code> …</p><p>When we are done using this array, we’ll need to manually free all the memory, since they’re allocated in heap.</p><p><code>for (int i = 0; i &lt; 15; i++) delete vp[i];</code></p><p><code>delete[] vp;</code></p></li></ol><h3 id="Const-Objects"><a href="#Const-Objects" class="headerlink" title="Const Objects"></a>Const Objects</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Node &amp;n)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>Constant objects arise often, especially as parameters.</p><p>Objects can be constant. A constant object is that its fields cannot be mutated after initialization:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> student s&#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;;</span><br><span class="line">s.assns = <span class="number">100</span>; <span class="comment">// This will cause a compilation error</span></span><br></pre></td></tr></table></figure><p>However, we cannot run any of the object’s inbuilt functions:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> student s&#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;;</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">grade</span>() &lt;&lt; endl; <span class="comment">// This will cause a compilation error</span></span><br></pre></td></tr></table></figure><p><strong>Issue:</strong> The compiler does not know whether <code>s.grade()</code> will modify any of the object’s fields or not. The function call is prevented by compiler because if <code>s.grade()</code> will respect the <code>const</code>ness of <code>s</code>.</p><p>If it is certain <code>grade()</code> won’t modify any of the fields, we must declare its behavior to use <code>grade</code> with a <code>const</code> object.</p><p><strong>Example:</strong> Functions that work with <code>const</code> objects:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> assns, mt, <span class="keyword">final</span>;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">grade</span><span class="params">()</span> consts</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Implementation</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Student::grade</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> assns * <span class="number">0.4</span> + mt * <span class="number">0.2</span> + <span class="keyword">final</span> * <span class="number">0.4</span>;</span><br><span class="line">&#125; <span class="comment">// Modifying any of the fields will cause a compilation error</span></span><br></pre></td></tr></table></figure><p><strong>Note:</strong> The <code>const</code> suffix must appear in both interface and implementation files. Only <code>const</code> methods can be called on <code>const</code> objects. Compiler checks that <code>const</code> methods do not actually modify any fields.</p><p>With the above code, we can run the <code>grade()</code> on a <code>const</code> object:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> student s&#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;;</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">grade</span>() &lt;&lt; endl; <span class="comment">// This will work now since grade is a const method</span></span><br></pre></td></tr></table></figure><p><code>const</code> objects may only have <code>const</code> methods called on them. Non-<code>const</code> objects may have either <code>const</code> or non-<code>const</code> methods called on them.</p><p>Now what if we want to collect usage statistics on Student objects?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> assns, mt, <span class="keyword">final</span>;</span><br><span class="line">    <span class="type">int</span> calls = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">grade</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        ++calls;</span><br><span class="line">        <span class="keyword">return</span> assns * <span class="number">0.4</span> + mt * <span class="number">0.2</span> + <span class="keyword">final</span> * <span class="number">0.4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>This would not work because the function increments <code>calls</code>.</p><p><strong>Issue:</strong> Difference between physical vs logical <code>const</code>ness:</p><ul><li>Physical: Whether or not the <u>actual bits</u> that make up the object have changed.</li><li>Logical: Whether or not the updated objects should logically be regarded as different after the update.</li></ul><p>We can make an exception to what the compiler checks be declaring a field to be <code>mutable</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="type">int</span> assns, mt, finals;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> calls; <span class="comment">// Can be changed in const methods (for both const and non-const objects)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Static-fields-and-methods"><a href="#Static-fields-and-methods" class="headerlink" title="Static fields and methods"></a>Static fields and methods</h3><p>What if I want to record the number of calls for ALL <code>Student</code> objects, and not just one. Or keep track of number of <code>Student</code>s created?</p><p>We use <code>static</code> fields (associated with the class itself, not any specific instance (object)):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> assns, mt, <span class="keyword">final</span>;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> numInstances = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> assns, <span class="type">int</span> mt, <span class="type">int</span> <span class="keyword">final</span>): assns&#123;assns&#125;, mt&#123;mt&#125;, <span class="keyword">final</span>&#123;<span class="keyword">final</span>&#125; &#123;</span><br><span class="line">        numInstances++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student s&#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;;</span><br><span class="line">Student r&#123;<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>&#125;;</span><br><span class="line">cout &lt;&lt; Student::numInstances &lt;&lt; endl; <span class="comment">// Will print out 2</span></span><br><span class="line"><span class="comment">// s.numInstances also works, but is not recommended</span></span><br></pre></td></tr></table></figure><p>Any <code>static</code> fields are defined for the object rather than for each instance, and the value is shared across all instances of the object. The <code>inline</code> keyword is used to allow static fields to be initialized directly in the interface rather than in the implementation file.</p><p>Static methods, just like <code>static</code> fields, are defined for the class rather than for any one particular object. Static methods can only access static fields. No need for <code>this</code>. Don’t depend on the specific instance.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">howMany</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; numInstances &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student s1 &#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;, s2&#123;<span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>&#125;; <span class="comment">// numInstances == 2</span></span><br><span class="line">Student::<span class="built_in">howMany</span>(); <span class="comment">// outputs 2</span></span><br></pre></td></tr></table></figure><p>In order to call this function we call <code>Student::howMany();</code>, calling <code>s.howMany()</code> won’t work.</p><h3 id="Three-Way-Comparison"><a href="#Three-Way-Comparison" class="headerlink" title="Three-Way Comparison"></a>Three-Way Comparison</h3><p>Let’s go back to C and see how string comparison works: <code>strcmp(s1, s2)</code>:</p><p>Return:</p><ul><li>negative if <code>s1 &lt; s2</code></li><li>zero if <code>s1 == s2</code></li><li>positive if <code>s1 &gt; s2</code></li></ul><p>In order to compare 2 strings, we would do the following:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IN C</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">strcmp</span>&#123;s1, s2&#125;;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IN C++</span></span><br><span class="line"><span class="keyword">if</span> (s1 &lt; s2) &#123; ... &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s1 == s2) &#123; ... &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>C++ version is easier to read. However, notice that in C, there’s only one string comparison (running <code>strcmp</code> once). In C++, there are 2 string comparisons being done. This causes an unnecessary waste of resources.</p><p>As of C+&#x3D;20, there’s a efficient way:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3-way comparison operator: (Spaceship operator)</span></span><br><span class="line">s1 &lt;=&gt; s2;</span><br></pre></td></tr></table></figure><p>Using the 3-way comparison operator is identical to using <code>strcmp</code> in C. Note that in order to use it we need to import the <code>&lt;compare&gt;</code> library.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;compare&gt;;</span><br><span class="line"></span><br><span class="line">std::strong_ordering n = (s1 &lt;=&gt; s2);</span><br><span class="line"><span class="comment">// std::strong_ordering is the return type of &lt;=&gt;</span></span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p><code>std::strong_ordering</code> is a lot to type. Instead, we can use automatic type deduction:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> n = (s1 &lt;=&gt; s2);</span><br><span class="line"><span class="comment">// n&#x27;s type is the return type of the expression on the RHS</span></span><br></pre></td></tr></table></figure><p>We may also overload the spaceship operator for our own data types. If we define <code>&lt;=&gt;</code> for a type, we also automatically get all the other comparison operators automatically:</p><ul><li>v1 &#x3D;&#x3D; v2</li><li>v1 !&#x3D; v2</li><li>v1 &lt;&#x3D; v2</li><li>v1 &gt;&#x3D; v2</li><li>v1 &lt; v2</li><li>v1 &gt; v2</li></ul><p>Even after we define the spaceship operator, we can overload <code>operator==</code> again, since it’s sometimes possible to check equality much more efficiently than comparison.</p><p><strong>Example:</strong> Operator overloading the spaceship operator:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> vec&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> n = x &lt;=&gt; other.x;</span><br><span class="line">        <span class="keyword">return</span> (n == <span class="number">0</span>) ? (y &lt;=&gt; other.y) : n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Here, we are simply comparing the fields in declaration order. If that is the case, we can use the default version of <code>operator&lt;=&gt;</code>. This is not provided by default and we need to specify that we are using default behavior.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Vec &amp;other) <span class="type">const</span> == <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// This does lexicographic comparison on the fields of Vec - equivalent to what we wrote before</span></span><br></pre></td></tr></table></figure><p><strong>Node:</strong> <code>= default</code> also works for all constructors, destructors, and operators that the compiler provides by default.</p><p>Consider a case where <code>= default</code> is not appropriate for <code>&lt;=&gt;</code>.</p><p><strong>Example:</strong> Linked lists</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Node &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> n = (data &lt;=&gt; other.data);</span><br><span class="line">        <span class="keyword">if</span> ((n != <span class="number">0</span>) || (!next &amp;&amp; !other.next)) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span> (!next &amp;&amp; other.next) <span class="keyword">return</span> std::strong_ordering::less;</span><br><span class="line">        <span class="keyword">if</span> (next ** !other.next) <span class="keyword">return</span> std::strong_ordering::greater;</span><br><span class="line">        <span class="keyword">return</span> *next &lt;=&gt; *other.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Note: Assumes non-empty lists</span></span><br><span class="line"><span class="comment">// Empty list is nullptr, and this method doesn&#x27;t applies to it, so no worries :)</span></span><br></pre></td></tr></table></figure><h3 id="Encapsulation"><a href="#Encapsulation" class="headerlink" title="Encapsulation"></a>Encapsulation</h3><p>Consider our linked list example again:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">    ...</span><br><span class="line">~<span class="built_in">Node</span>() &#123;<span class="keyword">delete</span> next&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node n1&#123;<span class="number">1</span>, <span class="keyword">new</span> Node&#123;<span class="number">2</span>, <span class="literal">nullptr</span>&#125;&#125;;</span><br><span class="line">Node n2&#123;<span class="number">3</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">Node n3&#123;n1, &amp;n2&#125;;</span><br></pre></td></tr></table></figure><p>When this program finished running, the following happens:</p><ul><li>n1 - <code>dtor</code> runs, entire list that are on heap is deleted.</li><li>n3 - <code>dtor</code> tries to delete n2, but fails because it tries to free <code>n2,</code> which is stack allocated.</li></ul><p>Even if we did these with variables that were all heap-allocated, we would end up with double-free errors on n1.</p><p>Class node relies on an assumption for its proper operation: that next is either nullptr or was allocated by new.</p><p>These are <u>invariants</u> - properties of a data structure that must hold true - upon which Node relies.</p><p>But we, can’t guarantee this invariant - can’t trust user to use Node properly. Because users can easily violate these invariants.</p><ul><li>But not if the client can rearrange the underlying data.</li></ul><p><strong>Encapsulation</strong> provides a solution to users violating invariants.</p><p>Users should treat our objects as “capsules” or “black boxes”, where users have no access to the underlying data, but rather interact with the objects by calling methods.</p><p>This is where <u>access specifiers</u> are useful. There are 2 different types:</p><ul><li><code>public</code> fields &#x2F; methods: can be accessed everywhere.</li><li><code>private</code> fields &#x2F; methods: can be accessed &#x2F; called within class methods.</li></ul><p><strong>Example:</strong> <code>Vec</code> struct using access specifiers</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec</span>&#123;</span><br><span class="line">    <span class="built_in">Vec</span>(<span class="type">int</span> x, <span class="type">int</span> y); <span class="comment">// Public</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x, y; <span class="comment">// Private</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Vec <span class="keyword">operator</span>+(<span class="type">const</span> Vec &amp;other); <span class="comment">// Public</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>It is preferred to keep fields <code>private</code> by default, only <code>method</code> should be public.</p><p><code>Class</code> has default visibility of fields &#x2F; methods <code>private</code>, <code>Struct</code> has default visibility of fields &#x2F; methods <code>public</code>.</p><p>Note that this is the only difference between <code>class</code> and <code>struct</code>.</p><p><strong>Example:</strong> <code>Vec</code> object implemented as a class</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">vec</span> &#123; </span><br><span class="line">    <span class="type">int</span> x, y; <span class="comment">// Private by default, can not be called outside vec methods </span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vec</span>(<span class="type">int</span> x, <span class="type">int</span> y);</span><br><span class="line">    vec <span class="keyword">operator</span>+(<span class="type">const</span> vec&amp; other) <span class="type">const</span>; </span><br><span class="line">&#125;; <span class="comment">// Semicolon at the end, like with structs</span></span><br></pre></td></tr></table></figure><p><strong>Example:</strong> Revisit our linked list - add encapsulation, protect invariants:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List.cc</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> list;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>; <span class="comment">// private nested class, accessible only within List</span></span><br><span class="line">    Node *head = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addToFront</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> &amp;<span class="title">ith</span><span class="params">(<span class="type">int</span> i)</span></span>; <span class="comment">// reference type, since we might want to mutate the element</span></span><br><span class="line">    ~<span class="built_in">List</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List-impl.cc</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span>::Node &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">    ~Node &#123; <span class="keyword">delete</span> next; &#125;</span><br><span class="line">    <span class="comment">// ... Rest of big 5, if needed</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">List::addToFront</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    head = <span class="keyword">new</span> Node&#123;n, head&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> &amp;<span class="title">List::ith</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    Node *cur = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List::~<span class="built_in">List</span>() &#123; <span class="keyword">delete</span> head; &#125;</span><br></pre></td></tr></table></figure><p>Only <code>List</code> can create &#x2F; manipulate Node objects.</p><p>Thus we can guarantee the invariant that next is always either <code>nullptr</code> or allocated by new.</p><p>Encapsulation gives us a lot of benefits, but let’s talk about something not so good.</p><p><strong>Issue:</strong> Printing a list take O(n^2) time. <code>List::ith()</code> cost O(i) time, calling <code>List::ith()</code> repetitively will eventually ends up with O(n^2) time.</p><p>How can we have faster iteration while maintaining encapsulation?</p><h3 id="Iterator-Pattern"><a href="#Iterator-Pattern" class="headerlink" title="Iterator Pattern"></a>Iterator Pattern</h3><p>We can’t traverse the list from node to node as would in a linked list. We can’t expose the nodes, or we lose encapsulation.</p><h4 id="SE-Topic-Design-Patterns"><a href="#SE-Topic-Design-Patterns" class="headerlink" title="SE Topic: Design Patterns"></a>SE Topic: Design Patterns</h4><ul><li>Certain programming challenges arise often</li><li>Keep track of good solutions to these problems - reuse &amp; adapt them</li></ul><p><u>Iterator Pattern:</u> </p><p>By creating an <u>iterator</u> class, which is an abstraction of a pointer. We keep track of how far we have reached, and allow the user to access data but not modify anything.</p><p>Recall from CS136:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> *p = arr; p != arr+size; ++p) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Example:</strong> <code>List</code> data structure with Iterator pattern.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>;</span><br><span class="line">    Node *head;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">            Node *cur;</span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">            <span class="built_in">Iterator</span>(Node *cur): cur&#123;cur&#125; &#123;&#125;</span><br><span class="line">            Iterator &amp;<span class="keyword">operator</span>++() &#123; <span class="comment">// if &amp;operator++(int), post-fix ++</span></span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="type">int</span> &amp;<span class="keyword">operator</span>*() &#123;</span><br><span class="line">                    <span class="keyword">return</span> cur-&gt;data;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> cur != other.cur;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;; <span class="comment">// End iterator</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// List class</span></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Iterator&#123;head&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Iterator&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">            <span class="comment">// If in array, replace nullptr with array&#x27;s front address + size</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Add addToFront, ith, Big 5</span></span><br><span class="line">&#125;; <span class="comment">// End List class</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List l = <span class="built_in">addToFront</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (List::Iterator it = l.<span class="built_in">begin</span>(); it != l.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="comment">// This loop runs in O(n) time.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If you have a class with the following:</p><ol><li><code>begin</code> and <code>end</code> methods returning some iterator type.</li><li>This iterator type has prefix <code>++</code>, <code>!=</code>, and unary <code>*</code>.</li></ol><p>You can use a range-based <code>for</code> loop.</p><p><strong>Example:</strong> Range-based <code>for</code> loop with iterator class</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If you want to get a copy of the data stored in the class</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> / <span class="keyword">auto</span> n : l) &#123;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl; <span class="comment">// n is a copy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If you want to mutate list items (or save copying):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;n : l) &#123;</span><br><span class="line">++n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Encapsulation continued</p><p>List client can create iterators directly:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = List::Iterator &#123;<span class="literal">nullptr</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>This violates the idea that all iterators are created by calling <code>begin()</code> or <code>end()</code>. While <code>List::Iterator&#123;nullptr&#125;</code> is the same thing that is returned by <code>end()</code> in this case, it’s not necessarily the case with other data structures.</li></ul><p>Consider making <code>List::Iterator</code>‘s constructor private:</p><ul><li>Being a <code>private</code> method, it can not be called by the user.</li><li>However, even <code>List</code> would not be able to make iterators in <code>begin()</code> or <code>end()</code>.</li></ul><p>Solution: Make an exception for the <code>List</code> class so that it gets privileged access to the normally <code>private</code> constructor for <code>Iterator</code>.</p><ul><li>Make it a <u>friend</u></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">            Node *cur;</span><br><span class="line">            <span class="built_in">Iterator</span> (Node *cur): cur&#123;cur&#125; &#123;&#125;</span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">            <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">List</span>; <span class="comment">// This can be anywhere in Iterator</span></span><br><span class="line">        &#125;; <span class="comment">// Ends iterator</span></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Iterator&#123;head&#125;; &#125;</span><br><span class="line">    <span class="function">Iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Iterator&#123;<span class="literal">nullptr</span>&#125;; &#125; </span><br><span class="line">&#125;; <span class="comment">// Ends List</span></span><br></pre></td></tr></table></figure><p>If class A declares class B as a friend, then B can access all the private fields &#x2F; methods of A.</p><p>Now, a user can now create an Iterator, also also List, we can be sure that all Iterators can be created via <code>begin()</code> or <code>end()</code>.</p><p><strong>Advice:</strong> Limit your friendships - More friendships means more difficulty to reason about private fields &#x2F; methods.</p><p>Instead of friendships, consider using accessor &#x2F; mutator methods instead (getters &#x2F; setters).</p><p><strong>Example:</strong> Accessors and mutators for the <code>vec</code> class.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vec</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; x = a; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">setY</span><span class="params">(<span class="type">int</span> b)</span> </span>&#123; y = b; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>What if we want to use <code>operator&lt;&lt;</code>, this needs both <code>x</code> and <code>y</code>, but must be a standalone function.</p><p>We declare friend methods just like how we declare friend classes. Instead of providing a class name, we provide a function signature.</p><p><strong>Example:</strong> Declaring output operator as a friend function.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> vec&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> out &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; v.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; v.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vec</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Has access to x &amp; y, even though they&#x27;re private fields</span></span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;, <span class="type">const</span> vec&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Equality-Revisited"><a href="#Equality-Revisited" class="headerlink" title="Equality Revisited"></a>Equality Revisited</h3><p>We now have an encapsulated <code>List</code> class.</p><p>We already have <code>ith</code> and <code>addToFront</code> methods. We could also add a length method.</p><p>Options:</p><ol><li>Loop through the nodes to count them: <code>O(n)</code>.</li><li>Store the length as a field of <code>List</code> &amp; keep it up to date whenever <code>addToFront</code> is called: <code>O(1)</code>.</li></ol><p>Option 2 is preferred, as it optimizes equality.</p><p>Most lists will have different lengths, and so we could optimize the <code>==</code> operator by checking the length first, and only compare the individual values if the lengths differ. If lengths differ, then equality is calculated in <code>O(1)1</code> time.</p><p><strong>Example:</strong> Optimized equality operator for a <code>List</code> class.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>;</span><br><span class="line">    Node* head;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">operator</span>==(<span class="type">const</span> List&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (length != other.length) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">            <span class="keyword">return</span> (*<span class="keyword">this</span> &lt;=&gt; other) == <span class="number">0</span>; <span class="comment">// Compare with &lt;=&gt;</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> List&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!head &amp;&amp; !other.head) &#123; <span class="keyword">return</span> std::strong_ordering::equal;&#125;</span><br><span class="line">            <span class="keyword">if</span> (!head) <span class="keyword">return</span> std::strong_ordering::less;</span><br><span class="line">            <span class="keyword">if</span> (!other.head) <span class="keyword">return</span> std::strong_ordering::greater;</span><br><span class="line">            <span class="keyword">return</span> *head &lt;=&gt; *other.head; <span class="comment">// Compare next</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spaceship operator provides <code>&gt;=</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&lt;</code>, for <code>List</code>. We have overloaded the <code>==</code> operator, for which the compiler will use the custom optimized version, as well as for <code>!=</code>, which is just the negation of <code>==</code>.</p><p>But in the special case of equality checking, we are missing out on a shortcut: Lists whose lengths are different cannot be equal. In this case, could answer “not equal” in <code>O(1)</code> time.</p><h3 id="System-Modelling"><a href="#System-Modelling" class="headerlink" title="System Modelling"></a>System Modelling</h3><p>Visualize the structure of the system (abstractions + relationships among them) to aid design of implementations.</p><p>We want to graphically display the classes of a program at a high level.</p><p>We uses the popular standard language <strong>UML (Unified Modelling Language)</strong>.</p><p><strong>Example:</strong> UML Diagram for the <code>Vec</code> class.</p><p><img src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202410221523999.png" alt="UML Fig 1"></p><p>Here, there are 2 different sections. Upper section is for variables and the bottom section is for functions. Anything prepended by a <code>+</code> is <code>public</code>, anything prepended by <code>-</code> is <code>private</code>.</p><h3 id="Relationships-Between-Classes"><a href="#Relationships-Between-Classes" class="headerlink" title="Relationships Between Classes"></a>Relationships Between Classes</h3><h4 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h4><p><strong>Composition</strong> is one possible relationship between classes, where one classes is embedded within the other.</p><p><strong>Example:</strong> Composition relationship.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Basis</span> &#123;</span><br><span class="line">Vec v1, v2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Embedding one object (e.g. Vec) inside another (e.g. Basis) called composition.</p><p>Here, <code>Basis</code> is <strong>composed</strong> of 2 <code>Vec</code>s. They are <u>part of</u> a basis and that is their only purpose. This is also called “owns-a”. Here, <code>Basis</code> owns 2 <code>Vec</code>s.</p><p>Following is the UML diagram for the <code>Basis</code> example:</p><p><img src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202410221531125.png" alt="UML Fig 2"></p><p>If “<code>A</code> owns-a <code>B</code>“, then:</p><ul><li><code>B</code> has no identity outside <code>A</code> (No independent existence)</li><li>If <code>A</code> dies, <code>B</code> also dies.</li><li>If <code>A</code> is copied, <code>B</code> is copied (deep copy).</li></ul><p>An example would be: A car owns its engine - the engine is part of the car.</p><ul><li>Destroying the car will also destroys the engine.</li><li>Copying the car will also copies the engine.</li></ul><p>Implementation - Usually as composition of classes.</p><p>A &lt;&gt;—-&gt; B means A owns some number of B’s.</p><ul><li>Can annotate with multiplicities, field names.</li></ul><h4 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h4><p><strong>Aggregation</strong> is similar to Composition, except with some minor differences. Instead of one class being embedded in another, it’s rather linked to the other.</p><p>E.g.: Compare car parts in a car (“owns-a”) vs. car parts in a catalogue.</p><ul><li>The catalogue contains the parts, but the parts have an independent existence.</li></ul><p>An aggregation relationship is also called “has-a”.</p><p>If “<code>A</code> has-a <code>B</code>“, then:</p><ul><li>If <code>A</code> dies, then <code>B</code> keeps living.</li><li>If <code>A</code> is copied, then <code>B</code> is not copied (shallow copy).</li><li><code>B</code> may have independent existence outside of <code>A</code>.</li></ul><p><strong>Example:</strong> Aggregation relationship - Parts in a catalogue, ducks in a pond.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    University* myUni&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(...) &#123;&#125;</span><br><span class="line">    <span class="comment">// Anything else</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    University uw &#123; ... &#125;;</span><br><span class="line">    Student s1 &#123;<span class="number">1</span>, &amp;uw&#125;;</span><br><span class="line">    Student s2 &#123;<span class="number">2</span>, &amp;uw&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The following is the UML diagram for the <code>Student</code> example:</p><p><img src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202410221550091.png" alt="UML Fig 3"></p><p>Case Study: Does a pointer field always mean non-ownership?</p><p><img src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202410241434412.png" alt="UML Fig 4"></p><p>A node owns the node that follows it. (Recall that implementation of the Big 5 is a good sign of ownership)</p><p>The <code>List</code> owns the first node, but the ownerships are implemented via pointers.</p><p>Another view of lists &amp; nodes.</p><p><img src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202410241440954.png" alt="UML Fig 5"></p><p>We could view the List object as owning <u>all</u> the nodes within it.</p><p>What might this suggest about the implementation of Lists &amp; Nodes in this case?</p><p>Likely, that List is taking responsibility for copying and construction&#x2F;deconstruction of Nodes, rather than Node.</p><p>Possible iterative (i.e. loop-based) management of pointers instead of recursive operations within Node.</p><h4 id="Specialization-x2F-Inheritance"><a href="#Specialization-x2F-Inheritance" class="headerlink" title="Specialization &#x2F; Inheritance"></a>Specialization &#x2F; Inheritance</h4><p>Suppose we want to track our collection of books.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    string title, author;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Book</span>(...) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">    string title, author;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    string topic;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Text</span>(...) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comic</span> &#123;</span><br><span class="line">    string title, author;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    string hero;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Comic</span>(...) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>This is OK, but it doesn’t capture the relationships among Book, Text, and Comic.</p><p>And how do we create an array (or list) that contains a mix of these?</p><p><u>Could</u>:</p><ol><li>Use a Union</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Union BookTypes &#123; Book *b, Text *t, Comic *c&#125;; <span class="comment">// Stores ONE of the data types</span></span><br><span class="line">Book Types myBooks[<span class="number">20</span>];</span><br></pre></td></tr></table></figure><ol start="2"><li>Array of <code>void*</code> - Pointer to anything</li></ol><p>Not good solutions - subvert the type system.</p><p>Rather, observe: Texts and Comics are <u>kinds</u> of Books - Books with extra features.</p><p>To model in C++, we introduce <strong>inheritance</strong>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123; <span class="comment">// Base class or Superclass</span></span><br><span class="line">    string title, author;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">book</span>(string title, string author, <span class="type">int</span> length): title&#123;title&#125;, author&#123;author&#125;, length&#123;length&#125; &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Derived subclasses</span></span><br><span class="line"><span class="comment">// All fields / methods inherited from Book</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span>: <span class="keyword">public</span> Book &#123;</span><br><span class="line">    string topic;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Text</span>(...) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comic</span>: <span class="keyword">public</span> Book &#123;</span><br><span class="line">    string hero;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Comic</span>(...) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Derived classes <u>inherit</u> fields and methods from the base class. So Text, Comic get title, author, length fields. Any method that can be collection on Book can be called on Text, Comic.</p><p>Who can see these members?</p><p>title, author, length - private in Book - outsiders can’t see them.</p><p>Can Text, Comic see them? <strong>NO</strong>, even subclasses can’t see them!</p><p>How do we initialize Text? Need title, author, length, topic</p><p><strong>Example:</strong> Incorrect constructor for a subclass.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Warning: This code doesn&#x27;t work and the reason why is explained below</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span>: <span class="keyword">public</span> Book &#123;</span><br><span class="line">    string topic;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Text</span>(string title, string author, <span class="type">int</span> length, string topic): title&#123;title&#125;, author&#123;author&#125;, length&#123;length&#125;, topic&#123;topic&#125; &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Wrong for 2 reasons:</p><ol><li>title, etc. are not accessible in Text (even if they were, MIL only lets you mention your own fields)</li><li>Once again, when an object is created:<ol><li>Space is allocated</li><li>Superclass constructor runs <strong>NEW</strong></li><li>Fields are initialized via MIL</li><li>Constructor body runs</li></ol></li></ol><p>So a constructor for Book must run before the fields of Text can be initialized. If Book has no default constructor, a constructor for Book must be invoked explicitly:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span>: <span class="keyword">public</span> Book &#123;</span><br><span class="line">    string topic;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Text</span>(string title, string author, <span class="type">int</span> length, string topic):</span><br><span class="line">    Book&#123;title, author, length&#125;, topic&#123;topic&#125; &#123;&#125;</span><br><span class="line">    step <span class="number">2</span> / step <span class="number">3</span> / step <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Good reasons to keep superclass fields inaccessible to subclasses.</p><h4 id="Protected-Variables-and-Methods"><a href="#Protected-Variables-and-Methods" class="headerlink" title="Protected Variables and Methods"></a>Protected Variables and Methods</h4><p>If you want to give subclasses access to certain members, use <u>protected</u> access.</p><p><strong>Example:</strong> Different abilities for different subclasses.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span>: <span class="comment">// Accessible to Book and its subclasses, but no one else</span></span><br><span class="line">    string title, author;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Book</span>(...) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span>: <span class="keyword">public</span> Book &#123;</span><br><span class="line">    string topic;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAuthor</span><span class="params">(string newArthor)</span> </span>&#123; author += <span class="string">&quot; &quot;</span> + newAuthor;&#125;</span><br><span class="line">    <span class="comment">// The above function can access and modify author since it is a protected field</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Not a good idea to give subclasses unlimited access to fields. <u>Better</u> - make fields private, but provide protected accessors &#x2F; mutators.</p><p><strong>Example:</strong> Protected mutators.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    string title, author;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAuthor</span><span class="params">(string newAuthor)</span></span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Book</span>();</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHeavy</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// The above function may only be called inside Book or any of it&#x27;s subclasses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Relationship among Text, Comic, Book is called “is-a”</p><ul><li>A text “is-a” Book</li><li>A Comic “is-a” Book</li></ul><p>![UML Fig 6] (<a href="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202410241543154.png">https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202410241543154.png</a>)</p><h4 id="Virtual-Methodss"><a href="#Virtual-Methodss" class="headerlink" title="Virtual Methodss"></a>Virtual Methodss</h4><p>Now consider the method <code>isHeavy</code> - when is a Book heavy?</p><ul><li>for ordinary books - a book is heavy if it’s more than 200 pages</li><li>for texts - more than 500 pages</li><li>for comics - more than 30 pages</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHeavy</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> length &gt; <span class="number">200</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comic</span>:<span class="keyword">public</span> Book &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHeavy</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> length &gt; <span class="number">30</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Book b &#123;<span class="string">&quot;A small book &quot;</span>, _____, <span class="number">50</span>&#125;;</span><br><span class="line">Comic c &#123;<span class="string">&quot;A big comic &quot;</span>, _____, <span class="number">40</span>, _____&#125;;</span><br><span class="line">cout &lt;&lt; b.<span class="built_in">isHeavy</span>() &lt;&lt; c.<span class="built_in">isHeavy</span>(); <span class="comment">// false true</span></span><br></pre></td></tr></table></figure><p>Now, since public inheritance defines an “is-a” relationship, we can do this:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Book b = Comic &#123;<span class="string">&quot;A big comic &quot;</span>, _____, <span class="number">40</span>, _____&#125;;</span><br></pre></td></tr></table></figure><p><u>Question</u>: Is b heavy? i.e. <code>b.isHeavy()</code> - true or false? i.e. which <code>isHeavy()</code> runs? <code>Book::isHeavy()</code> or <code>Comic::isHeavy()</code>?</p><p><u>Answer</u>: b is <strong>NOT</strong> heavy. Which means <code>Book::isHeavy()</code> runs.</p><p><u>Why?</u> <code>Book b</code> is on stack, <code>= Comic &#123; ... &#125;;</code> is on heap</p><p><u>Explanation</u>: We tries to fit a Comic object, where there is only space for a Book object. What happens? Comic is <u>sliced</u>. The hero field gets chopped off. Comic is <u>coerced</u> into a Book. So <code>Book b = Comic &#123; ... &#125;;</code>  creates a Book and <code>Book::isHeavy</code> runs.</p><p>NOTE: Slicing takes place even if the two object types were of the same size. Having <code>isHeavy()</code> depend on whether Book &amp; Comic are the same size would not be good.</p><p>When accessing objects through pointers, slicing is unnecessary and doesn’t happen.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Comic c &#123;___, ___, <span class="number">40</span>, ___&#125;;</span><br><span class="line">Book *pb = &amp;c;</span><br><span class="line">c.<span class="built_in">isHeavy</span>(); <span class="comment">// true</span></span><br><span class="line">pb-&gt;<span class="built_in">isHeavy</span>(); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>Compiler uses the type of the pointer (or reference) to decide which <code>isHeavy()</code> to run - doesn’t consider the actual type of the object.</p><p>Behavior of the object depends on what type of pointer (or reference) you access it through.</p><p>How can we make Comic act like a Comic, even when pointed to by a Book pointer? I.e., how can you get <code>Comic::isHeavy()</code> to run?</p><p>Declare the method <u>virtual</u>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isHeavy</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> length &gt; <span class="number">200</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comic</span>:<span class="keyword">public</span> Book &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHeavy</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> length &gt; <span class="number">30</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Comic c &#123;___, ___, <span class="number">40</span>, ___&#125;;</span><br><span class="line">Comic *pc = &amp;c;</span><br><span class="line">Book *pb = &amp;c;</span><br><span class="line">Book &amp;rb = c;</span><br><span class="line"></span><br><span class="line">pc-&gt;<span class="built_in">isHeavy</span>(); <span class="comment">// true</span></span><br><span class="line">pb-&gt;<span class="built_in">isHeavy</span>(); <span class="comment">// true</span></span><br><span class="line">rb.<span class="built_in">isHeavy</span>(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Virtual methods: Choose which class’s method to run based on the actual type of the object at run time. (Only applies if accessing through pointer&#x2F;reference, otherwise slicing).</p><p><strong>Example:</strong> my book collection</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Book *myBooks[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    cout &lt;&lt; myBooks[i]-&gt;<span class="built_in">isHeavy</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Uses <code>Book::isHeavy()</code> for Books</li><li>Uses <code>Comic::isHeavy()</code> for Comics</li><li>Uses <code>Text::isHeavy()</code> for Texts</li></ul><p>Accommodating multiple types under one abstraction: <strong>Polymorphism</strong> (“many forms”).</p><p><u>Note</u>: this is why a function <code>void f(istream f)</code> can be passed an <code>ifstream</code>, <code>ifstream</code> is a subclass of <code>istream</code>.</p><p><strong>DANGER:</strong> What if we’ve written <code>Book myBooks[20];</code> and try to use that polymorphically?</p><p>Consider</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(Book books[])</span> </span>&#123;</span><br><span class="line">    books[<span class="number">1</span>] = Book&#123;<span class="string">&quot;book&quot;</span>, <span class="string">&quot;author&quot;</span>, ___&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Comic c[<span class="number">2</span>] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;comic1&quot;</span>, <span class="string">&quot;artist1&quot;</span>, <span class="number">10</span>, <span class="string">&quot;hero1&quot;</span>&#125;,</span><br><span class="line">   &#123;<span class="string">&quot;comic2&quot;</span>, <span class="string">&quot;artist2&quot;</span>, <span class="number">10</span>, <span class="string">&quot;hero2&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(c); <span class="comment">// This is legal</span></span><br></pre></td></tr></table></figure><p>What is c now?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#123;“comic1<span class="string">&quot;, &quot;</span>artist1<span class="string">&quot;, 10, &quot;</span>book<span class="string">&quot;&#125;,</span></span><br><span class="line"><span class="string">    &#123;&quot;</span>author<span class="string">&quot;, ??? &#125;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br></pre></td></tr></table></figure><p><strong>Recommendation:</strong>  Never use arrays of objects polymorphically. Use arrays of pointers.</p><h4 id="Destructor-Revisited"><a href="#Destructor-Revisited" class="headerlink" title="Destructor Revisited"></a>Destructor Revisited</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span> *x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">X</span>(<span class="type">int</span> n): X &#123;<span class="keyword">new</span> <span class="type">int</span>[n]&#125; &#123;&#125;</span><br><span class="line">    ~<span class="built_in">X</span>() &#123; <span class="keyword">delete</span>[] x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span> &#123;</span><br><span class="line">    <span class="type">int</span> *y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Y</span>(<span class="type">int</span> m, <span class="type">int</span> n): X&#123;n&#125;, y&#123;<span class="keyword">new</span> <span class="type">int</span>[m];&#125; &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Y</span>() &#123; <span class="keyword">delete</span>[] y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>How can we make sure that deleting through a superclass pointer runs the subclass desctructor? - Declare the destructor <u>virtual</u>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span> *x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">X</span>() &#123; <span class="keyword">delete</span>[] x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><u>ALWAYS</u> make the destructor virtual in classes that are meant to have subclasses, even if the destructor doesn’t do anything.</p><p>If a class is <strong>NOT</strong> meant to have subclasses - declare it <u>final</u>: <code>classY find:public X &#123;...&#125;;</code></p><h4 id="Pure-Virtual-Methods"><a href="#Pure-Virtual-Methods" class="headerlink" title="Pure Virtual Methods"></a>Pure Virtual Methods</h4><p>Consider 2 kinds of student: Regular and Coop.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Students</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">fees</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Regular</span>: <span class="keyword">public</span> Student&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fees</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coop</span>: <span class="keyword">public</span> Student&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fees</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>What should we put for <code>Student::fees()</code>?</p><p>We’re not sure, since every student should be either Regular or Coop.</p><p>We can explicitly give <code>Student::fees()</code> <u>no</u> implementation.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">fees</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Method has no implementation</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>A class with a pure virtual method cannot be instantiated.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student s; <span class="comment">// Cannot do this</span></span><br></pre></td></tr></table></figure><p>This is called an <u>abstract class</u>, which purpose is to organize subclasses. Subclasses of an abstract class are also abstract unless they implement all pure virtual methods.</p><p>Non-abstract classes are called <u>concrete</u>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Regular</span>: <span class="keyword">public</span> Student &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fees</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> ...; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>UML:</p><ul><li>Virtual &#x2F; Pure virtual methods: italics</li><li>Abstract classes: italicize class name</li></ul><h4 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h4><p>Huge topic - just to highlight here.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        Node *next;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>What if you want a List of something else?</p><p>Whole new class?</p><p><u>OR</u> a template - class parameterized by a type</p><p><strong>Example:</strong> Implementing Stack using template</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="type">int</span> size, cap;</span><br><span class="line">    T *contents;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T, x)</span> </span>&#123; ... &#125;;</span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Example:</strong> Implementing List using template</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    Struct Node &#123;</span><br><span class="line">        T data;</span><br><span class="line">        Node *next;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node *head;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">            Node *p;</span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">            T &amp;<span class="keyword">operator</span> *();</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="function">T &amp;<span class="title">ith</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addToFront</span><span class="params">(<span class="type">const</span> T&amp; n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Client:</span></span><br><span class="line">List&lt;<span class="type">int</span>&gt; l1;</span><br><span class="line">List&lt;List&lt;<span class="type">int</span>&gt;&gt; l2;</span><br><span class="line">l1.<span class="built_in">addToFront</span>(<span class="number">3</span>);</span><br><span class="line">l2.<span class="built_in">addToFront</span>(l1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (List&lt;<span class="type">int</span>&gt;:Iterator it = l1.<span class="built_in">begin</span>(); it != l1.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Compiler specializes templates at the source code level, then compiles the specializations.</p><h4 id="Standard-Template-Library-STL"><a href="#Standard-Template-Library-STL" class="headerlink" title="Standard Template Library (STL)"></a>Standard Template Library (STL)</h4><p>A collection of useful templated classes.</p><p>Dynamic length arrays: <code>std::vector</code></p><p><strong>Example:</strong> Client code of <code>std::vector</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;vector&gt;;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// contains &#123;4, 5&#125;</span></span><br><span class="line"><span class="comment">// Note: vector &lt;int&gt; v (4, 5); produces &#123;5, 5, 5, 5&#125;</span></span><br><span class="line">v.<span class="built_in">emplace_back</span>(<span class="number">6</span>); <span class="comment">// contains &#123;4, 5, 6&#125;</span></span><br><span class="line">v.<span class="built_in">emplace_back</span>(<span class="number">7</span>): <span class="comment">// contains &#123;4, 5, 6, 7&#125;</span></span><br></pre></td></tr></table></figure><p>But also:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector w &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;; <span class="comment">// Note: no &lt;int&gt;</span></span><br></pre></td></tr></table></figure><ul><li>if the type argument of a template can be deduced from its initialization, you can leave it out! <int> is deduced here.</li></ul><p><strong>Example:</strong> Looping over vectors:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Regular loop (like array)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; v[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Using an iterator</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterator with ranged-based for loop</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : v) cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reverse iterator</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::reverse_iterator it = v.<span class="built_in">rbegin</span>(); it != v.<span class="built_in">rend</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>More <code>vector</code> functions:</p><ul><li><code>v.pop_back()</code> remove last element</li></ul><p>Use iterators to remove items from inside a vector.</p><p><strong>Example:</strong> remove all 5’s from the vector v.</p><p><u>Attempt #1</u>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">5</span>) v.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Why is this wrong? Consider: we can’t handle consecutive repetitive items.</p><p><u>Note:</u> After the erase, <u>it</u> points at a different item.</p><p>The rule is: after an insertion or erase, all iterators pointing after the point of insertion &#x2F; erase are considered invalid and must be refreshed.</p><p><strong>Example:</strong> Code that iterates through a <code>vector</code> and removes all elements that are equal to 5</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">5</span>) v.<span class="built_in">erase</span>(it);</span><br><span class="line">    <span class="keyword">else</span> it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Another thing to note:</p><p><code>v[i]</code> is i-th element of v.</p><ul><li>This is unchecked, if you go out of bounds, that is <u>undefined behavior</u>.</li></ul><p><code>v.at[i]</code></p><ul><li>Checked version of <code>v[i]</code></li><li>When goes out of bound<ul><li><u>Problem</u>: Vector’s code can detect the error, but doesn’t know what to do about it.</li><li>Client can response, but can’t detect the error.</li><li><u>C solution</u>: function’s return a status code or set the global variable error<ul><li>Leads to awkward programming</li><li>encourages programmers to ignore error checks</li></ul></li></ul></li></ul><p>C++ - when an error condition arises, the function <u>raises an exception</u>.</p><p>By default, execution stops, but we can write <u>handlers</u> to <u>catch</u> exceptions &amp; deal with them.</p><p><code>Vector&lt;T&gt;::at</code> throws an exception of type <code>std::out_of_range</code> when it fails, we can handle it as follows.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;stdexcept&gt;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">at</span>(<span class="number">10000</span>); <span class="comment">// Statement that may fail go in a try block</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (out_of_range r) &#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Range error&quot;</span> &lt;&lt; r.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now consider:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> out_of_range &#123;<span class="string">&quot;f&quot;</span>&#125;; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">f</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">g</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">h</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">catch</span>(out_of_range) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the above code, main calls h, h  calls g, g calls f, f throws. The control goes back through the call chain (unwinds the stack) until the handler is found, all the way back to main, main handles the exception.</p><p>If there’s no matching handler in the entire call chain, the program terminates.</p><p>A handler can do part of the recovery job, i.e. execute some corrective code &amp; throw another exception.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// throw other exception</span></span><br><span class="line"><span class="keyword">try</span> &#123; ... &#125;</span><br><span class="line"><span class="built_in">catch</span> (someError s) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">throw</span> SomeOtherError &#123; ..  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or rethrow same exception</span></span><br><span class="line"><span class="keyword">try</span> &#123; ... &#125;</span><br><span class="line"><span class="built_in">catch</span> (someError s) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// throw or throw s?</span></span><br></pre></td></tr></table></figure><p>maybe <code>someError</code> has a subclass: <code>specialError</code></p><p><code>throw s:</code> s may be a subtype of <code>someError</code>, and throws a new exception of type <code>someError</code>.</p><p><code>throw:</code> actual type of s is retained.</p><p>A handler can act as a catch-all.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; ... &#125;</span><br><span class="line"><span class="built_in">catch</span> (...) &#123; <span class="comment">// Literally &quot;...&quot;, catches all exceptions</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note: You can throw anything you want, it doesn’t have to be an object!</p><p>Define your own classes (or use appropriate existing ones) for exceptions.</p><p><strong>Example:</strong> Bad input</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BadInput</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">int</span> n; !(cin &gt;&gt; n)) <span class="keyword">throw</span> BadInput&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (BadInput &amp;) &#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Input not well-formed. \n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Recap that in Assignment Operator:</p><p>When new fails: throws an exception <code>std::bad_alloc</code>.</p><p><u>NEVER:</u> let a destructor throw or propagate an exception. If we let destructor throw exception:</p><ul><li>Program <u>will</u> abort <u>immediately.</u></li><li>If you want to let a destructor throw, you can tag it with <code>noexcept(false)</code>.</li></ul><p><u>BUT</u>: If a destructor is running during stack unwinding, while dealing with another exception, and it throws, you now have <u>two</u> active, unhandled exceptions, and the program <u>will</u> abort <u>immediately.</u></p><h3 id="Design-Patterns-Continued"><a href="#Design-Patterns-Continued" class="headerlink" title="Design Patterns (Continued)"></a>Design Patterns (Continued)</h3><p>In general, the guiding principle is to program to the interface instead of the implementation.</p><ul><li>The abstract base classes define the interface.<ul><li>work with base class pointers &amp; call their methods.</li></ul></li><li>concrete subclasses can be swapped in &amp; out.<ul><li>abstraction over a variety of behaviors.</li></ul></li></ul><h4 id="Iterator-Pattern-1"><a href="#Iterator-Pattern-1" class="headerlink" title="Iterator Pattern"></a>Iterator Pattern</h4><p><strong>Example:</strong> Abstract Iterator Pattern</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractIterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">int</span> &amp;<span class="keyword">operator</span>*() = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> AbstractIterator &amp;<span class="keyword">operator</span>++() = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> AbstractIterator &amp;other) == <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Iterator</span>:<span class="keyword">public</span> AbstractIterator &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Iterator</span>:<span class="keyword">public</span> AbstractIterator &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Then you can write code that operates over iterators:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Works over Lists and Sets</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">for_each</span><span class="params">(AbstractIterator &amp;start, AbstractIterator &amp;finish, <span class="type">void</span> (*f) (<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (start != end) &#123;</span><br><span class="line">        <span class="built_in">f</span>(*start);</span><br><span class="line">        ++start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Observer-Pattern"><a href="#Observer-Pattern" class="headerlink" title="Observer Pattern"></a>Observer Pattern</h4><p>Publish-subscribe model:</p><ul><li>One class: publisher &#x2F; subject - generates data</li><li>One or more subscriber &#x2F; observer classes - receive data &amp; react to it</li></ul><p><strong>Example:</strong> publisher &#x3D; spreadsheet cells, observers &#x3D; charts</p><ul><li>When cells change graphs update.</li></ul><p>There can be many kinds of observer objects - the subject should not need to know all the details.</p>]]></content>
      
      
      <categories>
          
          <category> School </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Course Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/09/CS136Notes/"/>
      <url>/2024/01/09/CS136Notes/</url>
      
        <content type="html"><![CDATA[<hr><hr><h1 id="CS-136-Course-Notes"><a href="#CS-136-Course-Notes" class="headerlink" title="CS 136 Course Notes"></a>CS 136 Course Notes</h1><h5 id="What-is-procedural-programming"><a href="#What-is-procedural-programming" class="headerlink" title="What is procedural programming?"></a>What is procedural programming?</h5><p>State machine &#x2F; Program change system state</p><h5 id="Topics-and-Themes"><a href="#Topics-and-Themes" class="headerlink" title="Topics and Themes"></a>Topics and Themes</h5><ol><li>System state &amp; Memory management</li><li>Procedural programming style</li><li>Data structures &amp; abstract data types</li><li>Algorithms design &amp; efficiency</li><li>Modularization</li><li>Medium size I&#x2F;O programs</li></ol><h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>My PVZ Development Log</title>
      <link href="/2023/12/20/2023-12-20/"/>
      <url>/2023/12/20/2023-12-20/</url>
      
        <content type="html"><![CDATA[<h3 id="Development-Log-3"><a href="#Development-Log-3" class="headerlink" title="Development Log #3"></a>Development Log #3</h3><h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><p>I just made about six pushes during the past three days. Many new features were implemented (actually they’re not “new” because they should be really familiar to those who’ve played the game before :P), but anyways, this is another log for all the updates.</p><h4 id="Bugs-encountered💀💀💀"><a href="#Bugs-encountered💀💀💀" class="headerlink" title="Bugs encountered💀💀💀"></a>Bugs encountered💀💀💀</h4><p>So far I encountered three big bugs that confused me quite some while. Thanks god I managed to fix them all. Bugs that are the easiest to fix are those where problems are merely logics. That being said the goofiest and most devastating are stupid errors like typos.</p><ul><li><pre><code>for (int i = 0; i &lt; num; i)</code></pre></li></ul><p>​Notice how in the above for loop there’s no addition to i every iteration, which means something are not going to work out</p><ul><li><p>zms[k] but k should be i. Similar to above, typo errors.</p></li><li><p>Accidentally put some code blocks into a supposedly empty loop (took me one day to notice the bug, literally carefully read through the entire code five times to find it out).</p></li></ul><h5 id="Bug-1"><a href="#Bug-1" class="headerlink" title="Bug 1"></a>Bug 1</h5><p>Zombies could not spawn.</p><p>​At first I thought it is that there’s problem rendering the zombie and I couldn’t see it on the screen. So after making sure the logic for the zombie’s movement make sense I start the game and let the “invisible” zombie walk. However once I realize after a long period of time the game wouldn’t stop automatically I know for sure things go wrong with creating the zombie. So quickly I locate the function that explicitly does this, which is called createZM().</p><p>​The problem is cause by me putting the code block that actually creating the zombie inside of an empty loop that should do nothing when zms[i].used is false. After extracting it out the bug is fixed.</p><h5 id="Bug-2"><a href="#Bug-2" class="headerlink" title="Bug 2"></a>Bug 2</h5><p>Peashooter shoot even if zombies is behind it</p><p>​This one is simply logical error. At first I didn’t consider the relative distance between each zombie and each peashooter. So the logic before the bug is fixed is that if there’s a zombie on the row, the peashooter would shoot the pea. However, since this logic failed to consider the case when peashooter is somehow planted behind the zombie, i.e. plant.x &gt; zombie.x, the peashooter should stop shooting pea. That make more sense as regular peashooter’s head is confronting toward the right direction, and there’s no way it can shoot backward (there’s a reverse shooter which shoot backward, but we’re not making it in this game).</p><p>​My resolution is by nesting another loop which traverse all possible zombies in the current zombie pool, and by analyzing the relative distance between each zombies and each plant, each peashooter can dynamically justify which zombie should it shoot and which should it not.</p><p>​Later when I look back to my resolution to this bug, I found that such an extra loop causes further bugs.</p><h5 id="Bug-3"><a href="#Bug-3" class="headerlink" title="Bug 3"></a>Bug 3</h5><p>Peashooter shooting too much at a time</p><p>​From the resolution in bug 2 I traverse all zombies to analyze the relative distance between each zombie and each peashooter. Now, one thing is that I embedded the actual function of “shooting the pea” into the innermost side of the triple loop. The problem is quickly revealed: The more zombies on a same row, the faster each peashooter shoots than it should be.</p><p>​In the original Plants-vs-Zombies, no matter how many zombies there’s in front of a peashooter, the peashooter should always shoot at a same frequency. Which means the frequency of shooting is a constant, rather than a variable.</p><p>​The reason for the bug is because during the for-k-loop which loop through each zombie in the pool, the pea-shooting function specifically ran for that zombie, so let’s say if the peashooter shoot one pea per second per zombie, if there’s two zombies standing on a same row, then since the pea-shooting function is ran twice, the peashooter would shoot two peas per second. That being said the peashooter’s shooting frequency is positively related to the amount of zombies presented ahead of that specific peashooter. The more zombies ahead, seemingly the “faster” it shoots.</p><p>​What confuses me the most is analyze and locate the problem. In fact the peashooter did not shoot faster at all. The frequency of it shooting peas are all the same. The fact that it seems like the peashooter shoots faster is because the program is ran more than one time, by which one at a time is ought to be the correct idea. Then the solution becomes much more clear, which is simply by restricting the amount of time the pea-shooting program is ran. By setting the program only allowed to run once at a time, the peashooter shoots in a normal speed again. </p><p>​What’s more, the peashooter keep shooting after the first zombie is dead, and the flying peas that are shot before the dead zombie dies kept flying and hit the next zombie and causes damage. This is because all peas are individual and does not relate to the peashooter. The only job that the pea does is to fly toward the east and causes damage to any zombie when collide. </p><h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><p>​Debugging in C++ is a painful thing. The most critical step is not fixing the bug, but instead locating the bug. Honestly speaking though one would not be able to correctly locate a bug if he&#x2F;she doesn’t understand why the bug occur. So once the bug is located, it is probable that you already understand the problem and are ready to fix it smoothly.</p><h4 id="Some-pictures-showing-latest-developed-features"><a href="#Some-pictures-showing-latest-developed-features" class="headerlink" title="Some pictures showing latest developed features"></a>Some pictures showing latest developed features</h4><h5 id="Sunshine-Balance"><a href="#Sunshine-Balance" class="headerlink" title="Sunshine Balance"></a>Sunshine Balance</h5><p><img src="https://github.com/M4cr0Chen/MyPic/blob/main/img/202312201716049.png?raw=true" alt="202312201716049.png"></p><h5 id="Sunshine-Addition"><a href="#Sunshine-Addition" class="headerlink" title="Sunshine Addition"></a>Sunshine Addition</h5><p><img src="https://github.com/M4cr0Chen/MyPic/blob/main/img/202312201717784.png?raw=true" alt="202312201717784.png"></p><h5 id="Create-Zombies"><a href="#Create-Zombies" class="headerlink" title="Create Zombies"></a>Create Zombies</h5><p><img src="https://github.com/M4cr0Chen/MyPic/blob/main/img/202312201719988.png?raw=true" alt="202312201719988.png"></p><h5 id="Peashooter-shoots-Peas"><a href="#Peashooter-shoots-Peas" class="headerlink" title="Peashooter shoots Peas"></a>Peashooter shoots Peas</h5><p><img src="https://github.com/M4cr0Chen/MyPic/blob/main/img/202312201720526.png?raw=true" alt="202312201720526.png"></p><p><img src="https://github.com/M4cr0Chen/MyPic/blob/main/img/202312201723407.png?raw=true" alt="202312201723407.png"></p><h5 id="Zombie-die"><a href="#Zombie-die" class="headerlink" title="Zombie die"></a>Zombie die</h5><p><img src="https://github.com/M4cr0Chen/MyPic/blob/main/img/202312201724270.png?raw=true" alt="202312201724270.png"></p><h5 id="Game-Over"><a href="#Game-Over" class="headerlink" title="Game Over"></a>Game Over</h5><p><img src="https://github.com/M4cr0Chen/MyPic/blob/main/img/202312201726882.png?raw=true" alt="202312201726882.png"></p>]]></content>
      
      
      <categories>
          
          <category> School </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Game Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My PVZ Development Log</title>
      <link href="/2023/12/17/2023-12-17/"/>
      <url>/2023/12/17/2023-12-17/</url>
      
        <content type="html"><![CDATA[<h2 id="My-Plants-vs-Zombies-Development-Log-2"><a href="#My-Plants-vs-Zombies-Development-Log-2" class="headerlink" title="My-Plants-vs-Zombies Development Log #2"></a>My-Plants-vs-Zombies Development Log #2</h2><p>I just finished my last final exam yesterday so hey, I finally got free time to work on this lil project :P</p><p>Just to recap, what I did in the first day are basically setting up a bunch of background images like the images for the lawn and the toolbar. The entire game interface is created so that’s a good start for me.</p><h4 id="What-I-did-afterward-are-following"><a href="#What-I-did-afterward-are-following" class="headerlink" title="What I did afterward are following:"></a>What I did afterward are following:</h4><ol><li>Implemented selection and dragging of the plants</li><li>Enabling the plants to be “planted” on the ground</li><li>Iteratively display the picture set in the res folder to create the waving animation of the plants</li><li>Created a starting menu of the game</li><li>Randomly creating Sunshine, and…</li><li>Display the random Sunshine.</li></ol><p>I defined the own structure like</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct sunshineBall &#123;</span><br><span class="line">int x, y; // Coordinates for the X and Y Coord of sunshine when falling</span><br><span class="line">int frameIndex; // Index for the current displaying picture</span><br><span class="line">int destY; // Y-Coord for the destination of the falling sunshine</span><br><span class="line">bool used; // Using or not</span><br><span class="line">int timer; //</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>which is exactly something we learned in CS135. I’m not gonna lie, struct are indeed very useful and convenient.</p><p>One of the confusing topic is the pointer variable and memories, I would’ve to read the textbook to understand what it does lol.</p><h4 id="Starting-Menu"><a href="#Starting-Menu" class="headerlink" title="Starting Menu"></a>Starting Menu</h4><p><img src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/main/img/202312171122020.png" alt="img"></p><h4 id="Selecting-and-Dragging-Plants"><a href="#Selecting-and-Dragging-Plants" class="headerlink" title="Selecting and Dragging Plants"></a>Selecting and Dragging Plants</h4><p><img src="https://github.com/M4cr0Chen/MyPic/blob/main/img/202312171125413.png?raw=true" alt="202312171125413.png"></p><h4 id="Planting-the-Plant-to-the-center-of-lawn-block"><a href="#Planting-the-Plant-to-the-center-of-lawn-block" class="headerlink" title="Planting the Plant to the center of lawn block"></a>Planting the Plant to the center of lawn block</h4><p><img src="https://github.com/M4cr0Chen/MyPic/blob/main/img/202312171126291.png?raw=true" alt="202312171126291.png"></p><h4 id="Displaying-Random-Sunshine"><a href="#Displaying-Random-Sunshine" class="headerlink" title="Displaying Random Sunshine"></a>Displaying Random Sunshine</h4><p><img src="https://github.com/M4cr0Chen/MyPic/blob/main/img/202312171127493.png?raw=true" alt="202312171127493.png"></p>]]></content>
      
      
      <categories>
          
          <category> School </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Game Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Math 135 Notes</title>
      <link href="/2023/12/14/Math135Notes/"/>
      <url>/2023/12/14/Math135Notes/</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/m135.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> School </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Course Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Math 137 Notes</title>
      <link href="/2023/12/14/Math137Notes/"/>
      <url>/2023/12/14/Math137Notes/</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/m137.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> School </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Course Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My PVZ Development Log</title>
      <link href="/2023/12/13/2023-12-13/"/>
      <url>/2023/12/13/2023-12-13/</url>
      
        <content type="html"><![CDATA[<h3 id="My-PVZ-Development-Log-1"><a href="#My-PVZ-Development-Log-1" class="headerlink" title="My PVZ Development Log #1"></a>My PVZ Development Log #1</h3><p>The project is based on C language, mainly focusing on C++. The IDE I used is Visual Studio 2022.</p><p>This is the first day of the development, I am looking forward of reproducing a well known 2D tower defense game Plants-vs-Zombies. I am new to C so I would’ve to learn all the basics and perhaps some deeper concepts of this programming language during the development. So for me basically this project is a pretty good preview of those bunch of concepts of C in advance.</p><p>I am planning to finish the project before the start of the winter term, which is gonna be January 8th. That being said I have roughly about 25 days to work on this project solely. Hopefully I can get over any bugs and errors during the development.</p><p>Following are what I did today,</p><ol><li>Create new project (empty project template) using any version of Visual Studio</li><li>Import materials</li><li>Implement primary game scene</li><li>Implement the tool bar at the top of the game panel</li><li>Implement the plant cards in the tool bar</li></ol><p><img src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/main/img/202312132104368.png" alt="1"></p><p>Basically what I did today is to create an actual panel with size 900 * 600 (which is the default resolution of the original game) to display the content; added a background image; added a “tool bar” which held all the plants’ cards; wrote some functions that access the resource folder to get the available plant cards, and placed them on to the tool bar separated by a certain widths. Last thing I did today is to allow the program to peek message of user’s input, by far only left-click to grab up the plant, and yet not able to place the plants down. </p><p><img src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/main/img/202312132106302.png" alt="2"></p><p><img src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/main/img/202312132106995.png" alt="3"></p><p>C is honestly quite different from Racket,  the one I’ve down into for the past three months (it’s always waterloo 1A CS135), and honestly I’ve had enough of recursion. As an imperative language C works much different from functional languages like Lisp or Racket. It’s refreshing picking up concepts like for loop, while loop, if-else statements, and so on again. Even though the grammar mike seems identical between JAVA and C (and C++), I feel like they’re much different from each other as C really shows much more basic details of programming compared to JAVA.</p>]]></content>
      
      
      <categories>
          
          <category> School </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Game Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo的个人博客网站搭建的简易教程</title>
      <link href="/2023/07/13/2023-07-13/"/>
      <url>/2023/07/13/2023-07-13/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-Github-搭建个人博客从0到1教程"><a href="#Hexo-Github-搭建个人博客从0到1教程" class="headerlink" title="Hexo + Github 搭建个人博客从0到1教程"></a><a href="https://so.csdn.net/so/search?q=Hexo&spm=1001.2101.3001.7020">Hexo</a> + Github 搭建个人博客从0到1教程</h1><h3 id="一、正式搭建博客前需要做的准备（软件安装）"><a href="#一、正式搭建博客前需要做的准备（软件安装）" class="headerlink" title="一、正式搭建博客前需要做的准备（软件安装）"></a>一、正式搭建博客前需要做的准备（软件安装）</h3><h5 id="搭建前置准备软件："><a href="#搭建前置准备软件：" class="headerlink" title="搭建前置准备软件："></a>搭建前置准备软件：</h5><p>Git：官网下载：<a href="https://git-scm.com/">https://git-scm.com/</a></p><p>Node.js 官网下载：<a href="http://nodejs.cn/">http://nodejs.cn/</a></p><h3 id="二、Hexo的安装"><a href="#二、Hexo的安装" class="headerlink" title="二、Hexo的安装"></a>二、Hexo的安装</h3><p>个人经历，国内使用npm经常出现莫名其妙报错情况（个人搭建过程中遇到不少次这样情况），于是在其他大佬的博客中学习到使用淘宝镜像源。</p><ol><li><h5 id="我们这里利用npm先安装cnpm"><a href="#我们这里利用npm先安装cnpm" class="headerlink" title="我们这里利用npm先安装cnpm"></a>我们这里利用npm先安装cnpm</h5></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>cnpm个人认为非常强大，当你遇到npm install “xxx” 出现恶心人的报错时（没错，你在搭建的过程中绝对会遇到至少几个抽象的报错，没有人能逃离 | 笑），不妨重新输入一次该死的指令，然后在指令前面加一个小巧可爱的 “ c ”。嗯，很多时候这样简单的操作就可以解决问题。</p><ol start="2"><li><h5 id="Win键输入-“Command”-或-“命令提示符”-打开cmd窗口，输入指令："><a href="#Win键输入-“Command”-或-“命令提示符”-打开cmd窗口，输入指令：" class="headerlink" title="Win键输入 “Command” 或 “命令提示符” 打开cmd窗口，输入指令："></a>Win键输入 “<strong>Command</strong>” 或 “<strong>命令提示符</strong>” 打开cmd窗口，输入指令：</h5></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><ol start="3"><li><h5 id="在本地创建一个文件夹"><a href="#在本地创建一个文件夹" class="headerlink" title="在本地创建一个文件夹"></a>在本地创建一个文件夹</h5></li></ol><p>个人起名为Blog因为好记好认。随后右键 &#x2F; 点击Git Bash （这里就是我们会最常用到的命令终端窗口了，不过之后建议用Visual Studio Code的终端，会更好用）</p><ol start="4"><li><h5 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h5></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><ol start="5"><li><h5 id="检验hexo是否能够启动成功"><a href="#检验hexo是否能够启动成功" class="headerlink" title="检验hexo是否能够启动成功"></a>检验hexo是否能够启动成功</h5></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>表示hexo成功启动</p><ol start="6"><li><h5 id="博客文件初始化成功后，来看看你的Blog文件夹里都有什么"><a href="#博客文件初始化成功后，来看看你的Blog文件夹里都有什么" class="headerlink" title="博客文件初始化成功后，来看看你的Blog文件夹里都有什么"></a>博客文件初始化成功后，来看看你的Blog文件夹里都有什么</h5><ol><li>node_modules: 依赖包 （后期魔改网站用到如pug，stylus，以及一大堆dependencies都会存放在这个网站）</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章，css文件，js文件，后期写文章就要用到这个文件夹</li><li>themes：主题（如果使用的是 git clone 则会下载到这个文件夹中，如果是 npm install 则会在上面1. node_modules 里）</li><li>_config.yml: 博客的配置文件 （这个文件很重要，是整个网页的基底，千万要保存好）</li></ol></li><li><h5 id="此时到浏览器里输入"><a href="#此时到浏览器里输入" class="headerlink" title="此时到浏览器里输入"></a>此时到浏览器里输入</h5></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:4000/</span><br></pre></td></tr></table></figure><p>即可看到你最初始化的博客网页了。</p><p>记住这个时候你的博客网页都只是本地文件，你也能看见你进入的网址为localhost，而你需要把你本地的文件部署到互联网上，别人才能通过输入域名来访问你的网站。</p><p>怎么做呢？我们使用大伙最常用的方式：部署到Github进行代码云保管。</p><h3 id="三，将Hexo部署到Github"><a href="#三，将Hexo部署到Github" class="headerlink" title="三，将Hexo部署到Github"></a>三，将Hexo部署到Github</h3><h5 id="1-Github创建个人仓库"><a href="#1-Github创建个人仓库" class="headerlink" title="1.Github创建个人仓库"></a>1.Github创建个人仓库</h5><p>首先，需要有一个github账号。登上账号后建一个仓库：仓库名为你的用户名.github.io，<br>举例如下：<br>创建一个和你用户名相同的仓库，后面加.github.io，<br>只有这样，将来要部署到GitHub的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名.</p><h5 id="2-生成ssh添加到Github"><a href="#2-生成ssh添加到Github" class="headerlink" title="2.生成ssh添加到Github"></a>2.生成ssh添加到Github</h5><h5 id="在Github上创建仓库完成之后，需要设置ssh免密登录"><a href="#在Github上创建仓库完成之后，需要设置ssh免密登录" class="headerlink" title="在Github上创建仓库完成之后，需要设置ssh免密登录"></a>在Github上创建仓库完成之后，需要设置ssh免密登录</h5><p>1.打开cmd窗口：执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure><p>这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。用户名为仓库的名称，邮箱为注册github的邮箱。</p><p>防止输错可以检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><p>2.接着进入到家目录：C:\Users\Zhenghong Chen，右击打开git bash 。</p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C 2561618861@qq.com</span><br></pre></td></tr></table></figure><p>后面是自己注册github的邮箱，然后敲三次回车，</p><p><img src="https://img-blog.csdnimg.cn/b07cadba4a484a7eac9c19884ea6f3b5.png"></p><p>3.接着就会发现C:\Users\libinbin下多了一个.ssh目录，打开后有一个公钥，一个私钥。id_rsa.pub是公钥，我们需要打开它，复制里面的内容。</p><p>然后进入github：</p><p>点击setings</p><p>进行以下操作</p><p>发现我们需要一个密钥，把我们刚刚复制的密钥粘进去，title随便起</p><p>点击 Add SSH Key</p><h5 id="3-进行部署"><a href="#3-进行部署" class="headerlink" title="3.进行部署"></a>3.进行部署</h5><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为<br>YourgithubName就是你的GitHub账户</p><p>1.修改配置文件</p><p>修改内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:goubin18/goubin18.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>注意：后面有空格</p><p>repo：获取步骤如下</p><p>点进自己刚刚创建的仓库，复制</p><p>2.找到自己的博客路径打开</p><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>2.然后依次执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo cl      #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure><p>注意deploy时会让输个yes</p><p>最后回到github上查看自己的仓库：</p><p>这就表示上传成功。</p><p>现在就可以使用xxx.github.io来访问你的博客啦<br>例如：我的用户名是M4cr0Chen，那么我的博客地址就是M4cr0Chen.github.io</p><p>————————————————<br>版权声明：本文为CSDN博主「小尘要自信」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_54796785/article/details/126053172">https://blog.csdn.net/qq_54796785/article/details/126053172</a></p>]]></content>
      
      
      <categories>
          
          <category> School </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
