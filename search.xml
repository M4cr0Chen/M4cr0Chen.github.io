<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CS 246 Notes</title>
      <link href="/2024/09/05/CS246%20Object-Oriented%20Software%20Dev/"/>
      <url>/2024/09/05/CS246%20Object-Oriented%20Software%20Dev/</url>
      
        <content type="html"><![CDATA[<h1 id="CS246-Object-Oriented-Software-Dev"><a href="#CS246-Object-Oriented-Software-Dev" class="headerlink" title="CS246 Object-Oriented Software Dev"></a>CS246 Object-Oriented Software Dev</h1><p>OOP from three perspectives:</p><ol><li><strong>Programmer’s perspective</strong> - How to structure programs correctly, how to lower the risk of bugs.</li><li><strong>Compiler’s perspective</strong> - What do our constructors actually means, and what must the compiler do to support them.</li><li><strong>Designer’s perspective</strong> - How to use OOP tools (encapsulation, inheritance, polymorphism, etc.) to build systems.</li></ol><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><u>Introduction</u></h2><h4 id="Comparison-between-C-and-C"><a href="#Comparison-between-C-and-C" class="headerlink" title="Comparison between C and C++:"></a>Comparison between C and C++:</h4><p>C:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;iostream&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note:</p><ul><li><p>import, like <code>#include</code>, brings <u>names</u> and <u>definitions</u> from other files, libraries, or module into our code.</p><ul><li><p><code>import</code>, was C++’s new <u>module system</u>, more about modules in future lectures.</p></li><li><p><code>#include &lt;iostream&gt;</code> works. However module system is preferred in CS 246.</p></li></ul></li><li><p>function <code>main()</code> must return int, <code>void main() &#123;...&#125;</code> is not legal in C++</p></li><li><p>return statement returns a <u>status code</u> to OS</p><ul><li>can be omitted from main-default to <code>return 0;</code></li></ul></li><li><p><code>cout</code> and <code>&lt;&lt;</code> are how you write to stdout.</p><ul><li>this is the preferred way to do <strong>I&#x2F;O</strong> in C++</li><li>stdio.h and printf are still available in C++</li></ul></li><li><p><code>using namespace std</code></p><ul><li>called a <u>using directive</u></li><li>C++ organizes names into namespaces</li><li>without <code>using namespace std</code>, you need to write <ul><li><code>std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl</code></li></ul></li></ul></li><li><p>most C programs work in C++ (or minimal changes is required)</p></li></ul><h4 id="Input-x2F-Output"><a href="#Input-x2F-Output" class="headerlink" title="Input&#x2F;Output"></a><strong>Input&#x2F;Output</strong></h4><p>Basic Info</p><p>​C++ comes with 3 built-in I&#x2F;O streams:</p><p>​<code>cout</code> - for writing to <code>stdout</code></p><p>​<code>cerr</code> - for writing to <code>stderr</code></p><p>​<code>cin</code> - for reading from <code>stdin</code></p><p>​Built-in Operators:</p><p>​<code>&lt;&lt;</code> “put to”, insertion operator (output)</p><p>​<code>&gt;&gt;</code> “get from”, extraction operator (input)</p><p><code>&lt;&lt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; ____ &lt;&lt; ____ &lt;&lt; ____ &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>[^]: dates, expressions, literals<br>[^]: <code>endl</code> outputs an end of line char, and flushes the output buffer.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; X<span class="comment">// Operator &quot;point&quot; in the direction of data flow</span></span><br><span class="line">cerr &lt;&lt; X<span class="comment">// Never buffered</span></span><br><span class="line"> cin &gt;&gt; X<span class="comment">// Extract a value from stdin and put it into X.</span></span><br></pre></td></tr></table></figure><p>Example: Read 2 ints and print their sum</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;iostream&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    cout &lt;&lt; x + y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note:</p><ul><li>The <code>&gt;&gt;</code> operator tries to interpret the input data, according to the type of variable being read into.<ul><li>In this case, <strong>x</strong> is an <strong>int</strong>, so <strong>&gt;&gt;</strong> will expect to read chars that look like an int: <u>“123”</u> or <u>“-42”</u> and assemble those chars into an int <u>value</u>.</li></ul></li><li>it’ll stop reading when it sees a character that is not part of an integer (letter or space)</li><li><code>cin &gt;&gt;</code> ignores leading whitespaces (spaces, tabs, newlines)</li><li>when reading from the keyboard, the program will pause waiting for the user input.</li><li>pressing <u>Enter</u> causes the entered text to be submitted to the program</li><li>pressing <u>^D</u> signals end of file, or end of input</li></ul><p><u>What if bad things happen?</u></p><ul><li><p>input doesn’t contain an int</p></li><li><p>input is too large to fit in the variable</p></li><li><p>input is exhausted (not enough data) and get 2 ints</p></li></ul><p><u>The input operation fails, how can we test for this in our program?</u></p><ul><li><p>if read failed (for whatever reasons): <code>cin.fail()</code> will return true</p></li><li><p>if EOF: <code>cin.eof()</code> will also return true</p></li><li><p>But not until attempted read fails</p></li></ul><p>Example: read all int from <code>stdin</code>, echo to <code>stdout</code>, one per line, stop at EOF or bad input.</p><p>Example 1:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">        <span class="keyword">if</span> (cin.<span class="built_in">fail</span>()) <span class="keyword">break</span>; <span class="comment">// Check for failure</span></span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">        <span class="keyword">if</span> (!cin) <span class="keyword">break</span>; <span class="comment">// cin variable is being implicitly converted to a boolean value</span></span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cin</code> converts to:</p><ul><li><code>true</code> if all good</li><li><code>false</code> if the stream has had a read failure</li><li><code>&gt;&gt;</code> means right bit shift operator in C&#x2F;C++</li><li>a, b are int, a <code>&gt;&gt;</code> b a’s bits to the right for b spots.<ul><li>21 &#x3D; 10101</li><li>21 &gt;&gt; 3 &#x3D; 10<del>101</del> &#x3D; 10 &#x3D; 2</li></ul></li></ul><p><strong>Question</strong>: How do the program knows whether <code>&gt;&gt;</code> is <u>shifting bits</u> or <u>get from operator</u>?</p><p><strong>Answer</strong>: They depends on the provided arguments!</p><ul><li>when LHS is from <code>&lt;iostream&gt;</code> (<code>cin</code>), <code>&gt;&gt;</code> is “get from”</li><li>when LHS is int, <code>&gt;&gt;</code> is “shifting bits”</li><li>this is the very first example of function overloading:<ul><li>same function&#x2F;operator has multiple, different implementations &amp; meanings.<ul><li>the compiler choose wisely based on the provided <strong>number</strong> and <strong>type</strong> of the arguments, which are done at compile time.</li></ul></li></ul></li></ul><p><code>&gt;&gt;</code></p><p><code>cin &gt;&gt; i;</code></p><p>Let’s take a closer look at the <code>&gt;&gt;</code> operator:</p><ul><li>The <code>&gt;&gt;</code> operator has 2 operands:<ul><li><code>cin</code>, which is a stream</li><li><code>i</code>, a variable to receive the input data.</li></ul></li><li>And it returns on result:<ul><li><code>cin</code>, the same stream used as the first operand</li><li>it also has a <u>side effect</u></li></ul></li></ul><p>The fact that <u>it returns a stream (<code>cin</code>)</u>, is why we can chain a series of these together</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> cin &gt;&gt; x &gt;&gt; y &gt;&gt; z</span><br><span class="line">[cin &gt;&gt; x] -&gt; cin</span><br><span class="line">    = cin &gt;&gt; y &gt;&gt; z</span><br><span class="line">    [cin &gt;&gt; y] -&gt; cin</span><br><span class="line">     = cin &gt;&gt; z</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// READ Example v3:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(cin &gt;&gt; i)) <span class="keyword">break</span>; <span class="comment">// Reading into i and checking for failure</span></span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// READ Example v4:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; i) &#123; <span class="comment">// if we cannot get anymore input, then cin &gt;&gt; i is false</span></span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read all ints from stdin, echo them to stdout until EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// V1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">cin &gt;&gt; i;</span><br><span class="line"><span class="keyword">if</span> (cin.<span class="built_in">eof</span>()) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cin.<span class="built_in">fail</span>()) &#123; <span class="comment">// 1. Proper - print 2. EOF - break 3. Bad input - skip</span></span><br><span class="line">cin.<span class="built_in">clear</span>();  <span class="comment">// Reset the stream&#x27;s failure flag, the stream will not function after failure until you do this.</span></span><br><span class="line">cin.<span class="built_in">ignore</span>(); <span class="comment">// Removes the offending character from the stream.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">// 1. Proper - print 2. EOF - break 3. Bad input - skip</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cin &gt;&gt; i) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; hex &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; dec &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cin.<span class="built_in">eof</span>()) <span class="keyword">break</span>; <span class="comment">// Done - EOF</span></span><br><span class="line">        </span><br><span class="line">        cin.<span class="built_in">clear</span>();</span><br><span class="line">        cin.<span class="built_in">ignore</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note:</p><ul><li><code>clear()</code> must come before <code>ignore()</code>, called<code>ignore()</code> on a failed stream does nothing.</li><li><code>ignore()</code> removes 1 char from the stream.</li><li><code>ignore(count)</code> removes count chars from stream</li><li><code>ignore(count, &#39;\n&#39;)</code> removes count chars <u>or</u> everything up to and including the newline char, whatever comes first.</li></ul><p><u>Formatted Output</u></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="number">95</span> &lt;&lt; endl; <span class="comment">// Prints &quot;95&quot;</span></span><br><span class="line">cout &lt;&lt; hex &lt;&lt; <span class="number">95</span> &lt;&lt; endl; <span class="comment">// Prints 5F (95 in hexadecimal)</span></span><br></pre></td></tr></table></figure><p><code>hex</code>: I&#x2F;O manipulator - puts the stream into “hex mode” all subsequent integers are printed in hex.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; dec; <span class="comment">// switches the stream back to decimal mode.</span></span><br></pre></td></tr></table></figure><p>Example: print a dollar amount with leading asterisks in a width of 10 characters</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> m = <span class="number">10.9</span>;</span><br><span class="line"><span class="comment">// cout &lt;&lt; setprecision(2) &lt;&lt; 10.912345678 &lt;&lt; endl; Output: 11</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; right &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; m &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: *****10.90</span></span><br></pre></td></tr></table></figure><p>Note: Use import <code>&lt;iomanip&gt;;</code></p><ul><li>Manipulators set flags in the stream. These are effectively global variables. Changes you make affect the program from that point on.</li><li>Changes to the stream only lives to the end of the program. i.e. Once restart the program, stream is renewed.</li></ul><hr><h2 id="C-Features"><a href="#C-Features" class="headerlink" title="C++ Features"></a><u>C++ Features</u></h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>C strings: An array of <code>char</code> (<code>char *</code> or <code>char[]</code>) terminated by a <code>null char</code> (\0)</p><ul><li>must explicitly manage memory - allocate more memory as strings get bigger</li><li>easy to overwrite the \0 at the end.</li><li>one of the biggest sources of security vulnerabilities</li></ul><p>C++ strings: GOOD NEWS, built-in string data type.</p><ul><li>intuitive, easy-to-use</li><li>string grow as needed (no need to manage memory explicitly)</li><li>safer to manipulate.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">string s3 = s1 + <span class="string">&quot; &quot;</span> + s2;</span><br></pre></td></tr></table></figure><p>Note: C++ Strings are created from C string on initialization.</p><p>String operations:</p><ul><li>equality&#x2F;inequality: &#x3D;&#x3D;, !&#x3D;<code>s1 == s2</code> | <code>s1 != s2</code></li><li>comparisons: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, etc. (lexicographic by default)</li><li>length: <code>s.length()</code>. →  O(1) time. “String structure stores each string’s length”</li><li>concat: <code>s3 = s1 + s2;</code> <code>s3 += s1;</code> ← s3 need to be pre-defined.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (s1 == s2) cout &lt;&lt; <span class="string">&quot;same&quot;</span> &lt;&lt; endl; <span class="comment">// comparing strings NOT memory addresses</span></span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;not same&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure><ul><li>individual chars:<ul><li><code>s[0]</code> - returns first char</li><li><code>s[1]</code> - returns second char</li></ul></li><li>mutable<ul><li><code>s[0] = &#39;h&#39;;</code></li></ul></li></ul><p>Example: Read Strings</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s; <span class="comment">// Skip leading whitespace, start reading, then stop at consequent whitespace.</span></span><br></pre></td></tr></table></figure><p>What if we want the whitespace?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin, s); <span class="comment">// getline(stream, string variable name)</span></span><br><span class="line"> <span class="comment">// Reads from current position up to next \n into s. (Excluding \n)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line">cin.<span class="built_in">get</span>(c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(cin.<span class="built_in">get</span>(c)) &#123;</span><br><span class="line">    cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Streams are an <u>abstraction</u>. “<em>They wrap an interface of “getting &amp; putting items” around the keyboard &amp; screen.</em>“</p><p>Are there other kinds of “<u>things</u>“ that could support the “<u>getting and putting</u>“ interface?</p><hr><h3 id="File-Stream-x2F-1"><a href="#File-Stream-x2F-1" class="headerlink" title="File Stream&#x2F;1"></a>File Stream&#x2F;1</h3><ul><li>read and write a file instead of stdin&#x2F;stdout.<ul><li><code>std::ifstream</code> - a file stream for reading</li><li><code>std::ofstream</code> - a file stream for writing</li><li>must import <code>&lt;fstream&gt;;</code></li></ul></li></ul><p>File access in C:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *f = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">char</span> s[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">fscanf</span>(f, <span class="string">&quot;%255s&quot;</span>, s);</span><br><span class="line">        <span class="keyword">if</span> (feof(f)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>File access in C++:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;iostream&gt;;</span><br><span class="line"><span class="keyword">import</span> &lt;fstream&gt;;</span><br><span class="line"><span class="keyword">import</span> &lt;string&gt;; <span class="comment">// import and compile string lastly!</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    ifstream f &#123;<span class="string">&quot;file.txt&quot;</span>&#125;; <span class="comment">// Declares and initializes the istream variable f. And opens the file.</span></span><br><span class="line">    <span class="keyword">while</span> (f &gt;&gt; s) &#123;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// File is closed automatically when the f variable goes out of scope: End of main().</span></span><br></pre></td></tr></table></figure><p>Note:</p><ul><li>Anything you can do with <code>cin</code>&#x2F;<code>cout</code>, you can do with an <code>ifstream</code>&#x2F;<code>ofstream</code>.</li></ul><h3 id="String-x2F-2"><a href="#String-x2F-2" class="headerlink" title="String&#x2F;2"></a>String&#x2F;2</h3><ul><li><code>import &lt;string&gt;;</code></li><li>Extract data from chars in a string: <code>std::istringstream</code>.</li><li>Send data to a string as chars: <code>std::ostringstream</code>.</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;sstream&gt;;</span><br><span class="line"><span class="keyword">import</span> &lt;string&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// E.g. -&gt; convert int to string</span></span><br><span class="line"><span class="function">string <span class="title">intToString</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    ostringstream sock; <span class="comment">// stream that writes to a string</span></span><br><span class="line">    sock &lt;&lt; n;</span><br><span class="line">    <span class="keyword">return</span> sock.<span class="built_in">str</span>(); <span class="comment">//extract the string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s = <span class="built_in">intToString</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// E.g. -&gt; convert string to number</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Enter a number&quot;</span> &lt;&lt; endl;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s; <span class="comment">// Input the string</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (istringstream sock&#123;s&#125;; sock &gt;&gt; n) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I said, &quot;</span>; <span class="comment">// keep asking for new num until provided.</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You entered &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Compare the two implementations:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Earlier Version</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// if false, then something bad happened -&gt; EOF, bad input</span></span><br><span class="line"><span class="keyword">if</span> (! (cin &gt;&gt; i)) &#123;</span><br><span class="line"><span class="keyword">if</span> (cin.<span class="built_in">EOF</span>()) <span class="keyword">break</span>;</span><br><span class="line">cin.<span class="built_in">clear</span>(); <span class="comment">// resets stream (must be cleared before another read)</span></span><br><span class="line">cin.<span class="built_in">ignore</span>(); <span class="comment">// removes offensive character from the stream</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl; <span class="comment">// will be default printed as a decimal</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// E.g. -&gt; Echo all numbers, skip all non-numbers</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s) &#123; <span class="comment">// Only fail when EOF</span></span><br><span class="line">    <span class="comment">// ignores whitespace, read until the largest input</span></span><br><span class="line"><span class="comment">// read as a string</span></span><br><span class="line"><span class="comment">// read until hit whitespace or EOF</span></span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> (istringstream sock&#123;s&#125;; sock &gt;&gt; n) &#123;</span><br><span class="line"><span class="comment">// convert s into input string stream, then convert to int</span></span><br><span class="line">        <span class="comment">// local scope, every new iteration will clear off fail flags</span></span><br><span class="line">            cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// Else just continue the loop</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ex. 3.1415 is all read in cin, then we use it as an istringstream, but then </span></span><br><span class="line"><span class="comment">// we only print out 3 because the . after that isn&#x27;t an int so it stops</span></span><br><span class="line"></span><br><span class="line">abc123</span><br><span class="line">EX<span class="number">.1</span> -&gt; <span class="number">123</span>          EX<span class="number">.2</span> -&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">3.1415</span></span><br><span class="line">EX<span class="number">.1</span> -&gt;              EX<span class="number">.2</span> -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1415</span>            </span><br><span class="line"></span><br><span class="line"><span class="number">123</span>abc</span><br><span class="line">EX<span class="number">.1</span> -&gt; <span class="number">123</span>          EX<span class="number">.2</span> -&gt; <span class="number">123</span></span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="Command-Line-Arguments"><a href="#Command-Line-Arguments" class="headerlink" title="Command Line Arguments"></a>Command Line Arguments</h3><p>To accept command line arguments in C or C++, always give main the following parameters:</p><p><code>int main(int argc, char *argv[]) &#123;...&#125;</code> where:</p><ul><li><code>int argc</code> stands for # of CMD Line Args<ul><li><code>argc</code> &gt;&#x3D; 1, where first value is the program name itself.</li></ul></li><li><code>char *argv[]</code> is an array of C-style strings<ul><li><code>argv[0]</code> &#x3D; program name</li><li><code>argv[1]</code> &#x3D; first arg</li><li><code>argv[2]</code> &#x3D; second arg</li><li>…</li><li><code>argv[argc]</code> &#x3D; NULL TERMINATOR</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example: ./myprog abc 123</span></span><br><span class="line"><span class="comment">// The program name is not a command line arguments, hence argc = 3 but 2 CLA</span></span><br><span class="line"></span><br><span class="line">argv = <span class="number">0</span> [] -&gt; <span class="string">&quot;. / m y p r o g \0&quot;</span></span><br><span class="line">       <span class="number">1</span> [] -&gt; <span class="string">&quot;a b c \0&quot;</span></span><br><span class="line">       <span class="number">2</span> [] -&gt; <span class="string">&quot;1 2 3 \0&quot;</span></span><br><span class="line">       <span class="number">3</span> [] -&gt; <span class="string">&quot;\0&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Recommendation: Convert to C++ style strings before processing</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>(<span class="type">int</span> argc, <span class="type">char</span> *argv[]) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">string arg = argv[i];</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// E.g. Print the sum of all numeric args on the cmd line.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        string arg = argv[i];</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> (istringstream sock&#123;args&#125;; sock &gt;&gt; n) sum += n;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// E.g. ./myprog &lt; input.txt</span></span><br><span class="line"><span class="comment">// redirection of data -&gt; treating it as it is input from the keyboard so 0</span></span><br><span class="line"><span class="comment">// command line arguments</span></span><br><span class="line"><span class="comment">// same as running ./myprog and typing it input -&gt; 0 command line arguments as</span></span><br><span class="line"><span class="comment">// well since program name isn&#x27;t a command line argument but argc = 1</span></span><br></pre></td></tr></table></figure><h3 id="Default-Function-Parameters"><a href="#Default-Function-Parameters" class="headerlink" title="Default Function Parameters"></a>Default Function Parameters</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFile</span><span class="params">(string name = <span class="string">&quot;file.txt&quot;</span>)</span> </span>&#123;</span><br><span class="line">    ifstream f &#123;name&#125;;</span><br><span class="line">    <span class="keyword">for</span> (string s; f &gt;&gt; s;) cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printFile</span>();<span class="comment">// Print &quot;file.txt&quot;</span></span><br><span class="line">    <span class="built_in">printFile</span>(<span class="string">&quot;othername.txt&quot;</span>);<span class="comment">// Print &quot;othename.txt&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note about behavior:</p><ul><li>optional parameters must be <u>last</u></li><li><code>int f(int n = 2, int y = 3, int z = 4) &#123; &#125;</code><ul><li><code>f(0)</code> → <code>f(0, 3, 4)</code></li><li><code>f(1, 2)</code> → <code>f(1, 2, 4)</code></li><li><code>f()</code> → <code>f(2, 3, 4)</code></li></ul></li></ul><p><u>Also note</u>: the missing parameter is supplied by the <u>caller</u>, not the <u>function</u>.</p><p><u>WHY</u>: </p><ul><li><p>The caller passes params by pushing them onto the stack.</p></li><li><p>The function fetches params by reading them from the stack from where they are expected to be.</p><ul><li>If an argument is missing, the function has no ways of knowing that.</li><li><u><strong>It would interpret whatever is in that part of the stack as the <code>arg</code>.</strong></u></li></ul></li><li><p>So instead, the <u><strong>caller</strong></u> must supply the extra param if it is missing.</p></li><li><p>Therefore, when writing <code>printFile();</code></p><ul><li><p>The compiler replaces this with <code>printFile(&quot;file.txt&quot;);</code></p><ul><li>Compiler do the duty for us, Function is duty-less.</li></ul></li><li><p><code>printFile();</code> → <code>printFile(&quot;file.txt&quot;);</code> → stack frame</p><p> write code          compilerun time</p></li></ul></li><li><p>For this reason, default arguments are part of a function’s <u>interface</u>, rather than its implementation.</p></li><li><p>If you are doing <u>separate compile</u>, defaults go in the <u>interface</u> file, not the <u>implementation</u> file.</p></li></ul><h3 id="Overloading"><a href="#Overloading" class="headerlink" title="Overloading"></a>Overloading</h3><p>In C:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">negInt</span><span class="params">(<span class="type">int</span> n)</span> &#123;<span class="keyword">return</span> -n;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">negBool</span><span class="params">(<span class="type">bool</span> t)</span> &#123;<span class="keyword">return</span> !b;&#125;</span><br></pre></td></tr></table></figure><p>In C++;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">neg</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;<span class="keyword">return</span> -n;&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">neg</span><span class="params">(<span class="type">bool</span> b)</span> </span>&#123;<span class="keyword">return</span> !b;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>The idea of having same function name for different implementations is called <u><strong>OVERLOADING</strong></u>.</p></li><li><p>Simplifies the code because reusing function with different # and types of parameters inside parameter lists is legit.</p></li><li><p>The <u>compiler</u> chooses the correct version of <code>neg()</code>, for each function call, at <u>compile-time</u>.</p><ul><li>Based on the # or types of the <code>args</code> in the function call.</li></ul></li></ul><p>Hence, <u><strong>OVERLOAD</strong></u> must differ in # or types of arguments</p><ul><li>Just differing return type is not enough.<ul><li>Example (Already seen): <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>+</code><ul><li>Their behavior depends on types of arguments.</li></ul></li></ul></li></ul><h3 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h3><p>In C++;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next; <span class="comment">// No need to say struct Node *next;</span></span><br><span class="line">&#125;; <span class="comment">// Don&#x27;t forget the semicolon</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WHY?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125; n1, n2, n3; <span class="comment">// You can initialize instances of Node after declaring the Node.</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">Node next; <span class="comment">// This is wrong</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Constants"><a href="#Constants" class="headerlink" title="Constants"></a>Constants</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> passingGrade = <span class="number">50</span>; <span class="comment">// Must be initialized</span></span><br></pre></td></tr></table></figure><ul><li>Declare as many things <code>const</code> as you can, it help catches errors.</li></ul><p>Constant Node</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node n &#123;<span class="number">5</span>, <span class="literal">nullptr</span>&#125;; <span class="comment">// Syntax for null ptrs in C++</span></span><br><span class="line"><span class="comment">// Don&#x27;t say NULL or 0 in C++!</span></span><br></pre></td></tr></table></figure><p>Interesting notes:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span></span>;  <span class="comment">// Taking int</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> *p)</span></span>; <span class="comment">// Taking ptr</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>Use the null pointer to indicate nullity.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Node n2 = n; <span class="comment">// Immutable copy of n</span></span><br><span class="line">   <span class="comment">// n mutable, n2 not mutable</span></span><br></pre></td></tr></table></figure><h3 id="Parameter-Passing"><a href="#Parameter-Passing" class="headerlink" title="Parameter Passing"></a>Parameter Passing</h3><p>Recall:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pass a value</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; ++n; &#125;</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">inc</span>(x);</span><br><span class="line">cout &lt;&lt; x;</span><br><span class="line"><span class="comment">// Print 5</span></span><br><span class="line"><span class="comment">// Consequence of Pass-by-Value</span></span><br><span class="line"><span class="comment">// inc gets a copy of x, mutates the copy</span></span><br><span class="line"><span class="comment">// the original is unchanged</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A Solution would be -- As in CS136</span></span><br><span class="line"><span class="comment">// Pass a pointer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span> <span class="params">(<span class="type">int</span> *n)</span> </span>&#123;++*n;&#125;</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">inc</span>(&amp;x); <span class="comment">// x&#x27;s address, inc changes the data at that address</span></span><br><span class="line">cout &lt;&lt; x;</span><br><span class="line"><span class="comment">// Print 6</span></span><br><span class="line"><span class="comment">// Consequence of Pass-by-Reference</span></span><br><span class="line"><span class="comment">// Visible to the caller.</span></span><br></pre></td></tr></table></figure><p>Q: Why <code>cin&gt;&gt;x</code> and not <code>cin &gt;&gt; &amp;x</code>?</p><p>A: <strong>C++ has another pointer-like type - <u>references</u></strong></p><h4 id="References-Important"><a href="#References-Important" class="headerlink" title="References - Important"></a><u>References</u> - <strong>Important</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;z = y; <span class="comment">// z is an lvalue reference to y</span></span><br><span class="line"><span class="comment">// imagine z as a const ptr</span></span><br><span class="line"><span class="comment">// similar to int *const z = &amp;y</span></span><br></pre></td></tr></table></figure><p>References are like const pointers with automatic dereferencing.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z = <span class="number">12</span> (Not *z = <span class="number">12</span>) <span class="comment">// now y == 12</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = &amp;z;</span><br></pre></td></tr></table></figure><p>In all cases, z behaves <u>exactly</u> like y.z is an <u>alias</u> (another name) for y.</p><p><strong>Question</strong>: How can we tell when &amp; means “reference” vs. “address of”</p><p>[^]: Overloading, but how??</p><p><strong>Answer</strong>: Whenever &amp; occurs as part of type (e.g. <code>int &amp;z</code>), it always means <strong>references</strong>. When &amp; occurs in an expression (e.g. <code>inc(&amp;z)</code>), it means <strong>address of</strong> (or bitwise-and).</p><p>Things you can’t do with lvalue references</p><ul><li>Leave them <strong>uninitialized</strong>e.g. <code>int &amp;z</code> - Illegal<ul><li>must be initialized with something that has an address (an lvalue), since refs and ptrs.<ul><li>x &#x3D; y<ul><li>y &#x3D; right value (interested in actual value)</li><li>x &#x3D; left value (interested in its location)<ul><li>Has to denote a location (Has an address)</li></ul></li></ul></li></ul></li><li><code>int &amp;x = 3;</code> is illegal<ul><li>3 doesn’t has an address</li></ul></li><li><code>int &amp;x = y+z;</code> is illegal<ul><li>y + z doesn’t has an address</li></ul></li><li><code>int &amp;x = y</code>; legal<ul><li>y has an address (lvalue)</li></ul></li></ul></li><li>create a <strong>pointer to a reference</strong><ul><li><code>int &amp;* p;</code> illegal<ul><li>a pointer to a reference to an int</li></ul></li><li><code>int *&amp; p;</code> legal<ul><li>a reference to a pointer to an int</li></ul></li></ul></li><li>create a <strong>reference to a reference</strong><ul><li><code>int &amp;&amp; r = ...</code> illegal<ul><li>perhaps simply use a reference directly to the value</li><li>will compile!<ul><li>&amp;&amp; means something different (later)</li></ul></li></ul></li></ul></li><li>create an <strong>array of references</strong><ul><li><code>int &amp;r[] = &#123;_, _, _&#125;;</code> illegal</li></ul></li></ul><p>Things that you can do</p><ul><li>Pass as <strong>function parameters</strong><ul><li><code>void inc(int &amp;n) &#123;++n;&#125; // No pointer deref</code><ul><li>const ptr to the arg (x), changes will affect x</li><li><code>int x = 5; inc(x); count &lt;&lt; x; // 6</code></li></ul></li></ul></li></ul><p>Then why does <code>cin &gt;&gt; x</code> work?Takes x as a reference</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;<span class="keyword">operator</span> &gt;&gt; (istream &amp;in, <span class="type">int</span> &amp;x);</span><br></pre></td></tr></table></figure><p><strong>Question:</strong> Why is the stream being taken &amp; returned as a ref? And what does returning by ref mean?</p><p><strong>Answer:</strong> Need a better understanding of the cost of parameter passing.</p><p>Pass-by-value, e.g. <code>int f(int n) &#123;...&#125;</code> copies the arguments.</p><ul><li>if the arguments are big, copy is <strong>expensive</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReallyBig</span>&#123;......&#125; <span class="comment">// Very big structure</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span> <span class="params">(ReallyBig rb)</span> </span>&#123;...&#125; <span class="comment">// this is a copy - this is slow</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span> <span class="params">(ReallyBig &amp;rb)</span> </span>&#123;...&#125; <span class="comment">// this is an alias - this is fast / Could change rb in the caller</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">h</span> <span class="params">(<span class="type">const</span> ReallyBig &amp;rb)</span> </span>&#123;...&#125; <span class="comment">// alias - this is fast / Could not change rb in the caller</span></span><br></pre></td></tr></table></figure><p>If applicable, Pick reference over pointers</p><ul><li>Const - Can’t change where reference points to</li><li>References can never be null - no need to worry</li></ul><p>What if a function <u>does</u> want to make changes to <code>rb</code> locally, but does not want these changes visible to the caller? (Being fast)</p><p>Then the function must make a local copy of rb:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">k</span><span class="params">(<span class="type">const</span> ReallyBig &amp;rb)</span> </span>&#123;</span><br><span class="line">ReallyBig rb2 = rb; <span class="comment">// Copy rb to rb2, still slow isn&#x27;t it</span></span><br><span class="line">    <span class="comment">// Mutate rb2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>But if you have to make a copy anyway, it’s better to just use <u>pass-by-value</u> and have the compiler make it for you - maybe it can optimize something.</p><p><u>Advice</u>:</p><ul><li>Prefer <u>pass-by-const-ref</u> over <u>pass-by-value</u> for  anything larger than a pointer, unless the function needs to make a copy anyway - then just use <u>pass-by-value</u>.</li></ul><p><u>Also</u>: <code>int f(int &amp;n);</code><code>int g(const int &amp;n);</code></p><ul><li><code>f(5);</code> illegal, can’t initialize an lvalue ref (n) to a literal value (non-lvalue)<ul><li><u>if n changes, can’t change the literal 5.</u></li></ul></li><li><code>g(5);</code> legal, since n can never be changed ↑, the <strong>compiler allows this</strong>.<ul><li><strong><u>HOW?</u></strong> <u>important</u> - the 5 is stored in a <u>temporary</u> location (<strong>stack</strong>)<ul><li>so the ref has something to point to → towards somewhere in the stack<ul><li>example putting const makes function more applicable</li></ul></li></ul></li></ul></li></ul><p>So, in the case of</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;<span class="keyword">operator</span> &gt;&gt; (istream &amp;in, <span class="type">int</span> &amp;x);</span><br></pre></td></tr></table></figure><p>the <code>istream</code> is passed and returned by reference to save copying.</p><p><strong>IMPORTANT</strong>: because stream variable are <u>not allowed</u> to be copied.</p><h3 id="Dynamic-Memory"><a href="#Dynamic-Memory" class="headerlink" title="Dynamic Memory"></a>Dynamic Memory</h3><p>In C:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="built_in">malloc</span>(# * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">...</span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">// DON&#x27;T USE THESE IN C++!</span></span><br></pre></td></tr></table></figure><p>In C++: <u>new&#x2F;delete</u> - type-aware, less error-prone</p><ul><li>knew the memories, doesn’t have to manually allocate</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example</span></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">// Creates an int object on the heap</span></span><br><span class="line">*p = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">// Deallocates the memory of the int. pis still a &quot;dangling pointer&quot;.</span></span><br><span class="line">p = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;...&#125;;</span><br><span class="line"><span class="comment">// Create</span></span><br><span class="line">Node *np = <span class="keyword">new</span> Node; <span class="comment">// Creates a Node object on the heap. Returns a pointer to it.</span></span><br><span class="line"><span class="comment">// Delete</span></span><br><span class="line"><span class="keyword">delete</span> np; <span class="comment">// Deallocates memory. np is dangling pointer</span></span><br><span class="line">np = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;...&#125;</span><br><span class="line">Node *np = <span class="keyword">new</span> Node; <span class="comment">// keyword new, want a Node, it gets space from type defn</span></span><br><span class="line"><span class="comment">// np is stored on the stack, the node np points to is on the heap</span></span><br><span class="line"></span><br><span class="line">stackheap</span><br><span class="line">__________________________</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">_____________</span><br><span class="line">p: <span class="type">int</span>* ----------&gt; <span class="type">int</span>: <span class="number">10</span>    </span><br><span class="line"></span><br><span class="line">np: node* --------&gt; node: []</span><br><span class="line">  []</span><br><span class="line">__________________________</span><br><span class="line"></span><br><span class="line"><span class="comment">// later on we need to delete np;</span></span><br><span class="line"><span class="comment">// delete only deallocate the memories on the heap</span></span><br><span class="line"><span class="comment">// p and np remains on stack as dangling pointers</span></span><br></pre></td></tr></table></figure><p>All <u>local</u> variables and <u>function parameters</u> reside on the the stack</p><ul><li>they are deallocated automatically when they go out of the scope (<u>stack</u> is popped)<ul><li>if they are pointers, the memory they point to is <u>not</u> deallocated automatically (require manual delete).</li></ul></li><li><code>new</code> allocated memory resides on the <u>heap</u></li><li>remains allocated until delete is called<ul><li>if don’t delete all allocated memory → Memory Leak.</li></ul></li><li>Calling <u>delete</u> on the same pointer more than once is an error.<ul><li>Program will crash: SEGV</li></ul></li><li>Calling <u>delete</u> on a <code>nullptr</code> is harmless - safe and acceptable.</li><li>Never call <u>delete</u> on a stack-allocated object  → program will crash</li></ul><h3 id="Methods-of-returning-values"><a href="#Methods-of-returning-values" class="headerlink" title="Methods of returning values"></a>Methods of returning values</h3><p>Return by value:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Okay</span></span><br><span class="line"><span class="function">Node <span class="title">getmeANode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node n;-------&gt; Stack <span class="keyword">for</span> getmeANode</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">Node n1 = <span class="built_in">getmeANode</span>(); -------&gt; Stack <span class="keyword">for</span> calling function</span><br><span class="line"><span class="comment">// Copying</span></span><br></pre></td></tr></table></figure><p>Return by pointer:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BAD</span></span><br><span class="line"><span class="function">Node *<span class="title">getmeANode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node n;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> &amp;n;</span><br><span class="line">&#125;</span><br><span class="line">Node *n1 = <span class="built_in">getmeANode</span>(); <span class="comment">// BAD: We are returning a pointer to a stack-allocated data which is DEAD on return.</span></span><br></pre></td></tr></table></figure><p>Return by reference:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BAD</span></span><br><span class="line"><span class="function">Node &amp;<span class="title">getmeANode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node n;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">Node &amp;n1 = <span class="built_in">getmeANode</span>(); <span class="comment">// Also BAD, returning a reference which is an alias to a DEAD data on return.</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recall example in operator &gt;&gt;</span></span><br><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;in, <span class="type">int</span> &amp;n) &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> in; <span class="comment">// GOOD since in is outside of function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Return by Pointer (Fixed):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">getmeANode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node *np = <span class="keyword">new</span> Node; <span class="comment">// New a node onto heap</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">return</span> np; <span class="comment">// return address of np</span></span><br><span class="line">&#125;</span><br><span class="line">Node *n1 = <span class="built_in">getmeANode</span>(); <span class="comment">// n1 stores a copy of address of the node on the heap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This version transfers ownership of that allocated memory to the caller of the function (or other function). The caller is responsible for calling delete. </span></span><br></pre></td></tr></table></figure><ul><li><p>Why is it okay to return a reference here? </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;operator&gt;&gt;(istream &amp;in, int &amp;n)</span><br></pre></td></tr></table></figure><ul><li>main: <code>cin &gt;&gt; n</code></li><li>the argument istream &amp;in was already available to the caller of operator &gt;&gt; so returning a reference back to it is okay</li><li>cin and n are in main so when you return the istream, you are returning it in main, not out of scope when istream is finished</li></ul></li></ul><h3 id="Operator-Overloading"><a href="#Operator-Overloading" class="headerlink" title="Operator Overloading"></a>Operator Overloading</h3><p>Recall from earlier how the <code>&lt;&lt;</code>and <code>&gt;&gt;</code> operators were overloaded to be used for input&#x2F;output, We can actually overload any operator to have customized behavior for certain input types. Most notably, this includes user-defined types (<code>struct</code>s and <code>class</code>es).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;return_type&gt; <span class="built_in">operator</span>&lt;op&gt;(...&lt;<span class="built_in">input</span> (s)&gt;...) &#123;</span><br><span class="line">... <span class="comment">// Perform computation</span></span><br><span class="line"><span class="keyword">return</span> &lt;return_value&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let’s consider a custom structure</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line">Vec <span class="keyword">operator</span>+(<span class="type">const</span> Vec &amp;v1, <span class="type">const</span> Vec &amp;v2) &#123;</span><br><span class="line">    Vec v &#123;v1.x + v2.x, v1.y + v2.y&#125;;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line">Vec <span class="keyword">operator</span>*(<span class="type">const</span> Vec &amp;v, <span class="type">const</span> <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;v.x * k, v.y * k&#125;; <span class="comment">// Compiler knows we&#x27;re talking about Vec structure</span></span><br><span class="line">&#125;</span><br><span class="line">Vec <span class="keyword">operator</span>*(<span class="type">const</span> <span class="type">int</span> k, <span class="type">const</span> Vec &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> v * k;</span><br><span class="line">&#125; <span class="comment">// This fixes v5&#x27;s problem</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vec v1&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    Vec v2&#123;<span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    Vec v3 = v1 + v2; <span class="comment">// Uses operator + function</span></span><br><span class="line">    Vec v4 = v1 * <span class="number">10</span>; <span class="comment">// Uses the operator * function</span></span><br><span class="line">    Vec v5 = <span class="number">10</span> * v1; <span class="comment">// Does not work yet!</span></span><br><span class="line">    Vec v6 = (v1 + v2) * <span class="number">5</span>; <span class="comment">// Chaining them together</span></span><br><span class="line">    Vec v7 = v1 + v2 * <span class="number">5</span> <span class="comment">// First * then -, precedence remains after overloading.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Example:</strong> Overloading <code>&gt;&gt;</code> and <code>&lt;&lt;</code> operators</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; v1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> Vec &amp;v) &#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; v.x &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; v.y &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream *in, Vec &amp;v) &#123; <span class="comment">// Can&#x27;t be a const Vec</span></span><br><span class="line">    <span class="type">char</span> p1, c, p2;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    in &gt;&gt; p1 &gt;&gt; x &gt;&gt; c &gt;&gt; y &gt;&gt; p2;</span><br><span class="line">    <span class="comment">// Check that data is was formatted correctly</span></span><br><span class="line">    <span class="keyword">if</span> (!in.<span class="built_in">fail</span>() &amp;&amp; p1 == <span class="string">&#x27;(&#x27;</span> &amp;&amp; c == <span class="string">&#x27;,&#x27;</span> &amp;&amp; p2 == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">        v.x = x;</span><br><span class="line">        v.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vec v;</span><br><span class="line">    cin &gt;&gt; v; <span class="comment">// read in Vector v</span></span><br><span class="line">    cout &lt;&lt; v; <span class="comment">// write out Vector v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> School </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Course Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/09/CS136Notes/"/>
      <url>/2024/01/09/CS136Notes/</url>
      
        <content type="html"><![CDATA[<hr><hr><h1 id="CS-136-Course-Notes"><a href="#CS-136-Course-Notes" class="headerlink" title="CS 136 Course Notes"></a>CS 136 Course Notes</h1><h5 id="What-is-procedural-programming"><a href="#What-is-procedural-programming" class="headerlink" title="What is procedural programming?"></a>What is procedural programming?</h5><p>State machine &#x2F; Program change system state</p><h5 id="Topics-and-Themes"><a href="#Topics-and-Themes" class="headerlink" title="Topics and Themes"></a>Topics and Themes</h5><ol><li>System state &amp; Memory management</li><li>Procedural programming style</li><li>Data structures &amp; abstract data types</li><li>Algorithms design &amp; efficiency</li><li>Modularization</li><li>Medium size I&#x2F;O programs</li></ol><h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>My PVZ Development Log</title>
      <link href="/2023/12/20/2023-12-20/"/>
      <url>/2023/12/20/2023-12-20/</url>
      
        <content type="html"><![CDATA[<h3 id="Development-Log-3"><a href="#Development-Log-3" class="headerlink" title="Development Log #3"></a>Development Log #3</h3><h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><p>I just made about six pushes during the past three days. Many new features were implemented (actually they’re not “new” because they should be really familiar to those who’ve played the game before :P), but anyways, this is another log for all the updates.</p><h4 id="Bugs-encountered💀💀💀"><a href="#Bugs-encountered💀💀💀" class="headerlink" title="Bugs encountered💀💀💀"></a>Bugs encountered💀💀💀</h4><p>So far I encountered three big bugs that confused me quite some while. Thanks god I managed to fix them all. Bugs that are the easiest to fix are those where problems are merely logics. That being said the goofiest and most devastating are stupid errors like typos.</p><ul><li><pre><code>for (int i = 0; i &lt; num; i)</code></pre></li></ul><p>​Notice how in the above for loop there’s no addition to i every iteration, which means something are not going to work out</p><ul><li><p>zms[k] but k should be i. Similar to above, typo errors.</p></li><li><p>Accidentally put some code blocks into a supposedly empty loop (took me one day to notice the bug, literally carefully read through the entire code five times to find it out).</p></li></ul><h5 id="Bug-1"><a href="#Bug-1" class="headerlink" title="Bug 1"></a>Bug 1</h5><p>Zombies could not spawn.</p><p>​At first I thought it is that there’s problem rendering the zombie and I couldn’t see it on the screen. So after making sure the logic for the zombie’s movement make sense I start the game and let the “invisible” zombie walk. However once I realize after a long period of time the game wouldn’t stop automatically I know for sure things go wrong with creating the zombie. So quickly I locate the function that explicitly does this, which is called createZM().</p><p>​The problem is cause by me putting the code block that actually creating the zombie inside of an empty loop that should do nothing when zms[i].used is false. After extracting it out the bug is fixed.</p><h5 id="Bug-2"><a href="#Bug-2" class="headerlink" title="Bug 2"></a>Bug 2</h5><p>Peashooter shoot even if zombies is behind it</p><p>​This one is simply logical error. At first I didn’t consider the relative distance between each zombie and each peashooter. So the logic before the bug is fixed is that if there’s a zombie on the row, the peashooter would shoot the pea. However, since this logic failed to consider the case when peashooter is somehow planted behind the zombie, i.e. plant.x &gt; zombie.x, the peashooter should stop shooting pea. That make more sense as regular peashooter’s head is confronting toward the right direction, and there’s no way it can shoot backward (there’s a reverse shooter which shoot backward, but we’re not making it in this game).</p><p>​My resolution is by nesting another loop which traverse all possible zombies in the current zombie pool, and by analyzing the relative distance between each zombies and each plant, each peashooter can dynamically justify which zombie should it shoot and which should it not.</p><p>​Later when I look back to my resolution to this bug, I found that such an extra loop causes further bugs.</p><h5 id="Bug-3"><a href="#Bug-3" class="headerlink" title="Bug 3"></a>Bug 3</h5><p>Peashooter shooting too much at a time</p><p>​From the resolution in bug 2 I traverse all zombies to analyze the relative distance between each zombie and each peashooter. Now, one thing is that I embedded the actual function of “shooting the pea” into the innermost side of the triple loop. The problem is quickly revealed: The more zombies on a same row, the faster each peashooter shoots than it should be.</p><p>​In the original Plants-vs-Zombies, no matter how many zombies there’s in front of a peashooter, the peashooter should always shoot at a same frequency. Which means the frequency of shooting is a constant, rather than a variable.</p><p>​The reason for the bug is because during the for-k-loop which loop through each zombie in the pool, the pea-shooting function specifically ran for that zombie, so let’s say if the peashooter shoot one pea per second per zombie, if there’s two zombies standing on a same row, then since the pea-shooting function is ran twice, the peashooter would shoot two peas per second. That being said the peashooter’s shooting frequency is positively related to the amount of zombies presented ahead of that specific peashooter. The more zombies ahead, seemingly the “faster” it shoots.</p><p>​What confuses me the most is analyze and locate the problem. In fact the peashooter did not shoot faster at all. The frequency of it shooting peas are all the same. The fact that it seems like the peashooter shoots faster is because the program is ran more than one time, by which one at a time is ought to be the correct idea. Then the solution becomes much more clear, which is simply by restricting the amount of time the pea-shooting program is ran. By setting the program only allowed to run once at a time, the peashooter shoots in a normal speed again. </p><p>​What’s more, the peashooter keep shooting after the first zombie is dead, and the flying peas that are shot before the dead zombie dies kept flying and hit the next zombie and causes damage. This is because all peas are individual and does not relate to the peashooter. The only job that the pea does is to fly toward the east and causes damage to any zombie when collide. </p><h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><p>​Debugging in C++ is a painful thing. The most critical step is not fixing the bug, but instead locating the bug. Honestly speaking though one would not be able to correctly locate a bug if he&#x2F;she doesn’t understand why the bug occur. So once the bug is located, it is probable that you already understand the problem and are ready to fix it smoothly.</p><h4 id="Some-pictures-showing-latest-developed-features"><a href="#Some-pictures-showing-latest-developed-features" class="headerlink" title="Some pictures showing latest developed features"></a>Some pictures showing latest developed features</h4><h5 id="Sunshine-Balance"><a href="#Sunshine-Balance" class="headerlink" title="Sunshine Balance"></a>Sunshine Balance</h5><p><img src="https://github.com/M4cr0Chen/MyPic/blob/main/img/202312201716049.png?raw=true" alt="202312201716049.png"></p><h5 id="Sunshine-Addition"><a href="#Sunshine-Addition" class="headerlink" title="Sunshine Addition"></a>Sunshine Addition</h5><p><img src="https://github.com/M4cr0Chen/MyPic/blob/main/img/202312201717784.png?raw=true" alt="202312201717784.png"></p><h5 id="Create-Zombies"><a href="#Create-Zombies" class="headerlink" title="Create Zombies"></a>Create Zombies</h5><p><img src="https://github.com/M4cr0Chen/MyPic/blob/main/img/202312201719988.png?raw=true" alt="202312201719988.png"></p><h5 id="Peashooter-shoots-Peas"><a href="#Peashooter-shoots-Peas" class="headerlink" title="Peashooter shoots Peas"></a>Peashooter shoots Peas</h5><p><img src="https://github.com/M4cr0Chen/MyPic/blob/main/img/202312201720526.png?raw=true" alt="202312201720526.png"></p><p><img src="https://github.com/M4cr0Chen/MyPic/blob/main/img/202312201723407.png?raw=true" alt="202312201723407.png"></p><h5 id="Zombie-die"><a href="#Zombie-die" class="headerlink" title="Zombie die"></a>Zombie die</h5><p><img src="https://github.com/M4cr0Chen/MyPic/blob/main/img/202312201724270.png?raw=true" alt="202312201724270.png"></p><h5 id="Game-Over"><a href="#Game-Over" class="headerlink" title="Game Over"></a>Game Over</h5><p><img src="https://github.com/M4cr0Chen/MyPic/blob/main/img/202312201726882.png?raw=true" alt="202312201726882.png"></p>]]></content>
      
      
      <categories>
          
          <category> School </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Game Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My PVZ Development Log</title>
      <link href="/2023/12/17/2023-12-17/"/>
      <url>/2023/12/17/2023-12-17/</url>
      
        <content type="html"><![CDATA[<h2 id="My-Plants-vs-Zombies-Development-Log-2"><a href="#My-Plants-vs-Zombies-Development-Log-2" class="headerlink" title="My-Plants-vs-Zombies Development Log #2"></a>My-Plants-vs-Zombies Development Log #2</h2><p>I just finished my last final exam yesterday so hey, I finally got free time to work on this lil project :P</p><p>Just to recap, what I did in the first day are basically setting up a bunch of background images like the images for the lawn and the toolbar. The entire game interface is created so that’s a good start for me.</p><h4 id="What-I-did-afterward-are-following"><a href="#What-I-did-afterward-are-following" class="headerlink" title="What I did afterward are following:"></a>What I did afterward are following:</h4><ol><li>Implemented selection and dragging of the plants</li><li>Enabling the plants to be “planted” on the ground</li><li>Iteratively display the picture set in the res folder to create the waving animation of the plants</li><li>Created a starting menu of the game</li><li>Randomly creating Sunshine, and…</li><li>Display the random Sunshine.</li></ol><p>I defined the own structure like</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct sunshineBall &#123;</span><br><span class="line">int x, y; // Coordinates for the X and Y Coord of sunshine when falling</span><br><span class="line">int frameIndex; // Index for the current displaying picture</span><br><span class="line">int destY; // Y-Coord for the destination of the falling sunshine</span><br><span class="line">bool used; // Using or not</span><br><span class="line">int timer; //</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>which is exactly something we learned in CS135. I’m not gonna lie, struct are indeed very useful and convenient.</p><p>One of the confusing topic is the pointer variable and memories, I would’ve to read the textbook to understand what it does lol.</p><h4 id="Starting-Menu"><a href="#Starting-Menu" class="headerlink" title="Starting Menu"></a>Starting Menu</h4><p><img src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/main/img/202312171122020.png" alt="img"></p><h4 id="Selecting-and-Dragging-Plants"><a href="#Selecting-and-Dragging-Plants" class="headerlink" title="Selecting and Dragging Plants"></a>Selecting and Dragging Plants</h4><p><img src="https://github.com/M4cr0Chen/MyPic/blob/main/img/202312171125413.png?raw=true" alt="202312171125413.png"></p><h4 id="Planting-the-Plant-to-the-center-of-lawn-block"><a href="#Planting-the-Plant-to-the-center-of-lawn-block" class="headerlink" title="Planting the Plant to the center of lawn block"></a>Planting the Plant to the center of lawn block</h4><p><img src="https://github.com/M4cr0Chen/MyPic/blob/main/img/202312171126291.png?raw=true" alt="202312171126291.png"></p><h4 id="Displaying-Random-Sunshine"><a href="#Displaying-Random-Sunshine" class="headerlink" title="Displaying Random Sunshine"></a>Displaying Random Sunshine</h4><p><img src="https://github.com/M4cr0Chen/MyPic/blob/main/img/202312171127493.png?raw=true" alt="202312171127493.png"></p>]]></content>
      
      
      <categories>
          
          <category> School </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Game Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Math 135 Notes</title>
      <link href="/2023/12/14/Math135Notes/"/>
      <url>/2023/12/14/Math135Notes/</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/m135.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> School </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Course Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Math 137 Notes</title>
      <link href="/2023/12/14/Math137Notes/"/>
      <url>/2023/12/14/Math137Notes/</url>
      
        <content type="html"><![CDATA[<div class="row">    <embed src="/pdf/m137.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      <categories>
          
          <category> School </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Course Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My PVZ Development Log</title>
      <link href="/2023/12/13/2023-12-13/"/>
      <url>/2023/12/13/2023-12-13/</url>
      
        <content type="html"><![CDATA[<h3 id="My-PVZ-Development-Log-1"><a href="#My-PVZ-Development-Log-1" class="headerlink" title="My PVZ Development Log #1"></a>My PVZ Development Log #1</h3><p>The project is based on C language, mainly focusing on C++. The IDE I used is Visual Studio 2022.</p><p>This is the first day of the development, I am looking forward of reproducing a well known 2D tower defense game Plants-vs-Zombies. I am new to C so I would’ve to learn all the basics and perhaps some deeper concepts of this programming language during the development. So for me basically this project is a pretty good preview of those bunch of concepts of C in advance.</p><p>I am planning to finish the project before the start of the winter term, which is gonna be January 8th. That being said I have roughly about 25 days to work on this project solely. Hopefully I can get over any bugs and errors during the development.</p><p>Following are what I did today,</p><ol><li>Create new project (empty project template) using any version of Visual Studio</li><li>Import materials</li><li>Implement primary game scene</li><li>Implement the tool bar at the top of the game panel</li><li>Implement the plant cards in the tool bar</li></ol><p><img src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/main/img/202312132104368.png" alt="1"></p><p>Basically what I did today is to create an actual panel with size 900 * 600 (which is the default resolution of the original game) to display the content; added a background image; added a “tool bar” which held all the plants’ cards; wrote some functions that access the resource folder to get the available plant cards, and placed them on to the tool bar separated by a certain widths. Last thing I did today is to allow the program to peek message of user’s input, by far only left-click to grab up the plant, and yet not able to place the plants down. </p><p><img src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/main/img/202312132106302.png" alt="2"></p><p><img src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/main/img/202312132106995.png" alt="3"></p><p>C is honestly quite different from Racket,  the one I’ve down into for the past three months (it’s always waterloo 1A CS135), and honestly I’ve had enough of recursion. As an imperative language C works much different from functional languages like Lisp or Racket. It’s refreshing picking up concepts like for loop, while loop, if-else statements, and so on again. Even though the grammar mike seems identical between JAVA and C (and C++), I feel like they’re much different from each other as C really shows much more basic details of programming compared to JAVA.</p>]]></content>
      
      
      <categories>
          
          <category> School </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Game Development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo的个人博客网站搭建的简易教程</title>
      <link href="/2023/07/13/2023-07-13/"/>
      <url>/2023/07/13/2023-07-13/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-Github-搭建个人博客从0到1教程"><a href="#Hexo-Github-搭建个人博客从0到1教程" class="headerlink" title="Hexo + Github 搭建个人博客从0到1教程"></a><a href="https://so.csdn.net/so/search?q=Hexo&spm=1001.2101.3001.7020">Hexo</a> + Github 搭建个人博客从0到1教程</h1><h3 id="一、正式搭建博客前需要做的准备（软件安装）"><a href="#一、正式搭建博客前需要做的准备（软件安装）" class="headerlink" title="一、正式搭建博客前需要做的准备（软件安装）"></a>一、正式搭建博客前需要做的准备（软件安装）</h3><h5 id="搭建前置准备软件："><a href="#搭建前置准备软件：" class="headerlink" title="搭建前置准备软件："></a>搭建前置准备软件：</h5><p>Git：官网下载：<a href="https://git-scm.com/">https://git-scm.com/</a></p><p>Node.js 官网下载：<a href="http://nodejs.cn/">http://nodejs.cn/</a></p><h3 id="二、Hexo的安装"><a href="#二、Hexo的安装" class="headerlink" title="二、Hexo的安装"></a>二、Hexo的安装</h3><p>个人经历，国内使用npm经常出现莫名其妙报错情况（个人搭建过程中遇到不少次这样情况），于是在其他大佬的博客中学习到使用淘宝镜像源。</p><ol><li><h5 id="我们这里利用npm先安装cnpm"><a href="#我们这里利用npm先安装cnpm" class="headerlink" title="我们这里利用npm先安装cnpm"></a>我们这里利用npm先安装cnpm</h5></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>cnpm个人认为非常强大，当你遇到npm install “xxx” 出现恶心人的报错时（没错，你在搭建的过程中绝对会遇到至少几个抽象的报错，没有人能逃离 | 笑），不妨重新输入一次该死的指令，然后在指令前面加一个小巧可爱的 “ c ”。嗯，很多时候这样简单的操作就可以解决问题。</p><ol start="2"><li><h5 id="Win键输入-“Command”-或-“命令提示符”-打开cmd窗口，输入指令："><a href="#Win键输入-“Command”-或-“命令提示符”-打开cmd窗口，输入指令：" class="headerlink" title="Win键输入 “Command” 或 “命令提示符” 打开cmd窗口，输入指令："></a>Win键输入 “<strong>Command</strong>” 或 “<strong>命令提示符</strong>” 打开cmd窗口，输入指令：</h5></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><ol start="3"><li><h5 id="在本地创建一个文件夹"><a href="#在本地创建一个文件夹" class="headerlink" title="在本地创建一个文件夹"></a>在本地创建一个文件夹</h5></li></ol><p>个人起名为Blog因为好记好认。随后右键 &#x2F; 点击Git Bash （这里就是我们会最常用到的命令终端窗口了，不过之后建议用Visual Studio Code的终端，会更好用）</p><ol start="4"><li><h5 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h5></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><ol start="5"><li><h5 id="检验hexo是否能够启动成功"><a href="#检验hexo是否能够启动成功" class="headerlink" title="检验hexo是否能够启动成功"></a>检验hexo是否能够启动成功</h5></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>表示hexo成功启动</p><ol start="6"><li><h5 id="博客文件初始化成功后，来看看你的Blog文件夹里都有什么"><a href="#博客文件初始化成功后，来看看你的Blog文件夹里都有什么" class="headerlink" title="博客文件初始化成功后，来看看你的Blog文件夹里都有什么"></a>博客文件初始化成功后，来看看你的Blog文件夹里都有什么</h5><ol><li>node_modules: 依赖包 （后期魔改网站用到如pug，stylus，以及一大堆dependencies都会存放在这个网站）</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章，css文件，js文件，后期写文章就要用到这个文件夹</li><li>themes：主题（如果使用的是 git clone 则会下载到这个文件夹中，如果是 npm install 则会在上面1. node_modules 里）</li><li>_config.yml: 博客的配置文件 （这个文件很重要，是整个网页的基底，千万要保存好）</li></ol></li><li><h5 id="此时到浏览器里输入"><a href="#此时到浏览器里输入" class="headerlink" title="此时到浏览器里输入"></a>此时到浏览器里输入</h5></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:4000/</span><br></pre></td></tr></table></figure><p>即可看到你最初始化的博客网页了。</p><p>记住这个时候你的博客网页都只是本地文件，你也能看见你进入的网址为localhost，而你需要把你本地的文件部署到互联网上，别人才能通过输入域名来访问你的网站。</p><p>怎么做呢？我们使用大伙最常用的方式：部署到Github进行代码云保管。</p><h3 id="三，将Hexo部署到Github"><a href="#三，将Hexo部署到Github" class="headerlink" title="三，将Hexo部署到Github"></a>三，将Hexo部署到Github</h3><h5 id="1-Github创建个人仓库"><a href="#1-Github创建个人仓库" class="headerlink" title="1.Github创建个人仓库"></a>1.Github创建个人仓库</h5><p>首先，需要有一个github账号。登上账号后建一个仓库：仓库名为你的用户名.github.io，<br>举例如下：<br>创建一个和你用户名相同的仓库，后面加.github.io，<br>只有这样，将来要部署到GitHub的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名.</p><h5 id="2-生成ssh添加到Github"><a href="#2-生成ssh添加到Github" class="headerlink" title="2.生成ssh添加到Github"></a>2.生成ssh添加到Github</h5><h5 id="在Github上创建仓库完成之后，需要设置ssh免密登录"><a href="#在Github上创建仓库完成之后，需要设置ssh免密登录" class="headerlink" title="在Github上创建仓库完成之后，需要设置ssh免密登录"></a>在Github上创建仓库完成之后，需要设置ssh免密登录</h5><p>1.打开cmd窗口：执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure><p>这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。用户名为仓库的名称，邮箱为注册github的邮箱。</p><p>防止输错可以检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><p>2.接着进入到家目录：C:\Users\Zhenghong Chen，右击打开git bash 。</p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C 2561618861@qq.com</span><br></pre></td></tr></table></figure><p>后面是自己注册github的邮箱，然后敲三次回车，</p><p><img src="https://img-blog.csdnimg.cn/b07cadba4a484a7eac9c19884ea6f3b5.png"></p><p>3.接着就会发现C:\Users\libinbin下多了一个.ssh目录，打开后有一个公钥，一个私钥。id_rsa.pub是公钥，我们需要打开它，复制里面的内容。</p><p>然后进入github：</p><p>点击setings</p><p>进行以下操作</p><p>发现我们需要一个密钥，把我们刚刚复制的密钥粘进去，title随便起</p><p>点击 Add SSH Key</p><h5 id="3-进行部署"><a href="#3-进行部署" class="headerlink" title="3.进行部署"></a>3.进行部署</h5><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为<br>YourgithubName就是你的GitHub账户</p><p>1.修改配置文件</p><p>修改内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:goubin18/goubin18.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>注意：后面有空格</p><p>repo：获取步骤如下</p><p>点进自己刚刚创建的仓库，复制</p><p>2.找到自己的博客路径打开</p><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>2.然后依次执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo cl      #清除缓存文件 db.json 和已生成的静态文件 public</span><br><span class="line">hexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span><br><span class="line">hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><br></pre></td></tr></table></figure><p>注意deploy时会让输个yes</p><p>最后回到github上查看自己的仓库：</p><p>这就表示上传成功。</p><p>现在就可以使用xxx.github.io来访问你的博客啦<br>例如：我的用户名是M4cr0Chen，那么我的博客地址就是M4cr0Chen.github.io</p><p>————————————————<br>版权声明：本文为CSDN博主「小尘要自信」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_54796785/article/details/126053172">https://blog.csdn.net/qq_54796785/article/details/126053172</a></p>]]></content>
      
      
      <categories>
          
          <category> School </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
