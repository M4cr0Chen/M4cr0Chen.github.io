<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CS 246 Notes | MACRO'S BLOG</title><meta name="author" content="Zhenghong Chen"><meta name="copyright" content="Zhenghong Chen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="CS246 Object-Oriented Software DevOOP from three perspectives:  Programmer’s perspective - How to structure programs correctly, how to lower the risk of bugs. Compiler’s perspective - What do our cons">
<meta property="og:type" content="article">
<meta property="og:title" content="CS 246 Notes">
<meta property="og:url" content="http://example.com/2024/09/05/CS246%20Object-Oriented%20Software%20Dev/index.html">
<meta property="og:site_name" content="MACRO&#39;S BLOG">
<meta property="og:description" content="CS246 Object-Oriented Software DevOOP from three perspectives:  Programmer’s perspective - How to structure programs correctly, how to lower the risk of bugs. Compiler’s perspective - What do our cons">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://miro.medium.com/v2/resize:fit:1400/1*GRljCZx9fe_t_4vL_1imAQ.png">
<meta property="article:published_time" content="2024-09-05T04:00:00.000Z">
<meta property="article:modified_time" content="2024-12-03T22:03:51.611Z">
<meta property="article:author" content="Zhenghong Chen">
<meta property="article:tag" content="Course Notes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://miro.medium.com/v2/resize:fit:1400/1*GRljCZx9fe_t_4vL_1imAQ.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/09/05/CS246%20Object-Oriented%20Software%20Dev/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"簡","msgToSimplifiedChinese":"繁"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CS 246 Notes',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-03 17:03:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/readPercent.css"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/goodPictures/suitNtie.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> Menu</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-dangan"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw iconfont icon-kafei"></i><span> Leisure</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw iconfont icon-yinle"></i><span> Music</span></a></li><li><a class="site-page child" href="/movie/"><i class="fa-fw iconfont icon-dianying"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-charulianjie"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-geren"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://miro.medium.com/v2/resize:fit:1400/1*GRljCZx9fe_t_4vL_1imAQ.png')"><nav id="nav"><span id="blog-info"><a href="/" title="MACRO'S BLOG"><span class="site-name">MACRO'S BLOG</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-shouye"></i><span> Menu</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-dangan"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw iconfont icon-kafei"></i><span> Leisure</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw iconfont icon-yinle"></i><span> Music</span></a></li><li><a class="site-page child" href="/movie/"><i class="fa-fw iconfont icon-dianying"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-charulianjie"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-geren"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CS 246 Notes</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">Created</span><time datetime="2024-09-05T04:00:00.000Z" title="Created 2024-09-05 00:00:00">2024-09-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/School/">School</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">19.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>123min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="CS 246 Notes"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="CS246-Object-Oriented-Software-Dev"><a href="#CS246-Object-Oriented-Software-Dev" class="headerlink" title="CS246 Object-Oriented Software Dev"></a>CS246 Object-Oriented Software Dev</h1><p>OOP from three perspectives:</p>
<ol>
<li><strong>Programmer’s perspective</strong> - How to structure programs correctly, how to lower the risk of bugs.</li>
<li><strong>Compiler’s perspective</strong> - What do our constructors actually means, and what must the compiler do to support them.</li>
<li><strong>Designer’s perspective</strong> - How to use OOP tools (encapsulation, inheritance, polymorphism, etc.) to build systems.</li>
</ol>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><u>Introduction</u></h2><h4 id="Comparison-between-C-and-C"><a href="#Comparison-between-C-and-C" class="headerlink" title="Comparison between C and C++:"></a>Comparison between C and C++:</h4><p>C:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello World\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>C++:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;iostream&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ul>
<li><p>import, like <code>#include</code>, brings <u>names</u> and <u>definitions</u> from other files, libraries, or module into our code.</p>
<ul>
<li><p><code>import</code>, was C++’s new <u>module system</u>, more about modules in future lectures.</p>
</li>
<li><p><code>#include &lt;iostream&gt;</code> works. However module system is preferred in CS 246.</p>
</li>
</ul>
</li>
<li><p>function <code>main()</code> must return int, <code>void main() &#123;...&#125;</code> is not legal in C++</p>
</li>
<li><p>return statement returns a <u>status code</u> to OS</p>
<ul>
<li>can be omitted from main-default to <code>return 0;</code></li>
</ul>
</li>
<li><p><code>cout</code> and <code>&lt;&lt;</code> are how you write to stdout.</p>
<ul>
<li>this is the preferred way to do <strong>I&#x2F;O</strong> in C++</li>
<li>stdio.h and printf are still available in C++</li>
</ul>
</li>
<li><p><code>using namespace std</code></p>
<ul>
<li>called a <u>using directive</u></li>
<li>C++ organizes names into namespaces</li>
<li>without <code>using namespace std</code>, you need to write <ul>
<li><code>std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl</code></li>
</ul>
</li>
</ul>
</li>
<li><p>most C programs work in C++ (or minimal changes is required)</p>
</li>
</ul>
<h4 id="Input-x2F-Output"><a href="#Input-x2F-Output" class="headerlink" title="Input&#x2F;Output"></a><strong>Input&#x2F;Output</strong></h4><p>Basic Info</p>
<p>​	C++ comes with 3 built-in I&#x2F;O streams:</p>
<p>​		<code>cout</code> - for writing to <code>stdout</code></p>
<p>​		<code>cerr</code> - for writing to <code>stderr</code></p>
<p>​		<code>cin</code> - for reading from <code>stdin</code></p>
<p>​	Built-in Operators:</p>
<p>​		<code>&lt;&lt;</code> “put to”, insertion operator (output)</p>
<p>​		<code>&gt;&gt;</code> “get from”, extraction operator (input)</p>
<p><code>&lt;&lt;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; ____ &lt;&lt; ____ &lt;&lt; ____ &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>[^]: dates, expressions, literals<br>[^]: <code>endl</code> outputs an end of line char, and flushes the output buffer.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; X	<span class="comment">// Operator &quot;point&quot; in the direction of data flow</span></span><br><span class="line">cerr &lt;&lt; X		<span class="comment">// Never buffered</span></span><br><span class="line"> cin &gt;&gt; X	<span class="comment">// Extract a value from stdin and put it into X.</span></span><br></pre></td></tr></table></figure>

<p>Example: Read 2 ints and print their sum</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;iostream&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    cout &lt;&lt; x + y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ul>
<li>The <code>&gt;&gt;</code> operator tries to interpret the input data, according to the type of variable being read into.<ul>
<li>In this case, <strong>x</strong> is an <strong>int</strong>, so <strong>&gt;&gt;</strong> will expect to read chars that look like an int: <u>“123”</u> or <u>“-42”</u> and assemble those chars into an int <u>value</u>.</li>
</ul>
</li>
<li>it’ll stop reading when it sees a character that is not part of an integer (letter or space)</li>
<li><code>cin &gt;&gt;</code> ignores leading whitespaces (spaces, tabs, newlines)</li>
<li>when reading from the keyboard, the program will pause waiting for the user input.</li>
<li>pressing <u>Enter</u> causes the entered text to be submitted to the program</li>
<li>pressing <u>^D</u> signals end of file, or end of input</li>
</ul>
<p><u>What if bad things happen?</u></p>
<ul>
<li><p>input doesn’t contain an int</p>
</li>
<li><p>input is too large to fit in the variable</p>
</li>
<li><p>input is exhausted (not enough data) and get 2 ints</p>
</li>
</ul>
<p><u>The input operation fails, how can we test for this in our program?</u></p>
<ul>
<li><p>if read failed (for whatever reasons): <code>cin.fail()</code> will return true</p>
</li>
<li><p>if EOF: <code>cin.eof()</code> will also return true</p>
</li>
<li><p>But not until attempted read fails</p>
</li>
</ul>
<p>Example: read all int from <code>stdin</code>, echo to <code>stdout</code>, one per line, stop at EOF or bad input.</p>
<p>Example 1:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">        <span class="keyword">if</span> (cin.<span class="built_in">fail</span>()) <span class="keyword">break</span>; <span class="comment">// Check for failure</span></span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Example 2:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        cin &gt;&gt; i;</span><br><span class="line">        <span class="keyword">if</span> (!cin) <span class="keyword">break</span>; <span class="comment">// cin variable is being implicitly converted to a boolean value</span></span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cin</code> converts to:</p>
<ul>
<li><code>true</code> if all good</li>
<li><code>false</code> if the stream has had a read failure</li>
<li><code>&gt;&gt;</code> means right bit shift operator in C&#x2F;C++</li>
<li>a, b are int, a <code>&gt;&gt;</code> b a’s bits to the right for b spots.<ul>
<li>21 &#x3D; 10101</li>
<li>21 &gt;&gt; 3 &#x3D; 10<del>101</del> &#x3D; 10 &#x3D; 2</li>
</ul>
</li>
</ul>
<p><strong>Question</strong>: How do the program knows whether <code>&gt;&gt;</code> is <u>shifting bits</u> or <u>get from operator</u>?</p>
<p><strong>Answer</strong>: They depends on the provided arguments!</p>
<ul>
<li>when LHS is from <code>&lt;iostream&gt;</code> (<code>cin</code>), <code>&gt;&gt;</code> is “get from”</li>
<li>when LHS is int, <code>&gt;&gt;</code> is “shifting bits”</li>
<li>this is the very first example of function overloading:<ul>
<li>same function&#x2F;operator has multiple, different implementations &amp; meanings.<ul>
<li>the compiler choose wisely based on the provided <strong>number</strong> and <strong>type</strong> of the arguments, which are done at compile time.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>&gt;&gt;</code></p>
<p><code>cin &gt;&gt; i;</code></p>
<p>Let’s take a closer look at the <code>&gt;&gt;</code> operator:</p>
<ul>
<li>The <code>&gt;&gt;</code> operator has 2 operands:<ul>
<li><code>cin</code>, which is a stream</li>
<li><code>i</code>, a variable to receive the input data.</li>
</ul>
</li>
<li>And it returns on result:<ul>
<li><code>cin</code>, the same stream used as the first operand</li>
<li>it also has a <u>side effect</u></li>
</ul>
</li>
</ul>
<p>The fact that <u>it returns a stream (<code>cin</code>)</u>, is why we can chain a series of these together</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> cin &gt;&gt; x &gt;&gt; y &gt;&gt; z</span><br><span class="line">[cin &gt;&gt; x] -&gt; cin</span><br><span class="line">    = cin &gt;&gt; y &gt;&gt; z</span><br><span class="line">    [cin &gt;&gt; y] -&gt; cin</span><br><span class="line">    	 = cin &gt;&gt; z</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// READ Example v3:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!(cin &gt;&gt; i)) <span class="keyword">break</span>; <span class="comment">// Reading into i and checking for failure</span></span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// READ Example v4:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">while</span>(cin &gt;&gt; i) &#123; <span class="comment">// if we cannot get anymore input, then cin &gt;&gt; i is false</span></span><br><span class="line">		cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read all ints from stdin, echo them to stdout until EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// V1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		cin &gt;&gt; i;</span><br><span class="line">		<span class="keyword">if</span> (cin.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cin.<span class="built_in">fail</span>()) &#123; <span class="comment">// 1. Proper - print 2. EOF - break 3. Bad input - skip</span></span><br><span class="line">			cin.<span class="built_in">clear</span>();  <span class="comment">// Reset the stream&#x27;s failure flag, the stream will not function after failure until you do this.</span></span><br><span class="line">			cin.<span class="built_in">ignore</span>(); <span class="comment">// Removes the offending character from the stream.</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// V2</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">// 1. Proper - print 2. EOF - break 3. Bad input - skip</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cin &gt;&gt; i) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; hex &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; dec &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cin.<span class="built_in">eof</span>()) <span class="keyword">break</span>; <span class="comment">// Done - EOF</span></span><br><span class="line">        </span><br><span class="line">        cin.<span class="built_in">clear</span>();</span><br><span class="line">        cin.<span class="built_in">ignore</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ul>
<li><code>clear()</code> must come before <code>ignore()</code>, called<code>ignore()</code> on a failed stream does nothing.</li>
<li><code>ignore()</code> removes 1 char from the stream.</li>
<li><code>ignore(count)</code> removes count chars from stream</li>
<li><code>ignore(count, &#39;\n&#39;)</code> removes count chars <u>or</u> everything up to and including the newline char, whatever comes first.</li>
</ul>
<p><u>Formatted Output</u></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="number">95</span> &lt;&lt; endl; <span class="comment">// Prints &quot;95&quot;</span></span><br><span class="line">cout &lt;&lt; hex &lt;&lt; <span class="number">95</span> &lt;&lt; endl; <span class="comment">// Prints 5F (95 in hexadecimal)</span></span><br></pre></td></tr></table></figure>

<p><code>hex</code>: I&#x2F;O manipulator - puts the stream into “hex mode” all subsequent integers are printed in hex.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; dec; <span class="comment">// switches the stream back to decimal mode.</span></span><br></pre></td></tr></table></figure>



<p>Example: print a dollar amount with leading asterisks in a width of 10 characters</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> m = <span class="number">10.9</span>;</span><br><span class="line">	<span class="comment">// cout &lt;&lt; setprecision(2) &lt;&lt; 10.912345678 &lt;&lt; endl; Output: 11</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; right &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; m &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output: *****10.90</span></span><br></pre></td></tr></table></figure>

<p>Note: Use import <code>&lt;iomanip&gt;;</code></p>
<ul>
<li>Manipulators set flags in the stream. These are effectively global variables. Changes you make affect the program from that point on.</li>
<li>Changes to the stream only lives to the end of the program. i.e. Once restart the program, stream is renewed.</li>
</ul>
<hr>
<h2 id="C-Features"><a href="#C-Features" class="headerlink" title="C++ Features"></a><u>C++ Features</u></h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>C strings: An array of <code>char</code> (<code>char *</code> or <code>char[]</code>) terminated by a <code>null char</code> (\0)</p>
<ul>
<li>must explicitly manage memory - allocate more memory as strings get bigger</li>
<li>easy to overwrite the \0 at the end.</li>
<li>one of the biggest sources of security vulnerabilities</li>
</ul>
<p>C++ strings: GOOD NEWS, built-in string data type.</p>
<ul>
<li>intuitive, easy-to-use</li>
<li>string grow as needed (no need to manage memory explicitly)</li>
<li>safer to manipulate.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">string s3 = s1 + <span class="string">&quot; &quot;</span> + s2;</span><br></pre></td></tr></table></figure>

<p>Note: C++ Strings are created from C string on initialization.</p>
<p>String operations:</p>
<ul>
<li>equality&#x2F;inequality: &#x3D;&#x3D;, !&#x3D;		<code>s1 == s2</code> | <code>s1 != s2</code></li>
<li>comparisons: <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, etc. (lexicographic by default)</li>
<li>length: <code>s.length()</code>. →  O(1) time. “String structure stores each string’s length”</li>
<li>concat: <code>s3 = s1 + s2;</code> <code>s3 += s1;</code> ← s3 need to be pre-defined.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (s1 == s2) cout &lt;&lt; <span class="string">&quot;same&quot;</span> &lt;&lt; endl; <span class="comment">// comparing strings NOT memory addresses</span></span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;not same&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<ul>
<li>individual chars:<ul>
<li><code>s[0]</code> - returns first char</li>
<li><code>s[1]</code> - returns second char</li>
</ul>
</li>
<li>mutable<ul>
<li><code>s[0] = &#39;h&#39;;</code></li>
</ul>
</li>
</ul>
<p>Example: Read Strings</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s; <span class="comment">// Skip leading whitespace, start reading, then stop at consequent whitespace.</span></span><br></pre></td></tr></table></figure>

<p>What if we want the whitespace?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin, s); <span class="comment">// getline(stream, string variable name)</span></span><br><span class="line">				 <span class="comment">// Reads from current position up to next \n into s. (Excluding \n)</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line">cin.<span class="built_in">get</span>(c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(cin.<span class="built_in">get</span>(c)) &#123;</span><br><span class="line">    cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Streams are an <u>abstraction</u>. “<em>They wrap an interface of “getting &amp; putting items” around the keyboard &amp; screen.</em>“</p>
<p>Are there other kinds of “<u>things</u>“ that could support the “<u>getting and putting</u>“ interface?</p>
<hr>
<h3 id="File-Stream-x2F-1"><a href="#File-Stream-x2F-1" class="headerlink" title="File Stream&#x2F;1"></a>File Stream&#x2F;1</h3><ul>
<li>read and write a file instead of stdin&#x2F;stdout.<ul>
<li><code>std::ifstream</code> - a file stream for reading</li>
<li><code>std::ofstream</code> - a file stream for writing</li>
<li>must import <code>&lt;fstream&gt;;</code></li>
</ul>
</li>
</ul>
<p>File access in C:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *f = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="type">char</span> s[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">fscanf</span>(f, <span class="string">&quot;%255s&quot;</span>, s);</span><br><span class="line">        <span class="keyword">if</span> (feof(f)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>File access in C++:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;iostream&gt;;</span><br><span class="line"><span class="keyword">import</span> &lt;fstream&gt;;</span><br><span class="line"><span class="keyword">import</span> &lt;string&gt;; <span class="comment">// import and compile string lastly!</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    ifstream f &#123;<span class="string">&quot;file.txt&quot;</span>&#125;; <span class="comment">// Declares and initializes the istream variable f. And opens the file.</span></span><br><span class="line">    <span class="keyword">while</span> (f &gt;&gt; s) &#123;</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// File is closed automatically when the f variable goes out of scope: End of main().</span></span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ul>
<li>Anything you can do with <code>cin</code>&#x2F;<code>cout</code>, you can do with an <code>ifstream</code>&#x2F;<code>ofstream</code>.</li>
</ul>
<h3 id="String-x2F-2"><a href="#String-x2F-2" class="headerlink" title="String&#x2F;2"></a>String&#x2F;2</h3><ul>
<li><code>import &lt;string&gt;;</code></li>
<li>Extract data from chars in a string: <code>std::istringstream</code>.</li>
<li>Send data to a string as chars: <code>std::ostringstream</code>.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;sstream&gt;;</span><br><span class="line"><span class="keyword">import</span> &lt;string&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// E.g. -&gt; convert int to string</span></span><br><span class="line"><span class="function">string <span class="title">intToString</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    ostringstream sock; <span class="comment">// stream that writes to a string</span></span><br><span class="line">    sock &lt;&lt; n;</span><br><span class="line">    <span class="keyword">return</span> sock.<span class="built_in">str</span>(); <span class="comment">//extract the string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s = <span class="built_in">intToString</span>(<span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// E.g. -&gt; convert string to number</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Enter a number&quot;</span> &lt;&lt; endl;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s; <span class="comment">// Input the string</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (istringstream sock&#123;s&#125;; sock &gt;&gt; n) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I said, &quot;</span>; <span class="comment">// keep asking for new num until provided.</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You entered &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Compare the two implementations:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Earlier Version</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123; <span class="comment">// if false, then something bad happened -&gt; EOF, bad input</span></span><br><span class="line">		<span class="keyword">if</span> (! (cin &gt;&gt; i)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (cin.<span class="built_in">EOF</span>()) <span class="keyword">break</span>;</span><br><span class="line">			cin.<span class="built_in">clear</span>(); <span class="comment">// resets stream (must be cleared before another read)</span></span><br><span class="line">			cin.<span class="built_in">ignore</span>(); <span class="comment">// removes offensive character from the stream</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; endl; <span class="comment">// will be default printed as a decimal</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// E.g. -&gt; Echo all numbers, skip all non-numbers</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; s) &#123; <span class="comment">// Only fail when EOF</span></span><br><span class="line">    <span class="comment">// ignores whitespace, read until the largest input</span></span><br><span class="line">	<span class="comment">// read as a string</span></span><br><span class="line">	<span class="comment">// read until hit whitespace or EOF</span></span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> (istringstream sock&#123;s&#125;; sock &gt;&gt; n) &#123;</span><br><span class="line">		<span class="comment">// convert s into input string stream, then convert to int</span></span><br><span class="line">        <span class="comment">// local scope, every new iteration will clear off fail flags</span></span><br><span class="line">            cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// Else just continue the loop</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ex. 3.1415 is all read in cin, then we use it as an istringstream, but then </span></span><br><span class="line"><span class="comment">// we only print out 3 because the . after that isn&#x27;t an int so it stops</span></span><br><span class="line"></span><br><span class="line">abc123</span><br><span class="line">EX<span class="number">.1</span> -&gt; <span class="number">123</span>          EX<span class="number">.2</span> -&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">3.1415</span></span><br><span class="line">EX<span class="number">.1</span> -&gt;              EX<span class="number">.2</span> -&gt; <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1415</span>            </span><br><span class="line"></span><br><span class="line"><span class="number">123</span>abc</span><br><span class="line">EX<span class="number">.1</span> -&gt; <span class="number">123</span>          EX<span class="number">.2</span> -&gt; <span class="number">123</span></span><br></pre></td></tr></table></figure>

<h3 id="Command-Line-Arguments"><a href="#Command-Line-Arguments" class="headerlink" title="Command Line Arguments"></a>Command Line Arguments</h3><p>To accept command line arguments in C or C++, always give main the following parameters:</p>
<p><code>int main(int argc, char *argv[]) &#123;...&#125;</code> where:</p>
<ul>
<li><code>int argc</code> stands for # of CMD Line Args<ul>
<li><code>argc</code> &gt;&#x3D; 1, where first value is the program name itself.</li>
</ul>
</li>
<li><code>char *argv[]</code> is an array of C-style strings<ul>
<li><code>argv[0]</code> &#x3D; program name</li>
<li><code>argv[1]</code> &#x3D; first arg</li>
<li><code>argv[2]</code> &#x3D; second arg</li>
<li>…</li>
<li><code>argv[argc]</code> &#x3D; NULL TERMINATOR</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example: ./myprog abc 123</span></span><br><span class="line"><span class="comment">// The program name is not a command line arguments, hence argc = 3 but 2 CLA</span></span><br><span class="line"></span><br><span class="line">argv = <span class="number">0</span> [] -&gt; <span class="string">&quot;. / m y p r o g \0&quot;</span></span><br><span class="line">       <span class="number">1</span> [] -&gt; <span class="string">&quot;a b c \0&quot;</span></span><br><span class="line">       <span class="number">2</span> [] -&gt; <span class="string">&quot;1 2 3 \0&quot;</span></span><br><span class="line">       <span class="number">3</span> [] -&gt; <span class="string">&quot;\0&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// Recommendation: Convert to C++ style strings before processing</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>(<span class="type">int</span> argc, <span class="type">char</span> *argv[]) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">		string arg = argv[i];</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// E.g. Print the sum of all numeric args on the cmd line.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        string arg = argv[i];</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> (istringstream sock&#123;args&#125;; sock &gt;&gt; n) sum += n;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// E.g. ./myprog &lt; input.txt</span></span><br><span class="line"><span class="comment">// redirection of data -&gt; treating it as it is input from the keyboard so 0</span></span><br><span class="line"><span class="comment">// command line arguments</span></span><br><span class="line"><span class="comment">// same as running ./myprog and typing it input -&gt; 0 command line arguments as</span></span><br><span class="line"><span class="comment">// well since program name isn&#x27;t a command line argument but argc = 1</span></span><br></pre></td></tr></table></figure>



<h3 id="Default-Function-Parameters"><a href="#Default-Function-Parameters" class="headerlink" title="Default Function Parameters"></a>Default Function Parameters</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printFile</span><span class="params">(string name = <span class="string">&quot;file.txt&quot;</span>)</span> </span>&#123;</span><br><span class="line">    ifstream f &#123;name&#125;;</span><br><span class="line">    <span class="keyword">for</span> (string s; f &gt;&gt; s;) cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printFile</span>();					<span class="comment">// Print &quot;file.txt&quot;</span></span><br><span class="line">    <span class="built_in">printFile</span>(<span class="string">&quot;othername.txt&quot;</span>);		<span class="comment">// Print &quot;othename.txt&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note about behavior:</p>
<ul>
<li>optional parameters must be <u>last</u></li>
<li><code>int f(int n = 2, int y = 3, int z = 4) &#123; &#125;</code><ul>
<li><code>f(0)</code> → <code>f(0, 3, 4)</code></li>
<li><code>f(1, 2)</code> → <code>f(1, 2, 4)</code></li>
<li><code>f()</code> → <code>f(2, 3, 4)</code></li>
</ul>
</li>
</ul>
<p><u>Also note</u>: the missing parameter is supplied by the <u>caller</u>, not the <u>function</u>.</p>
<p><u>WHY</u>: </p>
<ul>
<li><p>The caller passes params by pushing them onto the stack.</p>
</li>
<li><p>The function fetches params by reading them from the stack from where they are expected to be.</p>
<ul>
<li>If an argument is missing, the function has no ways of knowing that.</li>
<li><u><strong>It would interpret whatever is in that part of the stack as the <code>arg</code>.</strong></u></li>
</ul>
</li>
<li><p>So instead, the <u><strong>caller</strong></u> must supply the extra param if it is missing.</p>
</li>
<li><p>Therefore, when writing <code>printFile();</code></p>
<ul>
<li><p>The compiler replaces this with <code>printFile(&quot;file.txt&quot;);</code></p>
<ul>
<li>Compiler do the duty for us, Function is duty-less.</li>
</ul>
</li>
<li><p><code>printFile();</code> → <code>printFile(&quot;file.txt&quot;);</code> → stack frame</p>
<p> write code          		compile				run time</p>
</li>
</ul>
</li>
<li><p>For this reason, default arguments are part of a function’s <u>interface</u>, rather than its implementation.</p>
</li>
<li><p>If you are doing <u>separate compile</u>, defaults go in the <u>interface</u> file, not the <u>implementation</u> file.</p>
</li>
</ul>
<h3 id="Overloading"><a href="#Overloading" class="headerlink" title="Overloading"></a>Overloading</h3><p>In C:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">negInt</span><span class="params">(<span class="type">int</span> n)</span> &#123;<span class="keyword">return</span> -n;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">negBool</span><span class="params">(<span class="type">bool</span> t)</span> &#123;<span class="keyword">return</span> !b;&#125;</span><br></pre></td></tr></table></figure>



<p>In C++;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">neg</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;<span class="keyword">return</span> -n;&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">neg</span><span class="params">(<span class="type">bool</span> b)</span> </span>&#123;<span class="keyword">return</span> !b;&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>The idea of having same function name for different implementations is called <u><strong>OVERLOADING</strong></u>.</p>
</li>
<li><p>Simplifies the code because reusing function with different # and types of parameters inside parameter lists is legit.</p>
</li>
<li><p>The <u>compiler</u> chooses the correct version of <code>neg()</code>, for each function call, at <u>compile-time</u>.</p>
<ul>
<li>Based on the # or types of the <code>args</code> in the function call.</li>
</ul>
</li>
</ul>
<p>Hence, <u><strong>OVERLOAD</strong></u> must differ in # or types of arguments</p>
<ul>
<li>Just differing return type is not enough.<ul>
<li>Example (Already seen): <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>+</code><ul>
<li>Their behavior depends on types of arguments.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h3><p>In C++;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next; <span class="comment">// No need to say struct Node *next;</span></span><br><span class="line">&#125;; <span class="comment">// Don&#x27;t forget the semicolon</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// WHY?</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125; n1, n2, n3; <span class="comment">// You can initialize instances of Node after declaring the Node.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	Node next; <span class="comment">// This is wrong</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h3 id="Constants"><a href="#Constants" class="headerlink" title="Constants"></a>Constants</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> passingGrade = <span class="number">50</span>; <span class="comment">// Must be initialized</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Declare as many things <code>const</code> as you can, it help catches errors.</li>
</ul>
<p>Constant Node</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node n &#123;<span class="number">5</span>, <span class="literal">nullptr</span>&#125;; <span class="comment">// Syntax for null ptrs in C++</span></span><br><span class="line"><span class="comment">// Don&#x27;t say NULL or 0 in C++!</span></span><br></pre></td></tr></table></figure>



<p>Interesting notes:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span></span>;  <span class="comment">// Taking int</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> *p)</span></span>; <span class="comment">// Taking ptr</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>Use the null pointer to indicate nullity.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Node n2 = n; <span class="comment">// Immutable copy of n</span></span><br><span class="line">				   <span class="comment">// n mutable, n2 not mutable</span></span><br></pre></td></tr></table></figure>





<h3 id="Parameter-Passing"><a href="#Parameter-Passing" class="headerlink" title="Parameter Passing"></a>Parameter Passing</h3><p>Recall:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pass a value</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; ++n; &#125;</span><br><span class="line">	...</span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">inc</span>(x);</span><br><span class="line">cout &lt;&lt; x;</span><br><span class="line"><span class="comment">// Print 5</span></span><br><span class="line"><span class="comment">// Consequence of Pass-by-Value</span></span><br><span class="line"><span class="comment">// inc gets a copy of x, mutates the copy</span></span><br><span class="line"><span class="comment">// the original is unchanged</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A Solution would be -- As in CS136</span></span><br><span class="line"><span class="comment">// Pass a pointer</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span> <span class="params">(<span class="type">int</span> *n)</span> </span>&#123;++*n;&#125;</span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">inc</span>(&amp;x); <span class="comment">// x&#x27;s address, inc changes the data at that address</span></span><br><span class="line">cout &lt;&lt; x;</span><br><span class="line"><span class="comment">// Print 6</span></span><br><span class="line"><span class="comment">// Consequence of Pass-by-Reference</span></span><br><span class="line"><span class="comment">// Visible to the caller.</span></span><br></pre></td></tr></table></figure>

<p>Q: Why <code>cin&gt;&gt;x</code> and not <code>cin &gt;&gt; &amp;x</code>?</p>
<p>A: <strong>C++ has another pointer-like type - <u>references</u></strong></p>
<h4 id="References-Important"><a href="#References-Important" class="headerlink" title="References - Important"></a><u>References</u> - <strong>Important</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;z = y; <span class="comment">// z is an lvalue reference to y</span></span><br><span class="line">			<span class="comment">// imagine z as a const ptr</span></span><br><span class="line">			<span class="comment">// similar to int *const z = &amp;y</span></span><br></pre></td></tr></table></figure>

<p>References are like const pointers with automatic dereferencing.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z = <span class="number">12</span> (Not *z = <span class="number">12</span>) <span class="comment">// now y == 12</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = &amp;z;</span><br></pre></td></tr></table></figure>

<p>In all cases, z behaves <u>exactly</u> like y.	z is an <u>alias</u> (another name) for y.</p>
<p><strong>Question</strong>: How can we tell when &amp; means “reference” vs. “address of”</p>
<p>[^]: Overloading, but how??</p>
<p><strong>Answer</strong>: Whenever &amp; occurs as part of type (e.g. <code>int &amp;z</code>), it always means <strong>references</strong>. When &amp; occurs in an expression (e.g. <code>inc(&amp;z)</code>), it means <strong>address of</strong> (or bitwise-and).</p>
<p>Things you can’t do with lvalue references</p>
<ul>
<li>Leave them <strong>uninitialized</strong>	e.g. <code>int &amp;z</code> - Illegal<ul>
<li>must be initialized with something that has an address (an lvalue), since refs and ptrs.<ul>
<li>x &#x3D; y<ul>
<li>y &#x3D; right value (interested in actual value)</li>
<li>x &#x3D; left value (interested in its location)<ul>
<li>Has to denote a location (Has an address)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>int &amp;x = 3;</code> is illegal<ul>
<li>3 doesn’t has an address</li>
</ul>
</li>
<li><code>int &amp;x = y+z;</code> is illegal<ul>
<li>y + z doesn’t has an address</li>
</ul>
</li>
<li><code>int &amp;x = y</code>; legal<ul>
<li>y has an address (lvalue)</li>
</ul>
</li>
</ul>
</li>
<li>create a <strong>pointer to a reference</strong><ul>
<li><code>int &amp;* p;</code> illegal<ul>
<li>a pointer to a reference to an int</li>
</ul>
</li>
<li><code>int *&amp; p;</code> legal<ul>
<li>a reference to a pointer to an int</li>
</ul>
</li>
</ul>
</li>
<li>create a <strong>reference to a reference</strong><ul>
<li><code>int &amp;&amp; r = ...</code> illegal<ul>
<li>perhaps simply use a reference directly to the value</li>
<li>will compile!<ul>
<li>&amp;&amp; means something different (later)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>create an <strong>array of references</strong><ul>
<li><code>int &amp;r[] = &#123;_, _, _&#125;;</code> illegal</li>
</ul>
</li>
</ul>
<p>Things that you can do</p>
<ul>
<li>Pass as <strong>function parameters</strong><ul>
<li><code>void inc(int &amp;n) &#123;++n;&#125; // No pointer deref</code><ul>
<li>const ptr to the arg (x), changes will affect x</li>
<li><code>int x = 5; inc(x); count &lt;&lt; x; // 6</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Then why does <code>cin &gt;&gt; x</code> work?	Takes x as a reference</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;<span class="keyword">operator</span> &gt;&gt; (istream &amp;in, <span class="type">int</span> &amp;x);</span><br></pre></td></tr></table></figure>



<p><strong>Question:</strong> Why is the stream being taken &amp; returned as a ref? And what does returning by ref mean?</p>
<p><strong>Answer:</strong> Need a better understanding of the cost of parameter passing.</p>
<p>Pass-by-value, e.g. <code>int f(int n) &#123;...&#125;</code> copies the arguments.</p>
<ul>
<li>if the arguments are big, copy is <strong>expensive</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ReallyBig</span>&#123;......&#125; <span class="comment">// Very big structure</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span> <span class="params">(ReallyBig rb)</span> </span>&#123;...&#125; <span class="comment">// this is a copy - this is slow</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span> <span class="params">(ReallyBig &amp;rb)</span> </span>&#123;...&#125; <span class="comment">// this is an alias - this is fast / Could change rb in the caller</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">h</span> <span class="params">(<span class="type">const</span> ReallyBig &amp;rb)</span> </span>&#123;...&#125; <span class="comment">// alias - this is fast / Could not change rb in the caller</span></span><br></pre></td></tr></table></figure>

<p>If applicable, Pick reference over pointers</p>
<ul>
<li>Const - Can’t change where reference points to</li>
<li>References can never be null - no need to worry</li>
</ul>
<p>What if a function <u>does</u> want to make changes to <code>rb</code> locally, but does not want these changes visible to the caller? (Being fast)</p>
<p>Then the function must make a local copy of rb:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">k</span><span class="params">(<span class="type">const</span> ReallyBig &amp;rb)</span> </span>&#123;</span><br><span class="line">	ReallyBig rb2 = rb; <span class="comment">// Copy rb to rb2, still slow isn&#x27;t it</span></span><br><span class="line">    <span class="comment">// Mutate rb2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>But if you have to make a copy anyway, it’s better to just use <u>pass-by-value</u> and have the compiler make it for you - maybe it can optimize something.</p>
<p><u>Advice</u>:</p>
<ul>
<li>Prefer <u>pass-by-const-ref</u> over <u>pass-by-value</u> for  anything larger than a pointer, unless the function needs to make a copy anyway - then just use <u>pass-by-value</u>.</li>
</ul>
<p><u>Also</u>: <code>int f(int &amp;n);</code>	<code>int g(const int &amp;n);</code></p>
<ul>
<li><code>f(5);</code> illegal, can’t initialize an lvalue ref (n) to a literal value (non-lvalue)<ul>
<li><u>if n changes, can’t change the literal 5.</u></li>
</ul>
</li>
<li><code>g(5);</code> legal, since n can never be changed ↑, the <strong>compiler allows this</strong>.<ul>
<li><strong><u>HOW?</u></strong> <u>important</u> - the 5 is stored in a <u>temporary</u> location (<strong>stack</strong>)<ul>
<li>so the ref has something to point to → towards somewhere in the stack<ul>
<li>example putting const makes function more applicable</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>So, in the case of</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;<span class="keyword">operator</span> &gt;&gt; (istream &amp;in, <span class="type">int</span> &amp;x);</span><br></pre></td></tr></table></figure>

<p>the <code>istream</code> is passed and returned by reference to save copying.</p>
<p><strong>IMPORTANT</strong>: because stream variable are <u>not allowed</u> to be copied.</p>
<h3 id="Dynamic-Memory"><a href="#Dynamic-Memory" class="headerlink" title="Dynamic Memory"></a>Dynamic Memory</h3><p>In C:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="built_in">malloc</span>(# * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">...</span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">// DON&#x27;T USE THESE IN C++!</span></span><br></pre></td></tr></table></figure>



<p>In C++: <u>new&#x2F;delete</u> - type-aware, less error-prone</p>
<ul>
<li>knew the memories, doesn’t have to manually allocate</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example</span></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">// Creates an int object on the heap</span></span><br><span class="line">*p = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">delete</span> p; <span class="comment">// Deallocates the memory of the int. pis still a &quot;dangling pointer&quot;.</span></span><br><span class="line">p = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;...&#125;;</span><br><span class="line"><span class="comment">// Create</span></span><br><span class="line">Node *np = <span class="keyword">new</span> Node; <span class="comment">// Creates a Node object on the heap. Returns a pointer to it.</span></span><br><span class="line"><span class="comment">// Delete</span></span><br><span class="line"><span class="keyword">delete</span> np; <span class="comment">// Deallocates memory. np is dangling pointer</span></span><br><span class="line">np = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;...&#125;</span><br><span class="line">Node *np = <span class="keyword">new</span> Node; <span class="comment">// keyword new, want a Node, it gets space from type defn</span></span><br><span class="line"><span class="comment">// np is stored on the stack, the node np points to is on the heap</span></span><br><span class="line"></span><br><span class="line">stack				heap</span><br><span class="line">_____________		_____________</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">_____________</span><br><span class="line">p: <span class="type">int</span>* ----------&gt; <span class="type">int</span>: <span class="number">10</span>    </span><br><span class="line"></span><br><span class="line">np: node* --------&gt; node: [		]</span><br><span class="line">						  [		]</span><br><span class="line">_____________		_____________</span><br><span class="line"></span><br><span class="line"><span class="comment">// later on we need to delete np;</span></span><br><span class="line"><span class="comment">// delete only deallocate the memories on the heap</span></span><br><span class="line"><span class="comment">// p and np remains on stack as dangling pointers</span></span><br></pre></td></tr></table></figure>

<p>All <u>local</u> variables and <u>function parameters</u> reside on the the stack</p>
<ul>
<li>they are deallocated automatically when they go out of the scope (<u>stack</u> is popped)<ul>
<li>if they are pointers, the memory they point to is <u>not</u> deallocated automatically (require manual delete).</li>
</ul>
</li>
<li><code>new</code> allocated memory resides on the <u>heap</u></li>
<li>remains allocated until delete is called<ul>
<li>if don’t delete all allocated memory → Memory Leak.</li>
</ul>
</li>
<li>Calling <u>delete</u> on the same pointer more than once is an error.<ul>
<li>Program will crash: SEGV</li>
</ul>
</li>
<li>Calling <u>delete</u> on a <code>nullptr</code> is harmless - safe and acceptable.</li>
<li>Never call <u>delete</u> on a stack-allocated object  → program will crash</li>
</ul>
<h3 id="Methods-of-returning-values"><a href="#Methods-of-returning-values" class="headerlink" title="Methods of returning values"></a>Methods of returning values</h3><p>Return by value:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Okay</span></span><br><span class="line"><span class="function">Node <span class="title">getmeANode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node n;				-------&gt; Stack <span class="keyword">for</span> getmeANode</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">Node n1 = <span class="built_in">getmeANode</span>(); -------&gt; Stack <span class="keyword">for</span> calling function</span><br><span class="line"><span class="comment">// Copying</span></span><br></pre></td></tr></table></figure>

<p>Return by pointer:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BAD</span></span><br><span class="line"><span class="function">Node *<span class="title">getmeANode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node n;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> &amp;n;</span><br><span class="line">&#125;</span><br><span class="line">Node *n1 = <span class="built_in">getmeANode</span>(); <span class="comment">// BAD: We are returning a pointer to a stack-allocated data which is DEAD on return.</span></span><br></pre></td></tr></table></figure>

<p>Return by reference:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BAD</span></span><br><span class="line"><span class="function">Node &amp;<span class="title">getmeANode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node n;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line">Node &amp;n1 = <span class="built_in">getmeANode</span>(); <span class="comment">// Also BAD, returning a reference which is an alias to a DEAD data on return.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recall example in operator &gt;&gt;</span></span><br><span class="line">istream &amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;in, <span class="type">int</span> &amp;n) &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">return</span> in; <span class="comment">// GOOD since in is outside of function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Return by Pointer (Fixed):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">getmeANode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node *np = <span class="keyword">new</span> Node; <span class="comment">// New a node onto heap</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">return</span> np; <span class="comment">// return address of np</span></span><br><span class="line">&#125;</span><br><span class="line">Node *n1 = <span class="built_in">getmeANode</span>(); <span class="comment">// n1 stores a copy of address of the node on the heap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This version transfers ownership of that allocated memory to the caller of the function (or other function). The caller is responsible for calling delete. </span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Why is it okay to return a reference here? </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;operator&gt;&gt;(istream &amp;in, int &amp;n)</span><br></pre></td></tr></table></figure>

<ul>
<li>main: <code>cin &gt;&gt; n</code></li>
<li>the argument istream &amp;in was already available to the caller of operator &gt;&gt; so returning a reference back to it is okay</li>
<li>cin and n are in main so when you return the istream, you are returning it in main, not out of scope when istream is finished</li>
</ul>
</li>
</ul>
<h3 id="Operator-Overloading"><a href="#Operator-Overloading" class="headerlink" title="Operator Overloading"></a>Operator Overloading</h3><p>Recall from earlier how the <code>&lt;&lt;</code>and <code>&gt;&gt;</code> operators were overloaded to be used for input&#x2F;output, We can actually overload any operator to have customized behavior for certain input types. Most notably, this includes user-defined types (<code>struct</code>s and <code>class</code>es).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;return_type&gt; <span class="built_in">operator</span>&lt;op&gt;(...&lt;<span class="built_in">input</span> (s)&gt;...) &#123;</span><br><span class="line">	... <span class="comment">// Perform computation</span></span><br><span class="line">	<span class="keyword">return</span> &lt;return_value&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Let’s consider a custom structure</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line">Vec <span class="keyword">operator</span>+(<span class="type">const</span> Vec &amp;v1, <span class="type">const</span> Vec &amp;v2) &#123;</span><br><span class="line">    Vec v &#123;v1.x + v2.x, v1.y + v2.y&#125;;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line">Vec <span class="keyword">operator</span>*(<span class="type">const</span> Vec &amp;v, <span class="type">const</span> <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;v.x * k, v.y * k&#125;; <span class="comment">// Compiler knows we&#x27;re talking about Vec structure</span></span><br><span class="line">&#125;</span><br><span class="line">Vec <span class="keyword">operator</span>*(<span class="type">const</span> <span class="type">int</span> k, <span class="type">const</span> Vec &amp;v) &#123;</span><br><span class="line">    <span class="keyword">return</span> v * k;</span><br><span class="line">&#125; <span class="comment">// This fixes v5&#x27;s problem</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vec v1&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    Vec v2&#123;<span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    Vec v3 = v1 + v2; <span class="comment">// Uses operator + function</span></span><br><span class="line">    Vec v4 = v1 * <span class="number">10</span>; <span class="comment">// Uses the operator * function</span></span><br><span class="line">    Vec v5 = <span class="number">10</span> * v1; <span class="comment">// Does not work yet!</span></span><br><span class="line">    Vec v6 = (v1 + v2) * <span class="number">5</span>; <span class="comment">// Chaining them together</span></span><br><span class="line">    Vec v7 = v1 + v2 * <span class="number">5</span> <span class="comment">// First * then -, precedence remains after overloading.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Example:</strong> Overloading <code>&gt;&gt;</code> and <code>&lt;&lt;</code> operators</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; v1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> Vec &amp;v) &#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; v.x &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; v.y &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream *in, Vec &amp;v) &#123; <span class="comment">// Can&#x27;t be a const Vec</span></span><br><span class="line">    <span class="type">char</span> p1, c, p2;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    in &gt;&gt; p1 &gt;&gt; x &gt;&gt; c &gt;&gt; y &gt;&gt; p2;</span><br><span class="line">    <span class="comment">// Check that data is was formatted correctly</span></span><br><span class="line">    <span class="keyword">if</span> (!in.<span class="built_in">fail</span>() &amp;&amp; p1 == <span class="string">&#x27;(&#x27;</span> &amp;&amp; c == <span class="string">&#x27;,&#x27;</span> &amp;&amp; p2 == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">        v.x = x;</span><br><span class="line">        v.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vec v;</span><br><span class="line">    cin &gt;&gt; v; <span class="comment">// read in Vector v</span></span><br><span class="line">    cout &lt;&lt; v; <span class="comment">// write out Vector v</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h3><p>When programming, we can split our programs into multiple modules, where each module provides both: an <strong>interface</strong> and an <strong>implementation</strong>.</p>
<ul>
<li><strong>Interface (<code>.h</code>):</strong> Declaration, Type definitions and prototypes for functions.</li>
<li><strong>Implementation (<code>.cc</code>):</strong> Full definitions for every provided function.</li>
</ul>
<p><strong>Interface File (Vec.cc):</strong> New syntax for C++20 and is NOT backward-compatible with <code>#include</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example Interface (Vec.cc)</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> Vec; <span class="comment">// This tells the compiler that this is the module interface file. We can only have one per module.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">struct</span> <span class="title class_">Vec</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> Vec <span class="keyword">operator</span>+(<span class="type">const</span> Vec &amp;v1, <span class="type">const</span> Vec&amp;v2);</span><br><span class="line"><span class="keyword">export</span> Vec <span class="keyword">operator</span>*(<span class="type">const</span> Vec &amp;v, <span class="type">const</span> <span class="type">int</span> k);</span><br></pre></td></tr></table></figure>

<p><strong>Implementation File (<code>Vec-impl.cc</code>)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Implementations</span></span><br><span class="line"><span class="keyword">module</span> Vec;</span><br><span class="line"></span><br><span class="line">Vec <span class="keyword">operator</span>+(<span class="type">const</span> Vec&amp; v1, <span class="type">const</span> Vec&amp; v2) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;v1.x + v2.x, v1.y + v2.y&#125;;</span><br><span class="line">&#125; </span><br><span class="line">Vec <span class="keyword">operator</span>*(<span class="type">const</span> Vec&amp; v, <span class="type">const</span> <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;v.x * k, v.y * k&#125;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>Client Code (<code>main.cc</code>)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Client</span></span><br><span class="line"><span class="keyword">import</span> Vec; <span class="comment">// Importing the module, no &lt;&gt; since this is user module not a system module.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Vec v1&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    Vec v2 = v1 + v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note:</p>
<ul>
<li>Interface file starts with export module (______);</li>
<li>Implementation files starts with module (______);</li>
<li>Client files use import (______);</li>
<li>These lines must be the first line</li>
</ul>
<h3 id="Separate-Compilation"><a href="#Separate-Compilation" class="headerlink" title="Separate Compilation"></a>Separate Compilation</h3><p>Speed up compilation by only compiling what’s necessary.</p>
<p>Files are compiled in dependency order:</p>
<ol>
<li>Interface files first</li>
<li>Implementation &#x2F; Client code second</li>
</ol>
<p>Separate Compilation in dependency order:</p>
<p><code>-c</code>: Produces an Object file (<code>.o</code>); Only compiling the file without linking, neither create an executable.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++<span class="number">20</span> -c Vec.cc 		<span class="comment">// Creates Vec.o</span></span><br><span class="line">g++<span class="number">20</span> -c Vec-impl.cc</span><br><span class="line">g++<span class="number">20</span> -c main.cc</span><br></pre></td></tr></table></figure>

<p>The command to link all the object files and produces an executable is:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++<span class="number">20</span> Vec.o Vec-impl.o main.o -o main</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++<span class="number">20</span> Vec-impl.o main.o -o main <span class="comment">// Omitting Vec.o is Valid, compiler knows which interface file is corresponding from gcm.cache.</span></span><br></pre></td></tr></table></figure>

<p>Now the executable file can be run as</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br></pre></td></tr></table></figure>

<p>We must compile interface files in C++ unlike in C where we only include header files (<code>.h</code>) inside the implementation files.</p>
<p>We must always compile system libraries&#x2F;modules before compiling any user-defined modules.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202409241210809.jpg" alt="Module Graph"></p>
<p><code>A -&gt; B</code> means A <u>depends on</u> B. If we were compiling, we would need to compile B <u>first</u>.</p>
<h3 id="Classes"><a href="#Classes" class="headerlink" title="Classes"></a>Classes</h3><p>Classes are the main difference between C and C++.</p>
<p>Simply speaking, a <code>class</code> is a <code>struct</code> with functions in it.</p>
<p><strong>Example:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student.cc</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">	<span class="type">int</span> assignments, midterm, <span class="keyword">final</span>;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">grade</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student-impl.cc</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Student::grade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> assignments * <span class="number">0.4</span> + midterm * <span class="number">0.2</span> + <span class="keyword">final</span> * <span class="number">0.4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student s&#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;;</span><br><span class="line">    cout &lt; s.grade &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Implementation of a class function can be either in interface file (inside the struct) or in implementation file. Writing in implementation file is recommended.</p>
<p><code>Student</code> is a class. The functions in it gives the struct <u>behavior</u>.</p>
<p><code>s</code> is an object - a particular instance of a class.</p>
<p><code>assignments</code> <code>midterm</code> and <code>final</code> are called <u>data members</u>, or <u>member fields</u> or (<u>fields</u>), or <u>member variables</u>.</p>
<p><code>::</code> - “scope resolution operator”. Locate the context. Define a function inside a class, also provide namespace.</p>
<p><code>Student::grade</code> is a “member function” or “method”. (Meaning grade in the context of class Student)</p>
<p>The fields: assignments, midterm, and final are fields of the <u>receiver object</u> - the object upon which the grade method was called.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.<span class="built_in">grade</span>(); <span class="comment">// method call | uses s1&#x27;s data members.</span></span><br></pre></td></tr></table></figure>

<p>Question: What do assignments, midterm, final mean inside of Student::grade?</p>
<ul>
<li>They are fields of the receiver object - the object upon which graded was called.</li>
<li>How do we know which data in the structure’s field corresponds to which receiver object?</li>
</ul>
<p>Formally, every <u>method</u> has a hidden extra parameter called <u><code>this</code></u>, which is a <u>pointer</u> (not a reference) to the receiver object. (It is a pointer to the object that the method was called on)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We write</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">grade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">          assignments * <span class="number">0.4</span></span><br><span class="line">        + midterm * <span class="number">0.2</span></span><br><span class="line">        + <span class="keyword">final</span> * <span class="number">0.4</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">grade</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compiler re-writes as</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">grade</span><span class="params">(Student *<span class="keyword">this</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> </span><br><span class="line">          <span class="keyword">this</span>-&gt;assignments * <span class="number">0.4</span></span><br><span class="line">        + <span class="keyword">this</span>-&gt;midterm * <span class="number">0.2</span></span><br><span class="line">        + <span class="keyword">this</span>-&gt;<span class="keyword">final</span> * <span class="number">0.4</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">grade</span>();</span><br></pre></td></tr></table></figure>

<p>Inside the function, <code>&lt;var&gt;</code> and <code>this-&gt;&lt;var&gt;</code> is the same thing, so they can be used interchangeably, when <code>&lt;var&gt;</code> is any fields inside the class&#x2F;struct.</p>
<h2 id="Big-Five"><a href="#Big-Five" class="headerlink" title="Big Five"></a><u>Big Five</u></h2><p>These are methods you may have to implement in your classes.</p>
<ol>
<li>Constructors (<code>ctor</code>)</li>
<li>Copy Constructors (<code>cctor</code>, copy <code>ctor</code>)</li>
<li>Destructors (<code>dtor</code>)</li>
<li>Copy assignment operators</li>
<li>move constructors</li>
<li>move assignment operator</li>
</ol>
<h3 id="Constructors-Initializing-Objects"><a href="#Constructors-Initializing-Objects" class="headerlink" title="Constructors (Initializing Objects)"></a>Constructors (Initializing Objects)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student s1 &#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;  <span class="comment">// Ok but limited</span></span><br><span class="line">Student s2 &#123;<span class="number">-100</span>, <span class="number">1000</span>&#125;; <span class="comment">// Valid, but doesn&#x27;t create a valid Student</span></span><br></pre></td></tr></table></figure>

<p>To control how objects are created, write a constructor (<u>ctor</u>). Constructors have no return type and have the same name as the class&#x2F;struct.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student.cc</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> assns, mt, <span class="keyword">final</span>;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">grade</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> assns, <span class="type">int</span> mt, <span class="type">int</span> <span class="keyword">final</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Student-impl.cc</span></span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="type">int</span> assns, <span class="type">int</span> mt, <span class="type">int</span> <span class="keyword">final</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span> -&gt; assns = assns;</span><br><span class="line">    <span class="keyword">this</span> -&gt; mt = mt;</span><br><span class="line">    <span class="keyword">this</span> -&gt; <span class="keyword">final</span> = <span class="keyword">final</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cc</span></span><br><span class="line">Student s &#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;; <span class="comment">// Much Better</span></span><br><span class="line">Student s = Student&#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125; <span class="comment">// Equivalent to above line</span></span><br><span class="line">Student *p = <span class="keyword">new</span> Student&#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;; <span class="comment">// Heap initialization</span></span><br></pre></td></tr></table></figure>

<p>When there is a constructor, program passes the arguments to the constructor. When there is not, then this is C-style field-by-field initialization. C-style struct initialization is only available if you have not written a constructor.</p>
<p>The major benefits of constructors is that they are functions and can thus be customized as such:</p>
<ul>
<li>Argument bounds checking</li>
<li>Default parameters</li>
<li>Overloading</li>
<li>Sanity checks</li>
</ul>
<p>Any constructor that can be called with 0 arguments is a “default constructor”. This can be either the constructor has no arguments or because it has default parameters. If we do not write any constructors, then the compiler provides the default constructor.</p>
<p>Compiler-provided default constructor:</p>
<ul>
<li>Primitive fields(<code>bool</code>, <code>int, </code>char&#96;, pointers) - left uninitialized</li>
<li>Object fields(<code>class</code>, <code>struct</code>) - calls the object’s default constructor</li>
</ul>
<p><strong>Example:</strong> Class with default constructor</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> [</span><br><span class="line">	<span class="type">int</span> assns, mt, <span class="keyword">final</span>;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> assns = <span class="number">0</span>, <span class="type">int</span> mt = <span class="number">0</span>, <span class="type">int</span> <span class="keyword">final</span> = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span> -&gt; assns = assns; <span class="keyword">this</span> -&gt; mt = mt; <span class="keyword">this</span> -&gt; <span class="keyword">final</span> = <span class="keyword">final</span>;</span><br><span class="line">    &#125;</span><br><span class="line">] </span><br><span class="line"></span><br><span class="line">Student s2&#123;<span class="number">70</span>, <span class="number">80</span>&#125;; <span class="comment">// 70, 80, 0 &quot;final&quot; is left as 0 by the ctor</span></span><br><span class="line">Student newKid; <span class="comment">// 0, 0, 0 (0-argument ctor invoked)</span></span><br><span class="line">Student newKid&#123;&#125;; <span class="comment">// Both this and above calls ctor</span></span><br></pre></td></tr></table></figure>

<p>Whenever an object is created, a constructor is always called.</p>
<p>If we do not have a default constructor for a class, that can cause issues with any classes containing classes without default constructor. Remember this is only an issue when we provide our own custom  constructor as compiler provides a default constructor by default.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec</span> &#123;</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Vec</span>(intx, <span class="type">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">this</span> -&gt; x = x;</span><br><span class="line">        <span class="keyword">this</span> -&gt; y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Vec v&#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// OK</span></span><br><span class="line">Vec vl 		 <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Basis</span> &#123;</span><br><span class="line">	Vec v1, v2; <span class="comment">// Note Vec doesn&#x27;t has a default ctor</span></span><br><span class="line">&#125;;</span><br><span class="line">Basis b;</span><br></pre></td></tr></table></figure>

<p>The built-in default <code>ctor</code> for Basis would attempt to default-construct all fields that are objects: v1 and v2 are objects. Since they have no default <code>ctor</code>, Basis cannot have a built-in default <code>ctor</code>.</p>
<p>Providing a default constructor might seem to work but it actually does not solve the issue.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Basis</span> &#123;</span><br><span class="line">    Vec v1, v2; <span class="comment">// v1 and v2 are already first constructed here</span></span><br><span class="line">    <span class="built_in">Basis</span>() &#123;</span><br><span class="line">        v1 = Vec&#123;<span class="number">1</span>, <span class="number">0</span>&#125;; <span class="comment">// Too late</span></span><br><span class="line">        v2 = Vec&#123;<span class="number">0</span>, <span class="number">1</span>&#125;; <span class="comment">// Too late</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>NOTE:</strong> Whenever we have a usable object in C++, it has been constructed at some point.</p>
<p>The body of the <code>ctor</code> can contain arbitrary code, so the <strong>fields</strong> of the class are expected to be constructed &amp; ready to use before the <code>ctor</code> body runs.</p>
<p>Steps for object creation:</p>
<ol>
<li>Enough space is allocated</li>
<li>Fields are constructed in declaration order (i.e. <code>ctor</code> run for fields that are objects)</li>
<li><code>ctor</code> body runs</li>
</ol>
<p>Initialization of v1, v2 must happen in step 2, not step 3. How to accomplish that?</p>
<p>We can fix this issue with a <strong>Member Initialization List (MIL)</strong>. The MIL provides default values to initialize the fields with in step 2 instead of using the default constructor.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student::<span class="built_in">Student</span>(<span class="type">int</span> assns, <span class="type">int</span> mt, <span class="type">int</span> <span class="keyword">final</span>):</span><br><span class="line">	assns&#123;assns&#125;, mt&#123;mt&#125;, <span class="keyword">final</span>&#123;<span class="keyword">final</span>&#125; &#123;&#125; <span class="comment">// var: fields, &#123;var&#125;: parameters</span></span><br></pre></td></tr></table></figure>

<p><strong>NOTE</strong>: We can initialize any field this way, not just object fields.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For Basis</span></span><br><span class="line">Basis::<span class="built_in">Basis</span>(): v1&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, v2&#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>More generally:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struc Basis&#123;</span><br><span class="line">	Vec v1, v2;</span><br><span class="line">	<span class="built_in">Basis</span>(<span class="type">const</span> Vec &amp;v1, <span class="type">const</span> Vec &amp;v2):</span><br><span class="line">		v1&#123;v1&#125;, v2&#123;v2&#125; &#123;&#125; <span class="comment">// Sth to think about: What ctor is running here?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NOTE:</strong> The MIL is <strong>ONLY</strong> provided in the interface file.</p>
<p>For something like the <code>Basis</code> class, we generally want 2 different constructors:</p>
<ol>
<li>Default Constructor</li>
<li>Custom Constructor (user provides all fields)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Option 1: Providing default values in the default constructor</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Basis</span>&#123;</span><br><span class="line">    Vec v1, v2;</span><br><span class="line">    <span class="built_in">Basis</span>(): v1&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, v2&#123;<span class="number">0</span>, <span class="number">1</span>&#125; &#123;&#125;</span><br><span class="line">    <span class="built_in">Basis</span>(<span class="type">const</span> vec&amp; v1, <span class="type">const</span> vec&amp; v2): v1&#123;v1&#125;, v2&#123;v2&#125; &#123;&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Option 2: Providing default values in the declaration</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Basis</span>&#123;</span><br><span class="line">    Vec v1&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, v2&#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">Basis</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Basis</span>(<span class="type">const</span> vec&amp; v1, <span class="type">const</span> vec&amp; v2): v1&#123;v1&#125;, v2&#123;v2&#125; &#123;&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>If there’s no MIL provided, then the default values provided during declaration are used. Fields are initialized <u>based on the order in which they were declared in the class</u>, even if the MIL order them differently. The order of the fields in the MIL doesn’t matter.</p>
<p>Using the MIL is sometimes more efficient than setting fields in the <code>ctor</code> body. Since for the constructor body, each object needs to be default constructed first before it’s overwritten is reset to the provided value. This causes extra memory write cycles. Hence it is recommended to use MIL whenever possible.</p>
<p>Consider:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> assns, mt, <span class="keyword">final</span>; <span class="comment">// not objects</span></span><br><span class="line">    string name; <span class="comment">// object</span></span><br><span class="line">    <span class="built_in">Student</span> (<span class="type">int</span> assns, <span class="type">int</span> mt, <span class="type">int</span> <span class="keyword">final</span>, string name) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;assns = assns;</span><br><span class="line">        ...</span><br><span class="line">		<span class="keyword">this</span>-&gt;name = name; <span class="comment">// name is default constructed to an empty string in Step 2, and reassigned here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Versus MIL:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Stuent</span> &#123;</span><br><span class="line">	<span class="built_in">Student</span> (<span class="type">int</span> assns, <span class="type">int</span> mt, <span class="type">int</span> <span class="keyword">final</span>, string name): assns&#123;assns&#125;, mt&#123;mt&#125;, <span class="keyword">final</span>&#123;<span class="keyword">final</span>&#125;, name&#123;name&#125; &#123;&#125; <span class="comment">// name is initialized to the correct value in step 2. No reassignment in step 3. More efficient.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>An MIL <strong>must</strong> be used for any fields that satisfy any of these conditions:</p>
<ol>
<li>objects with no default constructor</li>
<li>const or references</li>
</ol>
<h3 id="Copy-Constructors"><a href="#Copy-Constructors" class="headerlink" title="Copy Constructors"></a>Copy Constructors</h3><p>Consider:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> assns, mt, <span class="keyword">final</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Student s&#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;;</span><br><span class="line">Student r&#123;s&#125;;</span><br><span class="line">Student s2 = s;</span><br></pre></td></tr></table></figure>

<p>Examples shown above invoke the copy constructor that we get for free. It creates an object from another of the same type. By default, the compiler-provided constructor copies each field from the original object into the object being constructed.</p>
<p>Note: Every class comes with</p>
<ol>
<li>Constructors (default-constructs all fields that are objects)<ol>
<li>lost if you write any custom constructor</li>
</ol>
</li>
<li>Destructors (frees up memory when the object is created)</li>
<li>Copy Constructors (just copies all fields)</li>
<li>Copy assignment operators</li>
<li>move constructors</li>
<li>move assignment operator</li>
</ol>
<p><strong>Example:</strong> Copy constructor for Student class</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> assns, mt, <span class="keyword">final</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> Student &amp;other): assns&#123;other.assns&#125;, mt&#123;other.mt&#125;, <span class="keyword">final</span>&#123;other.<span class="keyword">final</span>&#125; &#123;&#125;</span><br><span class="line">    <span class="comment">// Equivalent to built-in copy constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It is important to note that adding ANY constructor (including a copy or more constructor) will remove the compiler-provided default constructor.</p>
<p>Example: When we cannot use the compiler provided copy constructor</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line">Node *n = <span class="keyword">new</span> Node &#123;<span class="number">1</span>, <span class="keyword">new</span> Node&#123;<span class="number">2</span>, <span class="keyword">new</span> Node&#123;<span class="number">3</span>, <span class="literal">nullptr</span>&#125;&#125;&#125;;</span><br><span class="line">Node m = *n;</span><br><span class="line">Node *p = <span class="keyword">new</span> Node&#123;*n&#125;;</span><br><span class="line"><span class="comment">// last two are copy ctor</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202409261507897.jpg" alt="Copy_Constructor_fig_1"></p>
<p>In this case, only the first node is actually copied. This is an example of shallow copy, where only first layer is copied over. Instead we want a deep copy, where we will end up with 3 identical but still independent lists.</p>
<p>In order to do that, we must write our own copy ctor.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">    <span class="built_in">Node</span> (<span class="type">const</span> Node &amp;other): data&#123;other.data&#125;, next&#123;other.next? <span class="keyword">new</span> Node&#123;*other.next&#125;: <span class="literal">nullptr</span>&#125; &#123;&#125;</span><br><span class="line">    <span class="comment">// Note that following is wrong</span></span><br><span class="line">    <span class="built_in">Node</span> (Node other): ... &#123;&#125;</span><br><span class="line">    <span class="comment">// Taking &#x27;other&#x27; by value implies that &#x27;other&#x27; is being copied, leading to infinite recursion.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The above example will perform a recursive deep copy, and when called on a linked list, will produce another that is identical but completely separate.</p>
<p>The copy constructor is called in the following situation:</p>
<ol>
<li>Constructing (initialized) one object from another of the same type</li>
<li>Object is passed by value</li>
<li>Object is returned by value</li>
</ol>
<p>The truth is more nuanced, as we will see.</p>
<h4 id="Explicit-x2F-Implicit-Constructors"><a href="#Explicit-x2F-Implicit-Constructors" class="headerlink" title="Explicit &#x2F; Implicit Constructors"></a>Explicit &#x2F; Implicit Constructors</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="built_in">Node</span> (<span class="type">int</span> data, Node *next=<span class="literal">nullptr</span>): data&#123;data&#125;, next&#123;next&#125; &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Single argument constructors allow implicit conversions. For example with the Node class shown above, we can construct it by just providing a single integer. Thus, the following behavior make sense:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node n&#123;<span class="number">4</span>&#125;;</span><br><span class="line">Node n = <span class="number">4</span>; <span class="comment">// Implicit conversion from int to node</span></span><br></pre></td></tr></table></figure>

<p>We have experienced this with C++ string initialization:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="comment">// A variable of type std::string is being initialized witha const char* value.</span></span><br></pre></td></tr></table></figure>

<p>This is allowed because there is a single argument constructor for std::string that tales in a const char*.</p>
<p>However, implicit conversions also allow for some unintuitive behavior:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Node n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Do something with n</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(Node&#123;<span class="number">4</span>&#125;); <span class="comment">// Make sense</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">4</span>); <span class="comment">// Doesn&#x27;t make sense but works</span></span><br></pre></td></tr></table></figure>

<p>In the example shown above, the constructor for Node is called, which takes in an int. Once a Node is constructed, it is passed to f.</p>
<p>Implicit conversions can be dangerous:</p>
<ul>
<li>Accidentally passing an int to a function expecting a Node</li>
<li>silen conversion</li>
<li>compiler does not signal an error</li>
<li>potential errors not caught</li>
</ul>
<p>In order to not letting you compiler helping you, disable the implicit conversion by prefixing the constructor with the <code>explicit</code> keyword:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">Node</span><span class="params">(<span class="type">int</span> data, Node *next=<span class="literal">nullptr</span>)</span>: data&#123;</span>data&#125;, next&#123;next&#125; &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node n&#123;<span class="number">4</span>&#125;; <span class="comment">// Works</span></span><br><span class="line">Node n = <span class="number">4</span>; <span class="comment">// Won&#x27;t compile</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Node n)</span></span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(Node&#123;<span class="number">4</span>&#125;); <span class="comment">// Works</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">4</span>); <span class="comment">// Won&#x27;t compile</span></span><br></pre></td></tr></table></figure>

<h3 id="Destructors"><a href="#Destructors" class="headerlink" title="Destructors"></a>Destructors</h3><ol>
<li>Called when a stack-allocated object is popped off the stack, or when <code>delete</code> is called on heap allocated memory.</li>
<li>A special method that runs when an object is destroyed.</li>
</ol>
<p>The default compiler-provided destructor calls the destructor on all constituent objects, and does nothing to non-objects.</p>
<p>Steps of C++ object destruction:</p>
<ol>
<li>Destructor body runs</li>
<li>Field’s destructors are invoked (destructor runs for all object fields) [In reverse declaration order]</li>
<li>space is deallocated</li>
</ol>
<p><strong>Reasons for writing custom destructors:</strong></p>
<p>Similar to with constructors, custom classes for data structures, especially those that references themselves will need a custom constructor. Let’s see why using the <code>Node</code> class as an example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Here, <code>next</code> is a <code>Node *</code> or <code>Node</code> pointer. Thus it is not an object and no destructor will run for it. When we call <code>delete</code> on a node in a linked list, only that node will be deleted, and all the subsequent nodes will remain in memory but inaccessible, causing a memory leak.</p>
<p><strong>Example:</strong> <code>Node</code> class with destructor.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    ... <span class="comment">// Fields and constructors</span></span><br><span class="line">	~<span class="built_in">Node</span>() &#123;<span class="keyword">delete</span> next;&#125; <span class="comment">// Recursively calls destructor</span></span><br><span class="line">    <span class="comment">// Name for dtor is ~&lt;name&gt;, has no args or return type</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>NOTE:</strong> The base case running <code>delete nullptr;</code> is guaranteed safe and does nothing more. Hence the recursion stops.</p>
<h3 id="Copy-Assignment-Operator"><a href="#Copy-Assignment-Operator" class="headerlink" title="Copy Assignment Operator"></a>Copy Assignment Operator</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student s1&#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;;</span><br><span class="line">Student s2 = s1; <span class="comment">// Copy ctor</span></span><br><span class="line"></span><br><span class="line">Student s3; <span class="comment">// Default ctor</span></span><br><span class="line">Student s3 = s1; <span class="comment">// Copy Assignment operator</span></span><br></pre></td></tr></table></figure>

<p>Copy assignment operator runs when we assign a value to another of the same type (that already exist). The compiler-supplied default version assigns each field of the object.</p>
<p>Similar to constructors and destructors, this may not work for many custom classes, especially those that have <u>recursive pointers</u> and&#x2F;or are <u>needed for data storage</u>.</p>
<p><strong>Example:</strong> Copy Assignment Operator for <code>Node</code> class (Version 1 - Dangerous):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    Node &amp;<span class="keyword">operator</span> = (<span class="type">const</span> Node &amp;other)&#123;</span><br><span class="line">        data = other.data;</span><br><span class="line">        <span class="keyword">delete</span> next;</span><br><span class="line">        next = other.next ? <span class="keyword">new</span> Node &#123;*other.next&#125; : <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// For chaining</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The above code works for almost all cases, but it’ll cause a runtime error when assigning a node to itself (<code>n = n</code>), known as self assignment.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Noded n&#123;<span class="number">1</span>, <span class="keyword">new</span> Node &#123;<span class="number">2</span>, <span class="keyword">new</span> Node &#123;<span class="number">3</span>, <span class="literal">nullptr</span>&#125;&#125;&#125;;</span><br><span class="line">n = n; <span class="comment">// Deletes n and tries to copy n to n - Undefined behaviour</span></span><br></pre></td></tr></table></figure>

<p>When writing <code>operator=</code>,  ALWAYS make sure it works well in the case of self-assignment:</p>
<p><strong>Example:</strong> Copy Assignment Operator for <code>Node</code> class (Version 2 - Better)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    Node &amp;<span class="keyword">operator</span>= (<span class="type">const</span> node &amp;other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        data = other.data;</span><br><span class="line">        <span class="keyword">delete</span> next;</span><br><span class="line">        next = other.next ? <span class="keyword">new</span> Node &#123;*other.next&#125; : <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// For chaining</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Question</strong>: How big of a deal is self-assignment? How likely am I to write n &#x3D; n?</p>
<p><strong>Answer</strong>: Not that likely, but considering <code>*p = *q</code> if p &amp; q point to the same location. Or <code>a[i] = a[j]</code> if i &amp; j happen to be equal (say in a loop). Because of aliasing, it is a big deal.</p>
<p>This version is better, but we can make a better implementation. Remember <code>new</code> could fail for not having enough space to allocate. Since when <code>new</code> fails, it aborts immediately instead of returning a <code>nullptr</code>. This causes <code>next</code> to be deleted but not reassigned, and then <code>next</code> will points to freed memories.</p>
<p><strong>Example:</strong> Copy Assignment Operator for <code>Node</code> class (Version 3 - Final)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Node &amp;Node::<span class="keyword">operator</span>= (<span class="type">const</span> Node &amp;other) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// Exit if self-assignment occurs</span></span><br><span class="line">    Node *tmp = next;</span><br><span class="line">    next = other.next ? <span class="keyword">new</span> Node &#123;*other.next&#125; : <span class="literal">nullptr</span>;</span><br><span class="line">    data = other.data;</span><br><span class="line">    <span class="keyword">delete</span> tmp;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;; <span class="comment">// if new fails, we still have the old list.</span></span><br></pre></td></tr></table></figure>

<p><u>Alternate</u>: copy-and-swap idiom.</p>
<h3 id="Copy-x2F-Swap-Idiom"><a href="#Copy-x2F-Swap-Idiom" class="headerlink" title="Copy&#x2F;Swap Idiom"></a>Copy&#x2F;Swap Idiom</h3><p>There’s another method to implement copy assignment.</p>
<p>A function called <code>std::swap</code> in <code>&lt;utility&gt;</code> library. Running <code>swap(a, b);</code> will swap the values of <code>a</code> and <code>b</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;utility&gt;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Node &amp;other)</span> </span>&#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(data,other.data);</span><br><span class="line">        std::<span class="built_in">swap</span>(next, other.next);</span><br><span class="line">    &#125;</span><br><span class="line">    Node &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Node &amp;other) &#123;</span><br><span class="line">        Node tmp = other; <span class="comment">// Deep copy other to tmp</span></span><br><span class="line">        swap tmp; <span class="comment">// I became tmp</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// tmp goes out of scope, dtor handle it</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Move-Constructors"><a href="#Move-Constructors" class="headerlink" title="Move Constructors"></a>Move Constructors</h3><p><u>R-values &amp; R-value references</u></p>
<p>Recall:</p>
<ul>
<li>an lvalue is anything with an address</li>
<li>an lvalue reference(&amp;) is like a <code>const ptr</code> with auto-dereference - always initialized to an lvalue.</li>
<li>they don’t bind with temporary values</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">oddsOrEvens</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node odds&#123;<span class="number">1</span>, <span class="keyword">new</span> Node&#123;<span class="number">3</span>, <span class="keyword">new</span> Node &#123;<span class="number">5</span>, <span class="literal">nullptr</span>&#125;&#125;&#125;;</span><br><span class="line">    Node evens&#123;<span class="number">2</span>, <span class="keyword">new</span> Node &#123;<span class="number">4</span>, <span class="keyword">new</span> Node &#123;<span class="number">6</span>, <span class="literal">nullptr</span>&#125;&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> evens;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> odds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node n = <span class="built_in">oddsOrEvens</span>(); <span class="comment">// Copy construction</span></span><br><span class="line"><span class="comment">// oddsOrEvens() returns by value and is the &#x27;other&#x27; as the argument of the copy ctor. But what is it referencing to?</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Compiler creates a <u>temporary object</u> to hold the result of <code>oddsOrEvens()</code></li>
<li>other is a reference to this temporary<ul>
<li>copy constructor deep-copies the data from this temporary</li>
</ul>
</li>
</ul>
<p><u>BUT</u> - the temporary is just going to be discarded anyways, as soon as the <code>struct Node n = oddsOrEvens()</code>, is done.</p>
<ul>
<li>Wasteful to have to copy the data from the temp.<ul>
<li>Why not just steal it instead? - Save the cost of copying</li>
</ul>
</li>
</ul>
<p>We need to be able to tell whether <code>other</code> is a reference to a temporary object (where stealing would work), or a standalone object (perform a deep copy).</p>
<p><code>Node &amp;&amp;</code> - rvalue reference. Can bind to temporary values. It is a reference to a temporary object (<code>rvalue</code>) of type Node.</p>
<p><strong>Example:</strong> Move constructors for the <code>Node</code> class:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">Node</span>(Node &amp;&amp;other): data&#123;other.data&#125;, next&#123;other.next&#125; &#123;</span><br><span class="line">        other.next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// Remove other&#x27;s access to the remaining nodes so the destructor</span></span><br><span class="line">        <span class="comment">// does not delete the rest of the linked list when other gets destroyed</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Nothing was copied&#x2F;changed here except for the ownership of the data.</p>
<h3 id="Move-Assignment-Operator"><a href="#Move-Assignment-Operator" class="headerlink" title="Move Assignment Operator"></a>Move Assignment Operator</h3><p>This is similar to the move constructor, except that it is used when reassigning the value of a variable that has already been initialized.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node m;</span><br><span class="line">m = <span class="built_in">oddsOrEvens</span>(); <span class="comment">// Assignment from temporary</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	 <span class="comment">// Steal other&#x27;s data | Destroy old data | Swap without copy</span></span><br><span class="line">	Node &amp;<span class="keyword">operator</span>=(Node &amp;&amp; other) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(data, other.data);</span><br><span class="line">        std::<span class="built_in">swap</span>(next, other.next);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// The temp will be destroyed &amp; take our old data with it</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>If <code>other</code> is a temporary (rvalue), the move constructor or move assignment oerator is called instead of copying resources. If you only write the copy constructor &#x2F; assignment operator, only these will be used.</p>
<h3 id="Copy-x2F-Move-Elision"><a href="#Copy-x2F-Move-Elision" class="headerlink" title="Copy&#x2F;Move Elision"></a>Copy&#x2F;Move Elision</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec <span class="title">makeAVec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;; <span class="comment">// Invoke basic Vec ctor</span></span><br><span class="line">&#125;</span><br><span class="line">Vec v = <span class="built_in">makeAVec</span>(); <span class="comment">// What runs? copy ctor? move ctor?</span></span><br></pre></td></tr></table></figure>

<p>Answer: This only uses basic constructor. There is no copy constructor nor move constructor. In certain cases, the compiler is required to skip calling copy&#x2F;move constructors.</p>
<p>Compiler writes the value directly to <code>main</code> itself and stores it inside the space occupied by v, instead of making a <code>Vec</code> in <code>makeAVec()</code> and moving it to <code>main</code>. This is called Copy&#x2F;Move Elision.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// E.g</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSomething</span><span class="params">(Vec v)</span></span>; <span class="comment">// pass-by-value, copy or move ctor</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">doSomething</span>(<span class="built_in">makeAVec</span>()); <span class="comment">// result of makeAvec written directly into the parameter</span></span><br><span class="line"><span class="comment">// There is no copy or move</span></span><br></pre></td></tr></table></figure>

<p>This happens even if dropping constructor calls would change the behavior of the program (e.g. if constructors print anything).</p>
<p>We are not expected to know exactly when elision happens, just that it is possible to happen.</p>
<h3 id="Summary-Rule-of-5-Big-5"><a href="#Summary-Rule-of-5-Big-5" class="headerlink" title="Summary: Rule of 5 (Big 5)"></a>Summary: Rule of 5 (Big 5)</h3><p>If you need to write any one of the Big 5 (destructor, copy constructor, copy assignment operator, move constructor, move assignment operator): then you should probably write them all out.</p>
<p>However, many classes wouldn’t need any of these, and try to avoid reinventing the wheels possible, and using the default implementations are fine.</p>
<p>Recall three important indicative understanding of CS246:</p>
<ol>
<li>References</li>
<li>Stack &amp; Heap</li>
<li>Ownership</li>
</ol>
<p>The Big 5 are usually necessary for classes that manages resources (i.e. memories, files).</p>
<h2 id="Features-of-Objects"><a href="#Features-of-Objects" class="headerlink" title="Features of Objects"></a><u>Features of Objects</u></h2><h3 id="Member-Operators"><a href="#Member-Operators" class="headerlink" title="Member Operators"></a>Member Operators</h3><p><u>Notice:</u> <code>operator=</code> is a member function of the class (method). Previous operators like <code>operator+()</code> have been standalone functions.</p>
<p>When an operator is declared as a member function, <code>*this</code> plays the role of the first (left) operand.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec</span>&#123;</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line">    ...</span><br><span class="line">    Vec <span class="keyword">operator</span>+(<span class="type">const</span> Vec &amp;other) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + other.x, y + other.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Vec <span class="keyword">operator</span>*(<span class="type">const</span> <span class="type">int</span> k) &#123; <span class="comment">// This only works for v * 5 and not 5 * v</span></span><br><span class="line">        <span class="keyword">return</span> &#123;x * k, y * k&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>How do we implement k * v? This can’t be a member function (method) since the first argument is not Vec, thus it must be external (standalone) function.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vec <span class="keyword">operator</span>*(<span class="type">const</span> <span class="type">int</span> k, <span class="type">const</span> Vec &amp;v) &#123;</span><br><span class="line">	<span class="keyword">return</span> v * k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>Advice</u>: If  you overload arithmetic operators, overload the assignment versions of these as well, and implement the former in terms of the latter (reuse logic from arithmetic methods):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vec &amp;<span class="keyword">operator</span> += (Vec &amp;v1, <span class="type">const</span> Vec &amp;v2) &#123;</span><br><span class="line">    v1.x += v2.x;</span><br><span class="line">    v1.y += v2.y;</span><br><span class="line">    <span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br><span class="line">Vec <span class="keyword">operator</span>+(<span class="type">const</span> Vec &amp;v1, <span class="type">const</span> Vec &amp;v2) &#123;</span><br><span class="line">    Vec tmp = v1;</span><br><span class="line">    <span class="keyword">return</span> tmpt+=v2; <span class="comment">// Reuse += to implement +</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Some operator overloads must be member functions (methods):</p>
<ul>
<li><code>operator=</code></li>
<li><code>operator[]</code></li>
<li><code>operator-&gt;</code></li>
<li><code>operator()</code></li>
<li><code>operatorT</code> (where T is a type)</li>
</ul>
<p>Some must not:</p>
<p><u>I&#x2F;O Operators:</u></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out) &#123;</span><br><span class="line">        <span class="keyword">return</span> out &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>What is wrong? This makes <code>Vec</code> become the first operand, not the second. View it as <code>v &lt;&lt; cout</code>, this is morally and semantically wrong, while compiler will actually allow this to happen.</p>
<p>So always define <code>&lt;&lt;</code>, <code>&gt;&gt;</code> as standalone functions.</p>
<h3 id="Arrays-of-Objects"><a href="#Arrays-of-Objects" class="headerlink" title="Arrays of Objects"></a>Arrays of Objects</h3><p>Let’s consider <code>Vec</code> object again:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Vec</span>(<span class="type">int</span> x, <span class="type">int</span> y): x&#123;x&#125;, y&#123;y&#125; &#123;&#125;</span><br><span class="line">    <span class="comment">// Notice this eliminates the default constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// We make an array of Vec objects</span></span><br><span class="line">Vec *vp = <span class="keyword">new</span> Vec[<span class="number">10</span>];</span><br><span class="line">Vec moreVecs[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>The above lines of codes will lead to compilation errors. This is because when creating an object in C++, it need to be initialized. When making an array of <code>Vec</code>s, they all needs to be initialized. However there is no default constructor, which leads to an error.</p>
<p><u>Options</u>:</p>
<ol>
<li><p>Provide a default constructor to the object.</p>
<ul>
<li>Not a good idea (i.e. Student class &#x2F; Empty name), unless it makes sense for the class to have a default constructor.</li>
</ul>
</li>
<li><p>For stack arrays, provide value during initialization.</p>
<ul>
<li><code>vec moreVecs[3] = &#123;&#123;0, 0&#125;, &#123;1, 1&#125;, &#123;2, 4&#125;&#125;;</code></li>
<li>This method works, but the use cases is limited</li>
</ul>
</li>
<li><p>For heap arrays, use an array of pointers to objects.</p>
<p><code>Vec **vp = new Vec*[5];</code></p>
<p><code>vp[0] = new Vec&#123;...&#125;;</code></p>
<p><code>vp[1] = new Vec&#123;...&#125;;</code> …</p>
<p>When we are done using this array, we’ll need to manually free all the memory, since they’re allocated in heap.</p>
<p><code>for (int i = 0; i &lt; 15; i++) delete vp[i];</code></p>
<p><code>delete[] vp;</code></p>
</li>
</ol>
<h3 id="Const-Objects"><a href="#Const-Objects" class="headerlink" title="Const Objects"></a>Const Objects</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Node &amp;n)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>Constant objects arise often, especially as parameters.</p>
<p>Objects can be constant. A constant object is that its fields cannot be mutated after initialization:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> student s&#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;;</span><br><span class="line">s.assns = <span class="number">100</span>; <span class="comment">// This will cause a compilation error</span></span><br></pre></td></tr></table></figure>

<p>However, we cannot run any of the object’s inbuilt functions:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> student s&#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;;</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">grade</span>() &lt;&lt; endl; <span class="comment">// This will cause a compilation error</span></span><br></pre></td></tr></table></figure>

<p><strong>Issue:</strong> The compiler does not know whether <code>s.grade()</code> will modify any of the object’s fields or not. The function call is prevented by compiler because if <code>s.grade()</code> will respect the <code>const</code>ness of <code>s</code>.</p>
<p>If it is certain <code>grade()</code> won’t modify any of the fields, we must declare its behavior to use <code>grade</code> with a <code>const</code> object.</p>
<p><strong>Example:</strong> Functions that work with <code>const</code> objects:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> assns, mt, <span class="keyword">final</span>;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">grade</span><span class="params">()</span> consts</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Implementation</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">Student::grade</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> assns * <span class="number">0.4</span> + mt * <span class="number">0.2</span> + <span class="keyword">final</span> * <span class="number">0.4</span>;</span><br><span class="line">&#125; <span class="comment">// Modifying any of the fields will cause a compilation error</span></span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong> The <code>const</code> suffix must appear in both interface and implementation files. Only <code>const</code> methods can be called on <code>const</code> objects. Compiler checks that <code>const</code> methods do not actually modify any fields.</p>
<p>With the above code, we can run the <code>grade()</code> on a <code>const</code> object:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> student s&#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;;</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">grade</span>() &lt;&lt; endl; <span class="comment">// This will work now since grade is a const method</span></span><br></pre></td></tr></table></figure>

<p><code>const</code> objects may only have <code>const</code> methods called on them. Non-<code>const</code> objects may have either <code>const</code> or non-<code>const</code> methods called on them.</p>
<p>Now what if we want to collect usage statistics on Student objects?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> assns, mt, <span class="keyword">final</span>;</span><br><span class="line">    <span class="type">int</span> calls = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">grade</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        ++calls;</span><br><span class="line">        <span class="keyword">return</span> assns * <span class="number">0.4</span> + mt * <span class="number">0.2</span> + <span class="keyword">final</span> * <span class="number">0.4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This would not work because the function increments <code>calls</code>.</p>
<p><strong>Issue:</strong> Difference between physical vs logical <code>const</code>ness:</p>
<ul>
<li>Physical: Whether or not the <u>actual bits</u> that make up the object have changed.</li>
<li>Logical: Whether or not the updated objects should logically be regarded as different after the update.</li>
</ul>
<p>We can make an exception to what the compiler checks be declaring a field to be <code>mutable</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">	<span class="type">int</span> assns, mt, finals;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="type">int</span> calls; <span class="comment">// Can be changed in const methods (for both const and non-const objects)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Static-fields-and-methods"><a href="#Static-fields-and-methods" class="headerlink" title="Static fields and methods"></a>Static fields and methods</h3><p>What if I want to record the number of calls for ALL <code>Student</code> objects, and not just one. Or keep track of number of <code>Student</code>s created?</p>
<p>We use <code>static</code> fields (associated with the class itself, not any specific instance (object)):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> assns, mt, <span class="keyword">final</span>;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">int</span> numInstances = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> assns, <span class="type">int</span> mt, <span class="type">int</span> <span class="keyword">final</span>): assns&#123;assns&#125;, mt&#123;mt&#125;, <span class="keyword">final</span>&#123;<span class="keyword">final</span>&#125; &#123;</span><br><span class="line">        numInstances++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student s&#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;;</span><br><span class="line">Student r&#123;<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>&#125;;</span><br><span class="line">cout &lt;&lt; Student::numInstances &lt;&lt; endl; <span class="comment">// Will print out 2</span></span><br><span class="line"><span class="comment">// s.numInstances also works, but is not recommended</span></span><br></pre></td></tr></table></figure>

<p>Any <code>static</code> fields are defined for the object rather than for each instance, and the value is shared across all instances of the object. The <code>inline</code> keyword is used to allow static fields to be initialized directly in the interface rather than in the implementation file.</p>
<p>Static methods, just like <code>static</code> fields, are defined for the class rather than for any one particular object. Static methods can only access static fields. No need for <code>this</code>. Don’t depend on the specific instance.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">howMany</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; numInstances &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Student s1 &#123;<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>&#125;, s2&#123;<span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>&#125;; <span class="comment">// numInstances == 2</span></span><br><span class="line">Student::<span class="built_in">howMany</span>(); <span class="comment">// outputs 2</span></span><br></pre></td></tr></table></figure>

<p>In order to call this function we call <code>Student::howMany();</code>, calling <code>s.howMany()</code> won’t work.</p>
<h3 id="Three-Way-Comparison"><a href="#Three-Way-Comparison" class="headerlink" title="Three-Way Comparison"></a>Three-Way Comparison</h3><p>Let’s go back to C and see how string comparison works: <code>strcmp(s1, s2)</code>:</p>
<p>Return:</p>
<ul>
<li>negative if <code>s1 &lt; s2</code></li>
<li>zero if <code>s1 == s2</code></li>
<li>positive if <code>s1 &gt; s2</code></li>
</ul>
<p>In order to compare 2 strings, we would do the following:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IN C</span></span><br><span class="line"><span class="type">int</span> n = <span class="built_in">strcmp</span>&#123;s1, s2&#125;;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IN C++</span></span><br><span class="line"><span class="keyword">if</span> (s1 &lt; s2) &#123; ... &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s1 == s2) &#123; ... &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>C++ version is easier to read. However, notice that in C, there’s only one string comparison (running <code>strcmp</code> once). In C++, there are 2 string comparisons being done. This causes an unnecessary waste of resources.</p>
<p>As of C+&#x3D;20, there’s a efficient way:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3-way comparison operator: (Spaceship operator)</span></span><br><span class="line">s1 &lt;=&gt; s2;</span><br></pre></td></tr></table></figure>

<p>Using the 3-way comparison operator is identical to using <code>strcmp</code> in C. Note that in order to use it we need to import the <code>&lt;compare&gt;</code> library.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;compare&gt;;</span><br><span class="line"></span><br><span class="line">std::strong_ordering n = (s1 &lt;=&gt; s2);</span><br><span class="line"><span class="comment">// std::strong_ordering is the return type of &lt;=&gt;</span></span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123; ... &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><code>std::strong_ordering</code> is a lot to type. Instead, we can use automatic type deduction:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> n = (s1 &lt;=&gt; s2);</span><br><span class="line"><span class="comment">// n&#x27;s type is the return type of the expression on the RHS</span></span><br></pre></td></tr></table></figure>

<p>We may also overload the spaceship operator for our own data types. If we define <code>&lt;=&gt;</code> for a type, we also automatically get all the other comparison operators automatically:</p>
<ul>
<li>v1 &#x3D;&#x3D; v2</li>
<li>v1 !&#x3D; v2</li>
<li>v1 &lt;&#x3D; v2</li>
<li>v1 &gt;&#x3D; v2</li>
<li>v1 &lt; v2</li>
<li>v1 &gt; v2</li>
</ul>
<p>Even after we define the spaceship operator, we can overload <code>operator==</code> again, since it’s sometimes possible to check equality much more efficiently than comparison.</p>
<p><strong>Example:</strong> Operator overloading the spaceship operator:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> vec&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> n = x &lt;=&gt; other.x;</span><br><span class="line">        <span class="keyword">return</span> (n == <span class="number">0</span>) ? (y &lt;=&gt; other.y) : n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Here, we are simply comparing the fields in declaration order. If that is the case, we can use the default version of <code>operator&lt;=&gt;</code>. This is not provided by default and we need to specify that we are using default behavior.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Vec &amp;other) <span class="type">const</span> == <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// This does lexicographic comparison on the fields of Vec - equivalent to what we wrote before</span></span><br></pre></td></tr></table></figure>

<p><strong>Node:</strong> <code>= default</code> also works for all constructors, destructors, and operators that the compiler provides by default.</p>
<p>Consider a case where <code>= default</code> is not appropriate for <code>&lt;=&gt;</code>.</p>
<p><strong>Example:</strong> Linked lists</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Node &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> n = (data &lt;=&gt; other.data);</span><br><span class="line">        <span class="keyword">if</span> ((n != <span class="number">0</span>) || (!next &amp;&amp; !other.next)) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">if</span> (!next &amp;&amp; other.next) <span class="keyword">return</span> std::strong_ordering::less;</span><br><span class="line">        <span class="keyword">if</span> (next ** !other.next) <span class="keyword">return</span> std::strong_ordering::greater;</span><br><span class="line">        <span class="keyword">return</span> *next &lt;=&gt; *other.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Note: Assumes non-empty lists</span></span><br><span class="line"><span class="comment">// Empty list is nullptr, and this method doesn&#x27;t applies to it, so no worries :)</span></span><br></pre></td></tr></table></figure>



<h3 id="Encapsulation"><a href="#Encapsulation" class="headerlink" title="Encapsulation"></a>Encapsulation</h3><p>Consider our linked list example again:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">    ...</span><br><span class="line">	~<span class="built_in">Node</span>() &#123;<span class="keyword">delete</span> next&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node n1&#123;<span class="number">1</span>, <span class="keyword">new</span> Node&#123;<span class="number">2</span>, <span class="literal">nullptr</span>&#125;&#125;;</span><br><span class="line">Node n2&#123;<span class="number">3</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">Node n3&#123;n1, &amp;n2&#125;;</span><br></pre></td></tr></table></figure>

<p>When this program finished running, the following happens:</p>
<ul>
<li>n1 - <code>dtor</code> runs, entire list that are on heap is deleted.</li>
<li>n3 - <code>dtor</code> tries to delete n2, but fails because it tries to free <code>n2,</code> which is stack allocated.</li>
</ul>
<p>Even if we did these with variables that were all heap-allocated, we would end up with double-free errors on n1.</p>
<p>Class node relies on an assumption for its proper operation: that next is either nullptr or was allocated by new.</p>
<p>These are <u>invariants</u> - properties of a data structure that must hold true - upon which Node relies.</p>
<p>But we, can’t guarantee this invariant - can’t trust user to use Node properly. Because users can easily violate these invariants.</p>
<ul>
<li>But not if the client can rearrange the underlying data.</li>
</ul>
<p><strong>Encapsulation</strong> provides a solution to users violating invariants.</p>
<p>Users should treat our objects as “capsules” or “black boxes”, where users have no access to the underlying data, but rather interact with the objects by calling methods.</p>
<p>This is where <u>access specifiers</u> are useful. There are 2 different types:</p>
<ul>
<li><code>public</code> fields &#x2F; methods: can be accessed everywhere.</li>
<li><code>private</code> fields &#x2F; methods: can be accessed &#x2F; called within class methods.</li>
</ul>
<p><strong>Example:</strong> <code>Vec</code> struct using access specifiers</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec</span>&#123;</span><br><span class="line">    <span class="built_in">Vec</span>(<span class="type">int</span> x, <span class="type">int</span> y); <span class="comment">// Public</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="type">int</span> x, y; <span class="comment">// Private</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	Vec <span class="keyword">operator</span>+(<span class="type">const</span> Vec &amp;other); <span class="comment">// Public</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It is preferred to keep fields <code>private</code> by default, only <code>method</code> should be public.</p>
<p><code>Class</code> has default visibility of fields &#x2F; methods <code>private</code>, <code>Struct</code> has default visibility of fields &#x2F; methods <code>public</code>.</p>
<p>Note that this is the only difference between <code>class</code> and <code>struct</code>.</p>
<p><strong>Example:</strong> <code>Vec</code> object implemented as a class</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">vec</span> &#123; </span><br><span class="line">    <span class="type">int</span> x, y; <span class="comment">// Private by default, can not be called outside vec methods </span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">vec</span>(<span class="type">int</span> x, <span class="type">int</span> y);</span><br><span class="line">    	vec <span class="keyword">operator</span>+(<span class="type">const</span> vec&amp; other) <span class="type">const</span>; </span><br><span class="line">&#125;; <span class="comment">// Semicolon at the end, like with structs</span></span><br></pre></td></tr></table></figure>

<p><strong>Example:</strong> Revisit our linked list - add encapsulation, protect invariants:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List.cc</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> list;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>; <span class="comment">// private nested class, accessible only within List</span></span><br><span class="line">    Node *head = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">addToFront</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line">    	<span class="function"><span class="type">int</span> &amp;<span class="title">ith</span><span class="params">(<span class="type">int</span> i)</span></span>; <span class="comment">// reference type, since we might want to mutate the element</span></span><br><span class="line">    	~<span class="built_in">List</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List-impl.cc</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List</span>::Node &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">    ~Node &#123; <span class="keyword">delete</span> next; &#125;</span><br><span class="line">    <span class="comment">// ... Rest of big 5, if needed</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">List::addToFront</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    head = <span class="keyword">new</span> Node&#123;n, head&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> &amp;<span class="title">List::ith</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    Node *cur = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List::~<span class="built_in">List</span>() &#123; <span class="keyword">delete</span> head; &#125;</span><br></pre></td></tr></table></figure>

<p>Only <code>List</code> can create &#x2F; manipulate Node objects.</p>
<p>Thus we can guarantee the invariant that next is always either <code>nullptr</code> or allocated by new.</p>
<p>Encapsulation gives us a lot of benefits, but let’s talk about something not so good.</p>
<p><strong>Issue:</strong> Printing a list take O(n^2) time. <code>List::ith()</code> cost O(i) time, calling <code>List::ith()</code> repetitively will eventually ends up with O(n^2) time.</p>
<p>How can we have faster iteration while maintaining encapsulation?</p>
<h3 id="Iterator-Pattern"><a href="#Iterator-Pattern" class="headerlink" title="Iterator Pattern"></a>Iterator Pattern</h3><p>We can’t traverse the list from node to node as would in a linked list. We can’t expose the nodes, or we lose encapsulation.</p>
<h4 id="SE-Topic-Design-Patterns"><a href="#SE-Topic-Design-Patterns" class="headerlink" title="SE Topic: Design Patterns"></a>SE Topic: Design Patterns</h4><ul>
<li>Certain programming challenges arise often</li>
<li>Keep track of good solutions to these problems - reuse &amp; adapt them</li>
</ul>
<p><u>Iterator Pattern:</u> </p>
<p>By creating an <u>iterator</u> class, which is an abstraction of a pointer. We keep track of how far we have reached, and allow the user to access data but not modify anything.</p>
<p>Recall from CS136:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> *p = arr; p != arr+size; ++p) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Example:</strong> <code>List</code> data structure with Iterator pattern.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>;</span><br><span class="line">    Node *head;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">            Node *cur;</span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">            	<span class="built_in">Iterator</span>(Node *cur): cur&#123;cur&#125; &#123;&#125;</span><br><span class="line">            	Iterator &amp;<span class="keyword">operator</span>++() &#123; <span class="comment">// if &amp;operator++(int), post-fix ++</span></span><br><span class="line">                    cur = cur-&gt;next;</span><br><span class="line">                    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            	<span class="type">int</span> &amp;<span class="keyword">operator</span>*() &#123;</span><br><span class="line">                    <span class="keyword">return</span> cur-&gt;data;</span><br><span class="line">                &#125;</span><br><span class="line">            	<span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> cur != other.cur;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;; <span class="comment">// End iterator</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// List class</span></span><br><span class="line">    	<span class="function">Iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Iterator&#123;head&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="function">Iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Iterator&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">            <span class="comment">// If in array, replace nullptr with array&#x27;s front address + size</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// Add addToFront, ith, Big 5</span></span><br><span class="line">&#125;; <span class="comment">// End List class</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List l = <span class="built_in">addToFront</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (List::Iterator it = l.<span class="built_in">begin</span>(); it != l.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="comment">// This loop runs in O(n) time.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If you have a class with the following:</p>
<ol>
<li><code>begin</code> and <code>end</code> methods returning some iterator type.</li>
<li>This iterator type has prefix <code>++</code>, <code>!=</code>, and unary <code>*</code>.</li>
</ol>
<p>You can use a range-based <code>for</code> loop.</p>
<p><strong>Example:</strong> Range-based <code>for</code> loop with iterator class</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If you want to get a copy of the data stored in the class</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> / <span class="keyword">auto</span> n : l) &#123;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl; <span class="comment">// n is a copy</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If you want to mutate list items (or save copying):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;n : l) &#123;</span><br><span class="line">	++n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Encapsulation continued</p>
<p>List client can create iterators directly:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = List::Iterator &#123;<span class="literal">nullptr</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>This violates the idea that all iterators are created by calling <code>begin()</code> or <code>end()</code>. While <code>List::Iterator&#123;nullptr&#125;</code> is the same thing that is returned by <code>end()</code> in this case, it’s not necessarily the case with other data structures.</li>
</ul>
<p>Consider making <code>List::Iterator</code>‘s constructor private:</p>
<ul>
<li>Being a <code>private</code> method, it can not be called by the user.</li>
<li>However, even <code>List</code> would not be able to make iterators in <code>begin()</code> or <code>end()</code>.</li>
</ul>
<p>Solution: Make an exception for the <code>List</code> class so that it gets privileged access to the normally <code>private</code> constructor for <code>Iterator</code>.</p>
<ul>
<li>Make it a <u>friend</u></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">            Node *cur;</span><br><span class="line">            <span class="built_in">Iterator</span> (Node *cur): cur&#123;cur&#125; &#123;&#125;</span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">            	<span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">List</span>; <span class="comment">// This can be anywhere in Iterator</span></span><br><span class="line">        &#125;; <span class="comment">// Ends iterator</span></span><br><span class="line">    	<span class="function">Iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Iterator&#123;head&#125;; &#125;</span><br><span class="line">    	<span class="function">Iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Iterator&#123;<span class="literal">nullptr</span>&#125;; &#125; </span><br><span class="line">&#125;; <span class="comment">// Ends List</span></span><br></pre></td></tr></table></figure>

<p>If class A declares class B as a friend, then B can access all the private fields &#x2F; methods of A.</p>
<p>Now, a user can now create an Iterator, also also List, we can be sure that all Iterators can be created via <code>begin()</code> or <code>end()</code>.</p>
<p><strong>Advice:</strong> Limit your friendships - More friendships means more difficulty to reason about private fields &#x2F; methods.</p>
<p>Instead of friendships, consider using accessor &#x2F; mutator methods instead (getters &#x2F; setters).</p>
<p><strong>Example:</strong> Accessors and mutators for the <code>vec</code> class.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vec</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br><span class="line">    	<span class="function"><span class="type">int</span> <span class="title">getY</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> y; &#125;</span><br><span class="line">    	<span class="function"><span class="type">int</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; x = a; &#125;</span><br><span class="line">    	<span class="function"><span class="type">int</span> <span class="title">setY</span><span class="params">(<span class="type">int</span> b)</span> </span>&#123; y = b; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>What if we want to use <code>operator&lt;&lt;</code>, this needs both <code>x</code> and <code>y</code>, but must be a standalone function.</p>
<p>We declare friend methods just like how we declare friend classes. Instead of providing a class name, we provide a function signature.</p>
<p><strong>Example:</strong> Declaring output operator as a friend function.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="type">const</span> vec&amp; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> out &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; v.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; v.y &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vec</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">// Has access to x &amp; y, even though they&#x27;re private fields</span></span><br><span class="line">    	<span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;, <span class="type">const</span> vec&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Equality-Revisited"><a href="#Equality-Revisited" class="headerlink" title="Equality Revisited"></a>Equality Revisited</h3><p>We now have an encapsulated <code>List</code> class.</p>
<p>We already have <code>ith</code> and <code>addToFront</code> methods. We could also add a length method.</p>
<p>Options:</p>
<ol>
<li>Loop through the nodes to count them: <code>O(n)</code>.</li>
<li>Store the length as a field of <code>List</code> &amp; keep it up to date whenever <code>addToFront</code> is called: <code>O(1)</code>.</li>
</ol>
<p>Option 2 is preferred, as it optimizes equality.</p>
<p>Most lists will have different lengths, and so we could optimize the <code>==</code> operator by checking the length first, and only compare the individual values if the lengths differ. If lengths differ, then equality is calculated in <code>O(1)1</code> time.</p>
<p><strong>Example:</strong> Optimized equality operator for a <code>List</code> class.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>;</span><br><span class="line">    Node* head;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">auto</span> <span class="keyword">operator</span>==(<span class="type">const</span> List&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (length != other.length) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">            <span class="keyword">return</span> (*<span class="keyword">this</span> &lt;=&gt; other) == <span class="number">0</span>; <span class="comment">// Compare with &lt;=&gt;</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> List&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!head &amp;&amp; !other.head) &#123; <span class="keyword">return</span> std::strong_ordering::equal;&#125;</span><br><span class="line">            <span class="keyword">if</span> (!head) <span class="keyword">return</span> std::strong_ordering::less;</span><br><span class="line">            <span class="keyword">if</span> (!other.head) <span class="keyword">return</span> std::strong_ordering::greater;</span><br><span class="line">            <span class="keyword">return</span> *head &lt;=&gt; *other.head; <span class="comment">// Compare next</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spaceship operator provides <code>&gt;=</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&lt;</code>, for <code>List</code>. We have overloaded the <code>==</code> operator, for which the compiler will use the custom optimized version, as well as for <code>!=</code>, which is just the negation of <code>==</code>.</p>
<p>But in the special case of equality checking, we are missing out on a shortcut: Lists whose lengths are different cannot be equal. In this case, could answer “not equal” in <code>O(1)</code> time.</p>
<h3 id="System-Modelling"><a href="#System-Modelling" class="headerlink" title="System Modelling"></a>System Modelling</h3><p>Visualize the structure of the system (abstractions + relationships among them) to aid design of implementations.</p>
<p>We want to graphically display the classes of a program at a high level.</p>
<p>We uses the popular standard language <strong>UML (Unified Modelling Language)</strong>.</p>
<p><strong>Example:</strong> UML Diagram for the <code>Vec</code> class.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202410221523999.png" alt="UML Fig 1"></p>
<p>Here, there are 2 different sections. Upper section is for variables and the bottom section is for functions. Anything prepended by a <code>+</code> is <code>public</code>, anything prepended by <code>-</code> is <code>private</code>.</p>
<h3 id="Relationships-Between-Classes"><a href="#Relationships-Between-Classes" class="headerlink" title="Relationships Between Classes"></a>Relationships Between Classes</h3><h4 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h4><p><strong>Composition</strong> is one possible relationship between classes, where one classes is embedded within the other.</p>
<p><strong>Example:</strong> Composition relationship.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Basis</span> &#123;</span><br><span class="line">	Vec v1, v2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Embedding one object (e.g. Vec) inside another (e.g. Basis) called composition.</p>
<p>Here, <code>Basis</code> is <strong>composed</strong> of 2 <code>Vec</code>s. They are <u>part of</u> a basis and that is their only purpose. This is also called “owns-a”. Here, <code>Basis</code> owns 2 <code>Vec</code>s.</p>
<p>Following is the UML diagram for the <code>Basis</code> example:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202410221531125.png" alt="UML Fig 2"></p>
<p>If “<code>A</code> owns-a <code>B</code>“, then:</p>
<ul>
<li><code>B</code> has no identity outside <code>A</code> (No independent existence)</li>
<li>If <code>A</code> dies, <code>B</code> also dies.</li>
<li>If <code>A</code> is copied, <code>B</code> is copied (deep copy).</li>
</ul>
<p>An example would be: A car owns its engine - the engine is part of the car.</p>
<ul>
<li>Destroying the car will also destroys the engine.</li>
<li>Copying the car will also copies the engine.</li>
</ul>
<p>Implementation - Usually as composition of classes.</p>
<p>A &lt;&gt;—-&gt; B means A owns some number of B’s.</p>
<ul>
<li>Can annotate with multiplicities, field names.</li>
</ul>
<h4 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h4><p><strong>Aggregation</strong> is similar to Composition, except with some minor differences. Instead of one class being embedded in another, it’s rather linked to the other.</p>
<p>E.g.: Compare car parts in a car (“owns-a”) vs. car parts in a catalogue.</p>
<ul>
<li>The catalogue contains the parts, but the parts have an independent existence.</li>
</ul>
<p>An aggregation relationship is also called “has-a”.</p>
<p>If “<code>A</code> has-a <code>B</code>“, then:</p>
<ul>
<li>If <code>A</code> dies, then <code>B</code> keeps living.</li>
<li>If <code>A</code> is copied, then <code>B</code> is not copied (shallow copy).</li>
<li><code>B</code> may have independent existence outside of <code>A</code>.</li>
</ul>
<p><strong>Example:</strong> Aggregation relationship - Parts in a catalogue, ducks in a pond.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    University* myUni&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Student</span>(...) &#123;&#125;</span><br><span class="line">    	<span class="comment">// Anything else</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    University uw &#123; ... &#125;;</span><br><span class="line">    Student s1 &#123;<span class="number">1</span>, &amp;uw&#125;;</span><br><span class="line">    Student s2 &#123;<span class="number">2</span>, &amp;uw&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The following is the UML diagram for the <code>Student</code> example:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202410221550091.png" alt="UML Fig 3"></p>
<p>Case Study: Does a pointer field always mean non-ownership?</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202410241434412.png" alt="UML Fig 4"></p>
<p>A node owns the node that follows it. (Recall that implementation of the Big 5 is a good sign of ownership)</p>
<p>The <code>List</code> owns the first node, but the ownerships are implemented via pointers.</p>
<p>Another view of lists &amp; nodes.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202410241440954.png" alt="UML Fig 5"></p>
<p>We could view the List object as owning <u>all</u> the nodes within it.</p>
<p>What might this suggest about the implementation of Lists &amp; Nodes in this case?</p>
<p>Likely, that List is taking responsibility for copying and construction&#x2F;deconstruction of Nodes, rather than Node.</p>
<p>Possible iterative (i.e. loop-based) management of pointers instead of recursive operations within Node.</p>
<h4 id="Specialization-x2F-Inheritance"><a href="#Specialization-x2F-Inheritance" class="headerlink" title="Specialization &#x2F; Inheritance"></a>Specialization &#x2F; Inheritance</h4><p>Suppose we want to track our collection of books.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    string title, author;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Book</span>(...) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span> &#123;</span><br><span class="line">    string title, author;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    string topic;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Text</span>(...) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comic</span> &#123;</span><br><span class="line">    string title, author;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    string hero;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Comic</span>(...) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This is OK, but it doesn’t capture the relationships among Book, Text, and Comic.</p>
<p>And how do we create an array (or list) that contains a mix of these?</p>
<p><u>Could</u>:</p>
<ol>
<li>Use a Union</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Union BookTypes &#123; Book *b, Text *t, Comic *c&#125;; <span class="comment">// Stores ONE of the data types</span></span><br><span class="line">Book Types myBooks[<span class="number">20</span>];</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Array of <code>void*</code> - Pointer to anything</li>
</ol>
<p>Not good solutions - subvert the type system.</p>
<p>Rather, observe: Texts and Comics are <u>kinds</u> of Books - Books with extra features.</p>
<p>To model in C++, we introduce <strong>inheritance</strong>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123; <span class="comment">// Base class or Superclass</span></span><br><span class="line">    string title, author;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">book</span>(string title, string author, <span class="type">int</span> length): title&#123;title&#125;, author&#123;author&#125;, length&#123;length&#125; &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Derived subclasses</span></span><br><span class="line"><span class="comment">// All fields / methods inherited from Book</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span>: <span class="keyword">public</span> Book &#123;</span><br><span class="line">    string topic;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Text</span>(...) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comic</span>: <span class="keyword">public</span> Book &#123;</span><br><span class="line">    string hero;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Comic</span>(...) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Derived classes <u>inherit</u> fields and methods from the base class. So Text, Comic get title, author, length fields. Any method that can be collection on Book can be called on Text, Comic.</p>
<p>Who can see these members?</p>
<p>title, author, length - private in Book - outsiders can’t see them.</p>
<p>Can Text, Comic see them? <strong>NO</strong>, even subclasses can’t see them!</p>
<p>How do we initialize Text? Need title, author, length, topic</p>
<p><strong>Example:</strong> Incorrect constructor for a subclass.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Warning: This code doesn&#x27;t work and the reason why is explained below</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span>: <span class="keyword">public</span> Book &#123;</span><br><span class="line">    string topic;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Text</span>(string title, string author, <span class="type">int</span> length, string topic): title&#123;title&#125;, author&#123;author&#125;, length&#123;length&#125;, topic&#123;topic&#125; &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Wrong for 2 reasons:</p>
<ol>
<li>title, etc. are not accessible in Text (even if they were, MIL only lets you mention your own fields)</li>
<li>Once again, when an object is created:<ol>
<li>Space is allocated</li>
<li>Superclass constructor runs <strong>NEW</strong></li>
<li>Fields are initialized via MIL</li>
<li>Constructor body runs</li>
</ol>
</li>
</ol>
<p>So a constructor for Book must run before the fields of Text can be initialized. If Book has no default constructor, a constructor for Book must be invoked explicitly:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span>: <span class="keyword">public</span> Book &#123;</span><br><span class="line">    string topic;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Text</span>(string title, string author, <span class="type">int</span> length, string topic):</span><br><span class="line">    		Book&#123;title, author, length&#125;, topic&#123;topic&#125; &#123;&#125;</span><br><span class="line">    		step <span class="number">2</span> / step <span class="number">3</span> / step <span class="number">4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Good reasons to keep superclass fields inaccessible to subclasses.</p>
<h4 id="Protected-Variables-and-Methods"><a href="#Protected-Variables-and-Methods" class="headerlink" title="Protected Variables and Methods"></a>Protected Variables and Methods</h4><p>If you want to give subclasses access to certain members, use <u>protected</u> access.</p>
<p><strong>Example:</strong> Different abilities for different subclasses.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span>: <span class="comment">// Accessible to Book and its subclasses, but no one else</span></span><br><span class="line">    	string title, author;</span><br><span class="line">    	<span class="type">int</span> length;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Book</span>(...) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span>: <span class="keyword">public</span> Book &#123;</span><br><span class="line">    string topic;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">addAuthor</span><span class="params">(string newArthor)</span> </span>&#123; author += <span class="string">&quot; &quot;</span> + newAuthor;&#125;</span><br><span class="line">    	<span class="comment">// The above function can access and modify author since it is a protected field</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Not a good idea to give subclasses unlimited access to fields. <u>Better</u> - make fields private, but provide protected accessors &#x2F; mutators.</p>
<p><strong>Example:</strong> Protected mutators.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    string title, author;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">setAuthor</span><span class="params">(string newAuthor)</span></span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Book</span>();</span><br><span class="line">    	<span class="function"><span class="type">bool</span> <span class="title">isHeavy</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    	<span class="comment">// The above function may only be called inside Book or any of it&#x27;s subclasses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Relationship among Text, Comic, Book is called “is-a”</p>
<ul>
<li>A text “is-a” Book</li>
<li>A Comic “is-a” Book</li>
</ul>
<p>![UML Fig 6] (<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202410241543154.png">https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202410241543154.png</a>)</p>
<h4 id="Virtual-Methodss"><a href="#Virtual-Methodss" class="headerlink" title="Virtual Methodss"></a>Virtual Methodss</h4><p>Now consider the method <code>isHeavy</code> - when is a Book heavy?</p>
<ul>
<li>for ordinary books - a book is heavy if it’s more than 200 pages</li>
<li>for texts - more than 500 pages</li>
<li>for comics - more than 30 pages</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">bool</span> <span class="title">isHeavy</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> length &gt; <span class="number">200</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comic</span>:<span class="keyword">public</span> Book &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">bool</span> <span class="title">isHeavy</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> length &gt; <span class="number">30</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Book b &#123;<span class="string">&quot;A small book &quot;</span>, _____, <span class="number">50</span>&#125;;</span><br><span class="line">Comic c &#123;<span class="string">&quot;A big comic &quot;</span>, _____, <span class="number">40</span>, _____&#125;;</span><br><span class="line">cout &lt;&lt; b.<span class="built_in">isHeavy</span>() &lt;&lt; c.<span class="built_in">isHeavy</span>(); <span class="comment">// false true</span></span><br></pre></td></tr></table></figure>

<p>Now, since public inheritance defines an “is-a” relationship, we can do this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Book b = Comic &#123;<span class="string">&quot;A big comic &quot;</span>, _____, <span class="number">40</span>, _____&#125;;</span><br></pre></td></tr></table></figure>

<p><u>Question</u>: Is b heavy? i.e. <code>b.isHeavy()</code> - true or false? i.e. which <code>isHeavy()</code> runs? <code>Book::isHeavy()</code> or <code>Comic::isHeavy()</code>?</p>
<p><u>Answer</u>: b is <strong>NOT</strong> heavy. Which means <code>Book::isHeavy()</code> runs.</p>
<p><u>Why?</u> <code>Book b</code> is on stack, <code>= Comic &#123; ... &#125;;</code> is on heap</p>
<p><u>Explanation</u>: We tries to fit a Comic object, where there is only space for a Book object. What happens? Comic is <u>sliced</u>. The hero field gets chopped off. Comic is <u>coerced</u> into a Book. So <code>Book b = Comic &#123; ... &#125;;</code>  creates a Book and <code>Book::isHeavy</code> runs.</p>
<p>NOTE: Slicing takes place even if the two object types were of the same size. Having <code>isHeavy()</code> depend on whether Book &amp; Comic are the same size would not be good.</p>
<p>When accessing objects through pointers, slicing is unnecessary and doesn’t happen.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Comic c &#123;___, ___, <span class="number">40</span>, ___&#125;;</span><br><span class="line">Book *pb = &amp;c;</span><br><span class="line">c.<span class="built_in">isHeavy</span>(); <span class="comment">// true</span></span><br><span class="line">pb-&gt;<span class="built_in">isHeavy</span>(); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>Compiler uses the type of the pointer (or reference) to decide which <code>isHeavy()</code> to run - doesn’t consider the actual type of the object.</p>
<p>Behavior of the object depends on what type of pointer (or reference) you access it through.</p>
<p>How can we make Comic act like a Comic, even when pointed to by a Book pointer? I.e., how can you get <code>Comic::isHeavy()</code> to run?</p>
<p>Declare the method <u>virtual</u>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">isHeavy</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> length &gt; <span class="number">200</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comic</span>:<span class="keyword">public</span> Book &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">bool</span> <span class="title">isHeavy</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> length &gt; <span class="number">30</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Comic c &#123;___, ___, <span class="number">40</span>, ___&#125;;</span><br><span class="line">Comic *pc = &amp;c;</span><br><span class="line">Book *pb = &amp;c;</span><br><span class="line">Book &amp;rb = c;</span><br><span class="line"></span><br><span class="line">pc-&gt;<span class="built_in">isHeavy</span>(); <span class="comment">// true</span></span><br><span class="line">pb-&gt;<span class="built_in">isHeavy</span>(); <span class="comment">// true</span></span><br><span class="line">rb.<span class="built_in">isHeavy</span>(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Virtual methods: Choose which class’s method to run based on the actual type of the object at run time. (Only applies if accessing through pointer&#x2F;reference, otherwise slicing).</p>
<p><strong>Example:</strong> my book collection</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Book *myBooks[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    cout &lt;&lt; myBooks[i]-&gt;<span class="built_in">isHeavy</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Uses <code>Book::isHeavy()</code> for Books</li>
<li>Uses <code>Comic::isHeavy()</code> for Comics</li>
<li>Uses <code>Text::isHeavy()</code> for Texts</li>
</ul>
<p>Accommodating multiple types under one abstraction: <strong>Polymorphism</strong> (“many forms”).</p>
<p><u>Note</u>: this is why a function <code>void f(istream f)</code> can be passed an <code>ifstream</code>, <code>ifstream</code> is a subclass of <code>istream</code>.</p>
<p><strong>DANGER:</strong> What if we’ve written <code>Book myBooks[20];</code> and try to use that polymorphically?</p>
<p>Consider</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(Book books[])</span> </span>&#123;</span><br><span class="line">    books[<span class="number">1</span>] = Book&#123;<span class="string">&quot;book&quot;</span>, <span class="string">&quot;author&quot;</span>, ___&#125;;</span><br><span class="line">&#125;</span><br><span class="line">Comic c[<span class="number">2</span>] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;comic1&quot;</span>, <span class="string">&quot;artist1&quot;</span>, <span class="number">10</span>, <span class="string">&quot;hero1&quot;</span>&#125;,</span><br><span class="line">   	&#123;<span class="string">&quot;comic2&quot;</span>, <span class="string">&quot;artist2&quot;</span>, <span class="number">10</span>, <span class="string">&quot;hero2&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(c); <span class="comment">// This is legal</span></span><br></pre></td></tr></table></figure>

<p>What is c now?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#123;“comic1<span class="string">&quot;, &quot;</span>artist1<span class="string">&quot;, 10, &quot;</span>book<span class="string">&quot;&#125;,</span></span><br><span class="line"><span class="string">    &#123;&quot;</span>author<span class="string">&quot;, ??? &#125;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>Recommendation:</strong>  Never use arrays of objects polymorphically. Use arrays of pointers.</p>
<h4 id="Destructor-Revisited"><a href="#Destructor-Revisited" class="headerlink" title="Destructor Revisited"></a>Destructor Revisited</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span> *x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">X</span>(<span class="type">int</span> n): X &#123;<span class="keyword">new</span> <span class="type">int</span>[n]&#125; &#123;&#125;</span><br><span class="line">    	~<span class="built_in">X</span>() &#123; <span class="keyword">delete</span>[] x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Y</span> &#123;</span><br><span class="line">    <span class="type">int</span> *y;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Y</span>(<span class="type">int</span> m, <span class="type">int</span> n): X&#123;n&#125;, y&#123;<span class="keyword">new</span> <span class="type">int</span>[m];&#125; &#123;&#125;</span><br><span class="line">    	~<span class="built_in">Y</span>() &#123; <span class="keyword">delete</span>[] y; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>How can we make sure that deleting through a superclass pointer runs the subclass desctructor? - Declare the destructor <u>virtual</u>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">X</span> &#123;</span><br><span class="line">    <span class="type">int</span> *x;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">virtual</span> ~<span class="built_in">X</span>() &#123; <span class="keyword">delete</span>[] x; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><u>ALWAYS</u> make the destructor virtual in classes that are meant to have subclasses, even if the destructor doesn’t do anything.</p>
<p>If a class is <strong>NOT</strong> meant to have subclasses - declare it <u>final</u>: <code>classY find:public X &#123;...&#125;;</code></p>
<h4 id="Pure-Virtual-Methods"><a href="#Pure-Virtual-Methods" class="headerlink" title="Pure Virtual Methods"></a>Pure Virtual Methods</h4><p>Consider 2 kinds of student: Regular and Coop.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Students</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">fees</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Regular</span>: <span class="keyword">public</span> Student&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">int</span> <span class="title">fees</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Coop</span>: <span class="keyword">public</span> Student&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">int</span> <span class="title">fees</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>What should we put for <code>Student::fees()</code>?</p>
<p>We’re not sure, since every student should be either Regular or Coop.</p>
<p>We can explicitly give <code>Student::fees()</code> <u>no</u> implementation.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">fees</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    	<span class="comment">// Method has no implementation</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>A class with a pure virtual method cannot be instantiated.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student s; <span class="comment">// Cannot do this</span></span><br></pre></td></tr></table></figure>

<p>This is called an <u>abstract class</u>, which purpose is to organize subclasses. Subclasses of an abstract class are also abstract unless they implement all pure virtual methods.</p>
<p>Non-abstract classes are called <u>concrete</u>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Regular</span>: <span class="keyword">public</span> Student &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">int</span> <span class="title">fees</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> ...; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>UML:</p>
<ul>
<li>Virtual &#x2F; Pure virtual methods: italics</li>
<li>Abstract classes: italicize class name</li>
</ul>
<h4 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h4><p>Huge topic - just to highlight here.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        Node *next;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>What if you want a List of something else?</p>
<p>Whole new class?</p>
<p><u>OR</u> a template - class parameterized by a type</p>
<p><strong>Example:</strong> Implementing Stack using template</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">    <span class="type">int</span> size, cap;</span><br><span class="line">    T *contents;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T, x)</span> </span>&#123; ... &#125;;</span><br><span class="line">    	<span class="function">T <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Example:</strong> Implementing List using template</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    Struct Node &#123;</span><br><span class="line">        T data;</span><br><span class="line">        Node *next;</span><br><span class="line">    &#125;;</span><br><span class="line">    Node *head;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">class</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">            Node *p;</span><br><span class="line">            <span class="keyword">public</span>:</span><br><span class="line">            	T &amp;<span class="keyword">operator</span> *();</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="function">T &amp;<span class="title">ith</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addToFront</span><span class="params">(<span class="type">const</span> T&amp; n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Client:</span></span><br><span class="line">List&lt;<span class="type">int</span>&gt; l1;</span><br><span class="line">List&lt;List&lt;<span class="type">int</span>&gt;&gt; l2;</span><br><span class="line">l1.<span class="built_in">addToFront</span>(<span class="number">3</span>);</span><br><span class="line">l2.<span class="built_in">addToFront</span>(l1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (List&lt;<span class="type">int</span>&gt;:Iterator it = l1.<span class="built_in">begin</span>(); it != l1.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Compiler specializes templates at the source code level, then compiles the specializations.</p>
<h4 id="Standard-Template-Library-STL"><a href="#Standard-Template-Library-STL" class="headerlink" title="Standard Template Library (STL)"></a>Standard Template Library (STL)</h4><p>A collection of useful templated classes.</p>
<p>Dynamic length arrays: <code>std::vector</code></p>
<p><strong>Example:</strong> Client code of <code>std::vector</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;vector&gt;;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// contains &#123;4, 5&#125;</span></span><br><span class="line"><span class="comment">// Note: vector &lt;int&gt; v (4, 5); produces &#123;5, 5, 5, 5&#125;</span></span><br><span class="line">v.<span class="built_in">emplace_back</span>(<span class="number">6</span>); <span class="comment">// contains &#123;4, 5, 6&#125;</span></span><br><span class="line">v.<span class="built_in">emplace_back</span>(<span class="number">7</span>): <span class="comment">// contains &#123;4, 5, 6, 7&#125;</span></span><br></pre></td></tr></table></figure>

<p>But also:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector w &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;; <span class="comment">// Note: no &lt;int&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>if the type argument of a template can be deduced from its initialization, you can leave it out! <int> is deduced here.</li>
</ul>
<p><strong>Example:</strong> Looping over vectors:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Regular loop (like array)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    cout &lt;&lt; v[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Using an iterator</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterator with ranged-based for loop</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> n : v) cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reverse iterator</span></span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::reverse_iterator it = v.<span class="built_in">rbegin</span>(); it != v.<span class="built_in">rend</span>(); it++) &#123;</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>More <code>vector</code> functions:</p>
<ul>
<li><code>v.pop_back()</code> remove last element</li>
</ul>
<p>Use iterators to remove items from inside a vector.</p>
<p><strong>Example:</strong> remove all 5’s from the vector v.</p>
<p><u>Attempt #1</u>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">5</span>) v.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Why is this wrong? Consider: we can’t handle consecutive repetitive items.</p>
<p><u>Note:</u> After the erase, <u>it</u> points at a different item.</p>
<p>The rule is: after an insertion or erase, all iterators pointing after the point of insertion &#x2F; erase are considered invalid and must be refreshed.</p>
<p><strong>Example:</strong> Code that iterates through a <code>vector</code> and removes all elements that are equal to 5</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>();) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*it == <span class="number">5</span>) v.<span class="built_in">erase</span>(it);</span><br><span class="line">    <span class="keyword">else</span> it++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Another thing to note:</p>
<p><code>v[i]</code> is i-th element of v.</p>
<ul>
<li>This is unchecked, if you go out of bounds, that is <u>undefined behavior</u>.</li>
</ul>
<p><code>v.at[i]</code></p>
<ul>
<li>Checked version of <code>v[i]</code></li>
<li>When goes out of bound<ul>
<li><u>Problem</u>: Vector’s code can detect the error, but doesn’t know what to do about it.</li>
<li>Client can response, but can’t detect the error.</li>
<li><u>C solution</u>: function’s return a status code or set the global variable error<ul>
<li>Leads to awkward programming</li>
<li>encourages programmers to ignore error checks</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>C++ - when an error condition arises, the function <u>raises an exception</u>.</p>
<p>By default, execution stops, but we can write <u>handlers</u> to <u>catch</u> exceptions &amp; deal with them.</p>
<p><code>Vector&lt;T&gt;::at</code> throws an exception of type <code>std::out_of_range</code> when it fails, we can handle it as follows.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;stdexcept&gt;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">at</span>(<span class="number">10000</span>); <span class="comment">// Statement that may fail go in a try block</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (out_of_range r) &#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Range error&quot;</span> &lt;&lt; r.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now consider:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> out_of_range &#123;<span class="string">&quot;f&quot;</span>&#125;; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123; <span class="built_in">f</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">g</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">h</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">catch</span>(out_of_range) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In the above code, main calls h, h  calls g, g calls f, f throws. The control goes back through the call chain (unwinds the stack) until the handler is found, all the way back to main, main handles the exception.</p>
<p>If there’s no matching handler in the entire call chain, the program terminates.</p>
<p>A handler can do part of the recovery job, i.e. execute some corrective code &amp; throw another exception.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// throw other exception</span></span><br><span class="line"><span class="keyword">try</span> &#123; ... &#125;</span><br><span class="line"><span class="built_in">catch</span> (someError s) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">throw</span> SomeOtherError &#123; ..  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or rethrow same exception</span></span><br><span class="line"><span class="keyword">try</span> &#123; ... &#125;</span><br><span class="line"><span class="built_in">catch</span> (someError s) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// throw or throw s?</span></span><br></pre></td></tr></table></figure>

<p>maybe <code>someError</code> has a subclass: <code>specialError</code></p>
<p><code>throw s:</code> s may be a subtype of <code>someError</code>, and throws a new exception of type <code>someError</code>.</p>
<p><code>throw:</code> actual type of s is retained.</p>
<p>A handler can act as a catch-all.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; ... &#125;</span><br><span class="line"><span class="built_in">catch</span> (...) &#123; <span class="comment">// Literally &quot;...&quot;, catches all exceptions</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note: You can throw anything you want, it doesn’t have to be an object!</p>
<p>Define your own classes (or use appropriate existing ones) for exceptions.</p>
<p><strong>Example:</strong> Bad input</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BadInput</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">int</span> n; !(cin &gt;&gt; n)) <span class="keyword">throw</span> BadInput&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (BadInput &amp;) &#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;Input not well-formed. \n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Recap that in Assignment Operator:</p>
<p>When new fails: throws an exception <code>std::bad_alloc</code>.</p>
<p><u>NEVER:</u> let a destructor throw or propagate an exception. If we let destructor throw exception:</p>
<ul>
<li>Program <u>will</u> abort <u>immediately.</u></li>
<li>If you want to let a destructor throw, you can tag it with <code>noexcept(false)</code>.</li>
</ul>
<p><u>BUT</u>: If a destructor is running during stack unwinding, while dealing with another exception, and it throws, you now have <u>two</u> active, unhandled exceptions, and the program <u>will</u> abort <u>immediately.</u></p>
<h3 id="Design-Patterns-Continued"><a href="#Design-Patterns-Continued" class="headerlink" title="Design Patterns (Continued)"></a>Design Patterns (Continued)</h3><p>In general, the guiding principle is to program to the interface instead of the implementation.</p>
<ul>
<li>The abstract base classes define the interface.<ul>
<li>work with base class pointers &amp; call their methods.</li>
</ul>
</li>
<li>concrete subclasses can be swapped in &amp; out.<ul>
<li>abstraction over a variety of behaviors.</li>
</ul>
</li>
</ul>
<h4 id="Iterator-Pattern-1"><a href="#Iterator-Pattern-1" class="headerlink" title="Iterator Pattern"></a>Iterator Pattern</h4><p><strong>Example:</strong> Abstract Iterator Pattern</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractIterator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">virtual</span> <span class="type">int</span> &amp;<span class="keyword">operator</span>*() = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">virtual</span> AbstractIterator &amp;<span class="keyword">operator</span>++() = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">virtual</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> AbstractIterator &amp;other) == <span class="number">0</span>;</span><br><span class="line">    	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">List</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">class</span> <span class="title class_">Iterator</span>:<span class="keyword">public</span> AbstractIterator &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Set</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">class</span> <span class="title class_">Iterator</span>:<span class="keyword">public</span> AbstractIterator &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Then you can write code that operates over iterators:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Works over Lists and Sets</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">for_each</span><span class="params">(AbstractIterator &amp;start, AbstractIterator &amp;finish, <span class="type">void</span> (*f) (<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (start != end) &#123;</span><br><span class="line">        <span class="built_in">f</span>(*start);</span><br><span class="line">        ++start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Observer-Pattern"><a href="#Observer-Pattern" class="headerlink" title="Observer Pattern"></a>Observer Pattern</h4><p>Publish-subscribe model:</p>
<ul>
<li>One class: publisher &#x2F; subject - generates data</li>
<li>One or more subscriber &#x2F; observer classes - receive data &amp; react to it</li>
</ul>
<p><strong>Example:</strong> publisher &#x3D; spreadsheet cells, observers &#x3D; charts</p>
<ul>
<li>When cells change graphs update.</li>
</ul>
<p>There can be many kinds of observer objects - the subject should not need to know all the details.</p>
<p>Here’s the UML diagram for the observer pattern:<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202411071438917.png" alt="Observer Pattern Fig.1"></p>
<p>Steps of execution when the <code>Subject</code> is called:</p>
<ol>
<li>Subject’s state is updated</li>
<li><code>Subject::notifyObservers()</code> is called - it calls every observer’s notify</li>
<li>Each observer calls <code>ConcreteSubject::getState</code> to query the state</li>
</ol>
<p><strong>Example:</strong> Horse races</p>
<p>Subject - Publishes winners</p>
<p>Observers - Individual betters - declare victory when their hose wins.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    vector&lt;Observer *&gt; observers;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">attach</span><span class="params">(Observer *ob)</span> </span>&#123;observers.<span class="built_in">emplace_back</span>(ob);&#125;</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">(Observer *ob)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> p : observers) &#123;</span><br><span class="line">                <span class="keyword">if</span> (*p == ob) &#123;</span><br><span class="line">                    observers.<span class="built_in">erase</span>(p);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123; <span class="keyword">for</span> (<span class="keyword">auto</span> ob : observers)&#123;ob-&gt;<span class="built_in">notify</span>();&#125;&#125;</span><br><span class="line">    	<span class="keyword">virtual</span> ~<span class="built_in">Subject</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Subject::~<span class="built_in">Subject</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Observer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">notify</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">virtual</span> ~<span class="built_in">Observers</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Above: Reusable code for similar pattern</span></span><br><span class="line"><span class="comment">// Below: Subclass that has to do with &quot;horse race&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HorseRace</span>: <span class="keyword">public</span> Subject &#123;</span><br><span class="line">    ifstream in; <span class="comment">// source of data</span></span><br><span class="line">    string lastWinner;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">HorseRace</span>(string source): in&#123;source&#125; &#123;&#125;</span><br><span class="line">    	<span class="function"><span class="type">bool</span> <span class="title">runRace</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> in &gt;&gt; lastWinner; &#125; <span class="comment">// True if successful, false if no more races.</span></span><br><span class="line">    	<span class="function">string <span class="title">getState</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> lastWinner; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bettor</span>: <span class="keyword">public</span> Observer &#123;</span><br><span class="line">    HorseRace *subject;</span><br><span class="line">    string name, myHorse;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Bettor</span> (____): _____&#123;&#125; &#123;</span><br><span class="line">            subject-&gt;<span class="built_in">attach</span>(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    ~<span class="built_in">Bettor</span>() &#123; subject-&gt;<span class="built_in">detach</span>(<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (subject-&gt;<span class="built_in">getState</span>() == myHorse) cout &lt;&lt; <span class="string">&quot;Win!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Lose :(&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main</span></span><br><span class="line"></span><br><span class="line">HorseRace hr&#123;<span class="string">&quot;...&quot;</span>&#125;;</span><br><span class="line">Bettor Larry &#123;&amp;hr, <span class="string">&quot;Larry&quot;</span>, <span class="string">&quot;RunsLikeACow&quot;</span>&#125;;</span><br><span class="line">...(other bettors)</span><br><span class="line"><span class="keyword">while</span>(hr.<span class="built_in">runRace</span>()) &#123;</span><br><span class="line">    hr.<span class="built_in">notifyObservers</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A4 &amp; Final Project: Do the text version first, later add the GUI as an observer.</p>
<h4 id="Decorator-Pattern"><a href="#Decorator-Pattern" class="headerlink" title="Decorator Pattern"></a>Decorator Pattern</h4><p>We want to enhance an object at runtime -add functionality &#x2F; features.</p>
<p>Let’s say we’re creating windowing system, we start with a basic window.</p>
<ul>
<li>Add a scrollbar when text exceeds the page length</li>
<li>Add a menu</li>
</ul>
<p>We want to choose these enhancements at runtime.</p>
<p>UML diagram for Decorator Pattern:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202411071521959.png" alt="Decorator Fig.1"></p>
<p>Components: defines the interface - operations your objects will provide</p>
<p>ConcreteComponent: implements the interface</p>
<p>Decorators: all inherit from Decorator, which inherits from component</p>
<ul>
<li>Every decorator <u>is</u> a Component <u>AND</u> every decorator <u>has</u> a component.</li>
</ul>
<p>For example: A window with a scrollbar is a kind of window and has a pointer to the underlying plain window.</p>
<p>Window with a scrollbar &amp; a menu is a window, which has a pointer to a window with a scrollbar, which has a pointer to a plain window.</p>
<p><strong>Example:</strong> Pizza:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pizza</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">price</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> sring <span class="title">desc</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">virtual</span> ~<span class="built_in">Pizza</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CrustAndSauce</span> : <span class="function"><span class="keyword">public</span> <span class="title">Pizza</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">float</span> <span class="title">price</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="number">5.99</span>; &#125;</span><br><span class="line">    	<span class="function">string <span class="title">desc</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Pizza&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202411071541558.png" alt="Decorator Fig.2"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span> : <span class="keyword">public</span> Pizza &#123;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">    	Pizza *component;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">Decorator</span>(Pizza *p) : component &#123;p&#125; &#123;&#125;</span><br><span class="line">    	<span class="keyword">virtual</span> ~<span class="built_in">Decorator</span>() &#123; <span class="keyword">delete</span> component; &#125; <span class="comment">// You may choose to separate them</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StuffedCrust</span> : <span class="keyword">public</span> Decorator &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">StuffedCrust</span> (Pizza *p): Decorator&#123;p&#125; &#123;&#125;</span><br><span class="line">    	<span class="function"><span class="type">float</span> <span class="title">price</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> component-&gt;<span class="built_in">price</span>() + <span class="number">2.69</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function">string <span class="title">desc</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> component-&gt;<span class="built_in">desc</span>() + <span class="string">&quot; with stuffed crust&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Main</span></span><br><span class="line">Pizza *p1 = <span class="keyword">new</span> CrustAndSauce&#123;&#125;;</span><br><span class="line">p1 = <span class="keyword">new</span> Topping &#123;<span class="string">&quot;Cheese&quot;</span>, p1&#125;;</span><br><span class="line">p1 = <span class="keyword">new</span> Topping &#123;<span class="string">&quot;Olives&quot;</span>, p1&#125;;</span><br><span class="line">p1 = <span class="keyword">new</span> StuffedCrust &#123;p1&#125;;</span><br><span class="line">cout &lt;&lt; p1-&gt;<span class="built_in">desc</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; p1-&gt;<span class="built_in">price</span>();</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br></pre></td></tr></table></figure>



<h4 id="Factoring-Method-Pattern"><a href="#Factoring-Method-Pattern" class="headerlink" title="Factoring Method Pattern"></a>Factoring Method Pattern</h4><p>Write a video game with 2 kinds of enemies: turtles and bullets</p>
<ul>
<li>system randomly sends turtles &amp; bullets, but bullets are more common in harder levels.</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202411121539441.png" alt="Factoring Method Pattern Fig.1"></p>
<ul>
<li>Never know exactly which enemies comes next, so can’t call turtle&#x2F;bullet constructor directly.</li>
<li>Instead put a factory method (a method that makes things) in level that creates enemies.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Level</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">virtual</span> Enemy *<span class="title">createEnemy</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// Factory method</span></span><br><span class="line">    	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Easy</span> : <span class="keyword">public</span> Level &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function">Enemy *<span class="title">createEnemy</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Create mostly turtles</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hard</span> : <span class="keyword">public</span> Level &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function">Enemy *<span class="title">createEnemy</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Create mostly bullets</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Level *l = <span class="keyword">new</span> Easy;</span><br><span class="line">Enemy *e = l-&gt;<span class="built_in">createEnemy</span>();</span><br></pre></td></tr></table></figure>



<h4 id="Template-Method-Pattern"><a href="#Template-Method-Pattern" class="headerlink" title="Template Method Pattern"></a>Template Method Pattern</h4><ul>
<li>Want subclasses to override superclass behavior, but some aspects must stay the same.</li>
</ul>
<p><strong>Example:</strong> There are red turtles and green turtles.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202411121550949.png" alt="Template Method Fig.1"></p>
<h2 id="Reviewing-Big-5-with-Inheritance"><a href="#Reviewing-Big-5-with-Inheritance" class="headerlink" title="Reviewing Big 5 with Inheritance"></a>Reviewing Big 5 with Inheritance</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">// Defines copy/move ctor/assign</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span> : <span class="keyword">public</span> Book &#123;</span><br><span class="line">    string topic;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="comment">// Does not define copy/move operations</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Text t &#123;<span class="string">&quot;Alogrithms&quot;</span>, <span class="string">&quot;CLRS&quot;</span>, <span class="number">5000</span>, <span class="string">&quot;CS&quot;</span>&#125;;</span><br><span class="line">Text t2 = t; <span class="comment">// No copy ctor for Text - what happens?</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Calls Book’s copy constructor</li>
<li>then goes field-by-field (i.e. default behavior) for the Text part</li>
<li>same for other operations.</li>
</ul>
<p>To write your own operations.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy Constructor</span></span><br><span class="line">Text:<span class="built_in">Text</span>(<span class="type">const</span> Text &amp;other) : Book &#123;other&#125;, topic &#123;other.topic&#125; &#123;&#125;</span><br><span class="line"><span class="comment">// Copy Assignment Operator</span></span><br><span class="line">Text &amp;Text::<span class="keyword">operator</span>=(<span class="type">const</span> Text &amp;other) &#123;</span><br><span class="line">    Book::<span class="keyword">operator</span> = (other); <span class="comment">// ?</span></span><br><span class="line">    topic = other.topic;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move Constructor</span></span><br><span class="line"><span class="comment">// Text::Text(Text &amp;&amp;other): Book&#123;other&#125;, topic&#123;other.topic&#125; &#123;&#125;</span></span><br><span class="line">Text::<span class="built_in">Text</span>(Text &amp;&amp;other): Book&#123;std::<span class="built_in">move</span>(other)&#125;, topic&#123;std::<span class="built_in">move</span>(other.topic)&#125; &#123;&#125;</span><br><span class="line"><span class="comment">// Move Assignment Operator</span></span><br><span class="line">Text &amp;Text::<span class="keyword">operator</span>=(Text &amp;&amp;other) &#123;</span><br><span class="line">    Book:<span class="keyword">operator</span>= (std::<span class="built_in">move</span>(other));</span><br><span class="line">    topic = std::<span class="built_in">move</span>(other.topic);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note: even though <u>other</u> “points” at an r-value, other itself is an l-value (so is <code>other.topic</code>).</p>
<p><code>std::move(x)</code> forces an l-value x to be treated as an r-value, so that the “move” versions of operations run.</p>
<p>Operations given above are equivalent to default.</p>
<p>Now consider:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Text t1 &#123;...&#125;, t2 &#123;...&#125;;</span><br><span class="line">Book *pb1 = &amp;t1, *pb2 = &amp;t2;</span><br><span class="line"><span class="comment">// What if we do *pb1 = *pb2;</span></span><br></pre></td></tr></table></figure>

<p>This is a <u>Partial Assignment</u>, only the Book part is copied.</p>
<p>How can we fix this? We try making <code>Book::operator=</code> virtual.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">virtual</span> Book &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Book &amp;other) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span> : <span class="keyword">public</span> Book &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    	Text &amp;<span class="keyword">operator</span>=(<span class="type">const</span> <span class="built_in">Book</span>(<span class="keyword">not</span> Text) &amp;other) <span class="keyword">override</span> &#123; ... &#125; <span class="comment">// Won&#x27;t compile cuz of parameter type, MUST BE SAME</span></span><br><span class="line">    	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>Note</u>: different return types are fine, but parameters must be the same or it’s not an override (and won’t compile).</p>
<p>Hence, assignment from a Book object to a Text variable would be allowed:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Text t = &#123; ... &#125;;</span><br><span class="line">t = Book &#123; ... &#125;; <span class="comment">// using a Book to assign a Text, this is BAD (but it would compile)</span></span><br><span class="line">t = Comic &#123; ... &#125; ; <span class="comment">// REALLY BAD</span></span><br></pre></td></tr></table></figure>

<p>If <code>operator=</code> is non-virtual, we get partial assignment through base class pointers. If it is virtual, it allows mixed assignment.</p>
<p><u>Recommendation</u>: All super-classes should be abstract.</p>
<p>We rewrite the Book hierarchy:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202411121520722.png" alt="Abstract Book UML"></p>
<p><strong>Example:</strong> Book with abstract superclass</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractBook</span> &#123;</span><br><span class="line">    string title, author;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    	AbstractBook &amp;<span class="keyword">operator</span>=(<span class="type">const</span> AbstractBook &amp;other); <span class="comment">// Non-virtual</span></span><br><span class="line">    	<span class="comment">// Prevents assignment through base class pointers from compiling, but implementation still available to subclasses</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">AbstractBook</span>(...) &#123; ... &#125;;</span><br><span class="line">    	<span class="keyword">virtual</span> ~<span class="built_in">AbstractBook</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AbstractBook *pb1 = &amp;t1, *pb2 = &amp;t2;</span><br><span class="line">*pb1 = *pb2; <span class="comment">// Won&#x27;t compile as it uses AbstractBook&#x27;s operator=, which is not accessible</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NormalBook</span> : <span class="keyword">public</span> AbstractBook &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	NormalBook &amp;<span class="keyword">operator</span>=(<span class="type">const</span> NormalBook &amp;other) &#123;</span><br><span class="line">            AbstractBook::<span class="keyword">operator</span>=(other);</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// other classes similar</span></span><br><span class="line">    	<span class="comment">// prevents partial &amp; mixed assignment</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Note: pure virtual destructor <u>must</u> be implemented, even though it is pure virtual.</p>
<p><code>AbstractBook::~AbstractBook() &#123;&#125;</code></p>
<h3 id="Advanced-C-Features"><a href="#Advanced-C-Features" class="headerlink" title="Advanced C++ Features"></a>Advanced C++ Features</h3><h4 id="Coupling-x2F-Cohesion"><a href="#Coupling-x2F-Cohesion" class="headerlink" title="Coupling &#x2F; Cohesion"></a>Coupling &#x2F; Cohesion</h4><p>Coupling: To what extent do modules depend on each other</p>
<ul>
<li><em><strong>Low Coupling:</strong></em> Simple communications via parameters&#x2F;result.</li>
<li><em><strong>High Coupling:</strong></em> Modules have access to each other’s implementation (<code>friend</code>s).</li>
</ul>
<p>Cohesion: How much do parts of a module relate to each other?</p>
<ul>
<li>Low Cohesion: Module parts are unrelated (ex. <utility>)</li>
<li>High Cohesion: Module parts co-operate to perform one task.</li>
</ul>
<p>We desire low coupling and high cohesion.</p>
<p><strong>Example:</strong> How to declare 2 classes that depends on each other</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    B y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">char</span> x;</span><br><span class="line">    A y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>We can not determine the size of A or B. Thus, we break the chain of dependencies via a pointer.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>; <span class="comment">// Forward declaration </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    B *y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    A *y;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>Q: How should A &amp; B be placed into modules?<br>A: Modules must be compiled in dependency order, so we can’t forward-declare modules, or anything within another module. Hence A &amp; B must reside in the same module. (Make sense since A &amp; B are obviously tightly coupled).</p>
<p>Note: Forward declaration is not allowed for object fields or for inheritance.</p>
<h4 id="Decoupling-the-Interface-MVC"><a href="#Decoupling-the-Interface-MVC" class="headerlink" title="Decoupling the Interface (MVC)"></a>Decoupling the Interface (MVC)</h4><p>Your primary program classes should not be printing things.</p>
<p><strong>Example:</strong> Let’s consider applying <strong>coupling</strong> and <strong>cohesion</strong> to Chess.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChessBoard</span> &#123;</span><br><span class="line">    ... <span class="comment">// private fields or methods</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Your move&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    ... <span class="comment">// Others</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is a bad design, since it inhibits code reuse. Think about what if you want to reuse <code>ChessBoard</code>, but not have it communicate via <code>std::out</code>?</p>
<p>One solution: give the class stream objects, where it can send its input&#x2F;output.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChessBoard</span> &#123;</span><br><span class="line">    istream &amp;in;</span><br><span class="line">    istream &amp;out;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">ChessBoard</span>(istream &amp;in, ostream &amp;out): in&#123;in&#125;, out&#123;out&#125; &#123; ... &#125;</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123; out &lt;&lt; <span class="string">&quot;Your move&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is better, but what if we don’t want to use streams at all?</p>
<p><strong>Single Responsibility Principle:</strong> A <code>class</code> should have only one reason to change.</p>
<p>I.e. If two or more distinct parts of the problem specification affects the same class, the class is doing too much.</p>
<p>Each class should do only <u>one</u> job - game state &amp; communication are <u>two</u> jobs.</p>
<p>Better: communicate with the <code>ChessBoard</code> via parameters &amp; results.</p>
<ul>
<li>Confine user communication to outside the game class.</li>
</ul>
<p>Q: So should main do all of the communication the call <code>ChessBoard</code> methods?</p>
<p>A: No, it is hard to reuse code if it’s in main.</p>
<p>So you should have a class to manage communication that is separate from the game state class.</p>
<h4 id="Model-View-Controller-MVC"><a href="#Model-View-Controller-MVC" class="headerlink" title="Model View Controller (MVC)"></a>Model View Controller (MVC)</h4><p>Separate the distinct notions of the data (or state - “model”), the presentation of the data (“view”) and the control or manipulation of the data (“controller”).</p>
<p>Model:</p>
<ul>
<li>can have multiple views (e.g. text &amp; graphics)</li>
<li>doesn’t need to know about their details</li>
<li>classic observer patterns (or could communicate via controller)</li>
</ul>
<p>Controller:</p>
<ul>
<li>Mediates control flow between model &amp; view</li>
<li>may encapsulate turn-taking, or full game rules.</li>
<li>may communicate with user for input (or this could be the view)</li>
</ul>
<p>By decoupling presentation &amp; control, MVC promotes reuse.</p>
<h4 id="Exception-Safety"><a href="#Exception-Safety" class="headerlink" title="Exception Safety"></a>Exception Safety</h4><p>Consider the following code, assuming C is any object</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    C *p = <span class="keyword">new</span> C;</span><br><span class="line">    <span class="built_in">g</span>();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>What if g throws an exception? During stack-unwinding, all stack-allocated data is cleaned up: destructors runs, memory is reclaimed. Heap-allocated memory is never reclaimed.</p>
<p>Hence if g throws, c is not leaked, but *p is.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    C *p = <span class="keyword">new</span> C;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">g</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is ugly and error prone due to the duplication of code.</p>
<p>How can we guarantee that something (e.g. delete p) will happen no matter how we exit f? (normal or exception?)</p>
<p>In some language - “finally” clauses guarantee certain final actions - not in C++.</p>
<p>Only thing you can count on in C++ - destructors for stack-allocated objects will run. Use stack-allocated data with destructors as much as possible. Use the guarantee to your advantage.</p>
<h4 id="RAII-Resource-Acquisition-is-Initialization"><a href="#RAII-Resource-Acquisition-is-Initialization" class="headerlink" title="RAII - Resource Acquisition is Initialization"></a>RAII - Resource Acquisition is Initialization</h4><p><strong>Solution</strong> : Wrap dynamically allocated memory in a stack-allocated object.</p>
<p><strong>Example from beginning of course:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ifstream f&#123;<span class="string">&quot;file.txt&quot;</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>the file is guaranteed to be released when f is popped from the stack (f’s destructor runs)</p>
<p>This can be done with dynamic memory</p>
<p>class std::unique_ptr<T> (import memory)</p>
<p>Constructor: Takes in a T*</p>
<p>Destructor: Deletes the pointer</p>
<p><strong>Example:</strong> Using RAII in a function using <code>unique_ptr</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    std::unique_ptr&lt;c&gt; p &#123;<span class="keyword">new</span> C&#125;;</span><br><span class="line">    <span class="built_in">g</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Whichever way <code>f</code> exits, the destructor will run on <code>p</code>, and the memory will be freed.</p>
<p>We could also use <code>std::make_unique</code> function also from memory</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C c &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> p = std::<span class="built_in">make_unique</span>&lt;c&gt;(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">g</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Difficulty:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;c&gt; p &#123;<span class="keyword">new</span> C&#125;;</span><br><span class="line">unique_ptr&lt;c&gt; q = p;</span><br></pre></td></tr></table></figure>

<p>What happens when a <code>unique_ptr</code> is copied? We don’t want to delete the same pointer twice!</p>
<p>Instead - copying is disabled for <code>unique_ptrs</code>. They can only be moved.</p>
<p>Simple implementation:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">unique_ptr</span> &#123;</span><br><span class="line">    T *ptr;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">unique_ptr</span> <span class="params">(T *p)</span>: ptr &#123;</span>p&#125; &#123;&#125;</span><br><span class="line">    ~<span class="built_in">unique_ptr</span>() &#123; <span class="keyword">delete</span> ptr; &#125;</span><br><span class="line">    <span class="built_in">unique_ptr</span> (<span class="type">const</span> unique_ptr &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    unique_ptr &amp;<span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">unique_ptr</span> (unique_ptr &amp;&amp;other) : ptr &#123;other.ptr&#125; &#123; other.ptr = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    unique_ptr &amp;<span class="keyword">operator</span>=(unique_ptr &amp;&amp;other) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(ptr, other.ptr);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T &amp;<span class="keyword">operator</span> &amp;() &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line">    <span class="function">T *<span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ptr; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If you need to copy pointers, you need to first answer the question of <u>ownership</u>.</p>
<p>Who will own the resource? Who will have the responsibility for freeing it?</p>
<p>Whatever pointer that is, that should be our unique pointer. All other pointers should be raw pointers (you can fetch the underlying raw pointers with <code>p.get()</code>).</p>
<p>We now have a new understanding of pointers:</p>
<ul>
<li><code>unique_ptr</code>: indicates <u>ownership</u> - delete will happen automatically when <code>unique_ptr</code> goes out of scope.</li>
<li>raw pointer: indicates non-ownership, since a raw pointer is not considered to own the resources it points at, you should not delete it.</li>
</ul>
<p>Moving a unique pointer &#x3D; transfer of ownership</p>
<p>Pointers as parameters</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span> <span class="params">(unique_ptr&lt;c&gt; p)</span></span>;</span><br><span class="line"><span class="comment">// f will take over ownership of the object pointed to by p - caller loses custody of the object</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span> <span class="params">(C *p)</span></span>;</span><br><span class="line"><span class="comment">// g will not take over ownership of the object pointed by p - caller&#x27;s ownership of the object doesn&#x27;t change (Note: caller might also not own the object)</span></span><br></pre></td></tr></table></figure>

<p>Pointers as results:</p>
<ul>
<li><code>unique_ptr &lt;c&gt; f();</code> - returns by value is always by move, so f is handing over ownership of the C object to the caller.</li>
<li><code>C *g();</code> - the pointer returned by g is understood not to be deleted by the caller, so it might represent a pointer to non-heap data or a pointer to heap data that someone else already owns.</li>
</ul>
<p>Rarely, a situation may arise that requires true <u>shared ownership</u>, i.e. any of several pointers may need to free the resource.</p>
<ul>
<li>use std::shared_ptr</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="keyword">auto</span> p = std::<span class="built_in">make_shared</span>&lt;c&gt; (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        <span class="keyword">auto</span> q = p;</span><br><span class="line">    &#125; <span class="comment">// when q is popped, pointer is not deleted</span></span><br><span class="line">&#125; <span class="comment">// when p is popped, pointer is deleted</span></span><br></pre></td></tr></table></figure>

<p><code>shared_ptr</code>s maintain a reference count - count of all shared pointers pointing at the same object.</p>
<p>Memory is freed when the number of shared pointers to it will reach 0.</p>
<p><u>Consider:</u></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define</span> lst1 (<span class="name">cons</span> <span class="number">1</span> (<span class="name">cons</span> <span class="number">2</span> (<span class="name">cons</span> <span class="number">3</span> empty))))</span><br><span class="line">(<span class="name">define</span> lst2 (<span class="name">cons</span> <span class="number">4</span> (<span class="name">list</span> lst1)))</span><br></pre></td></tr></table></figure>

<p>Use the form of pointer that accurately reflects the pointer’s ownership rule.</p>
<p><u>Dramatically</u> fewer opportunities for leaks.</p>
<p>Back to exception safety - What is exception safety?</p>
<p>It is not</p>
<ul>
<li>exceptions never happen</li>
<li>all exceptions get handled</li>
</ul>
<p>It is</p>
<ul>
<li>after an exception is handled, the program is not left in a broken or unusable state.</li>
</ul>
<p>Specifically - 3 levels of exception safety for a function f:</p>
<ol>
<li>Basic guarantee - if an exception occurs, the program will be in some valid state<ul>
<li>Nothing is leaked, no corrupted data structures, all class invariants are maintained.</li>
</ul>
</li>
<li>Strong guarantee - if an exception is raised while executing f, the state of the program will be as it was before f was called.</li>
<li>No-throw guarantee - f will never throw or propagate an exception</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123; ... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a.<span class="built_in">g</span>(); <span class="comment">// May throw (strong guarantee)</span></span><br><span class="line">        b.<span class="built_in">h</span>(); <span class="comment">// May throw (strong guarantee)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>If <code>a.g()</code> throws - nothing has happened yet. OK</p>
<p>If <code>b.h()</code> throws - effects of <code>a.g()</code> must be undone to offer the strong guarantee.</p>
<ul>
<li>Very hard or impossible to achieve if g has non-local side effects.</li>
</ul>
<p>If <code>A::g B::h</code> don’t have non-local side-effects.</p>
<p>copy &amp; swap:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A atemp = a; <span class="comment">// If these throws,original a &amp; b still intact</span></span><br><span class="line">        B btemp = b;</span><br><span class="line">        atemp.<span class="built_in">g</span>();</span><br><span class="line">        btemp.<span class="built_in">h</span>();	<span class="comment">//</span></span><br><span class="line">        </span><br><span class="line">        a = atemp; <span class="comment">// But what if copy assignment throws?</span></span><br><span class="line">        b = btemp; <span class="comment">// In particular, what if a = atemp suceeds, and b = btemp fails?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Better if swap was no-throw. <u>Recall</u>: copying pointers cannot throw.</p>
<p>Solution: Access C’s internal state through a pointer. (called the <code>pImpl</code> idiom)</p>
<p><code>Pimpl</code> Idiom(“pointer to implementation”): Access C’s internal state through a pointer.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CImpl</span> &#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    unique_ptr &lt;CImpl&gt; pImpl;</span><br><span class="line">    ...</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> temp = <span class="built_in">make_unique</span>&lt;CImpl&gt; (*pImpl);</span><br><span class="line">        temp-&gt;a.<span class="built_in">g</span>();</span><br><span class="line">        temp-&gt;b.<span class="built_in">h</span>();</span><br><span class="line">        std::<span class="built_in">swap</span>(pImpl, temp); <span class="comment">// No-throw</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This implementation provides the <strong>strong guarantee</strong>.</p>
<p>In general, if <code>A::g</code> or <code>B::h</code> don’t provide any exception safety, then neither does <code>C::f</code>.</p>
<p><code>Vectors - RAII and Exception Safety</code></p>
<h5 id="Constructor-Delegation"><a href="#Constructor-Delegation" class="headerlink" title="Constructor Delegation"></a>Constructor Delegation</h5><p>A constructor can call another constructor as a helper.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Vec</span>(<span class="type">int</span> x, <span class="type">int</span> y): x&#123;x&#125;, y&#123;y&#125; &#123; cout &lt;&lt; <span class="string">&quot;CS 246&quot;</span>; &#125;</span><br><span class="line">    <span class="comment">// constructor process a vec of slope -1</span></span><br><span class="line">    <span class="built_in">Vec</span> (<span class="type">int</span> x): Vec&#123;x, -x&#125; &#123; cout &lt;&lt; <span class="string">&quot; is fun!&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="Exception-Safety-amp-the-STL-vector"><a href="#Exception-Safety-amp-the-STL-vector" class="headerlink" title="Exception Safety &amp; the STL - vector"></a>Exception Safety &amp; the STL - vector</h4><p>Vectors:</p>
<ul>
<li>encapsulate a heap allocated array</li>
<li>follow RAII - when a stack-allocated vector goes out of scope, the internal heap-allocated array is freed.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;c&gt; v;</span><br><span class="line">&#125; <span class="comment">// v goes out of scope, array is freed. C destructor runs on all objects in the Vector.</span></span><br></pre></td></tr></table></figure>

<p>But</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector &lt;C*&gt; v;</span><br><span class="line">&#125; <span class="comment">// array is freed, pointers don&#x27;t have destructors, any objects pointed to by the pointers are not deleted</span></span><br></pre></td></tr></table></figure>

<p>But</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;unique_ptr&lt;C&gt;&gt; v;</span><br><span class="line">&#125; <span class="comment">// array is freed, unique_ptr destructor runs, so the objects are deleted. No explicit deallocation.</span></span><br></pre></td></tr></table></figure>

<p><code>vector&lt;c&gt;</code> - owns the objects</p>
<p><code>vector&lt;cw&gt;</code> - doesn’t own the objects</p>
<p><code>vector&lt;unique_ptr&lt;c&gt;&gt;</code> - owns the objects</p>
<p><code>vector&lt;T&gt;::emplace_back</code> - offers the strong guarantee</p>
<ul>
<li>if the array is full (i.e. size &#x3D;&#x3D; cap)<ul>
<li>allocate new array</li>
<li>copy object’s over (copy constructor)</li>
<li>delete old array<ul>
<li>if copy constructor throws<ul>
<li>destroy the new array</li>
<li>old array still intact</li>
<li>strong guarantee</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>But - copying is expensive &amp; the old array will be thrown away.</p>
<ul>
<li>wouldn’t moving the objects be more efficient?<ul>
<li>allocate new array</li>
<li>move the objects over (move constructor)</li>
<li>swap arrays</li>
<li>delete old array</li>
</ul>
</li>
</ul>
<p>If the move constructor offers the no-throw guarantee, emplace_back will use the move constructor. Otherwise, it will use the copy constructor, which may be slower.</p>
<p>So your move operator should provide the no-throw guarantee, and you should indicate that they do:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">C</span>(C &amp;&amp;other) <span class="keyword">noexcept</span> &#123; ... &#125;</span><br><span class="line">    	C &amp;<span class="keyword">operator</span>=(C &amp;&amp;other) <span class="keyword">noexcept</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If you know a function will never throw or propagate an exception, declare it no-except - facilitates optimization.</p>
<h4 id="Casting"><a href="#Casting" class="headerlink" title="Casting"></a>Casting</h4><p>In C, casting is:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node n;</span><br><span class="line"><span class="type">int</span> *ip = (<span class="type">int</span> *) &amp;n; <span class="comment">// forces C++ to treat a Node * as an int*</span></span><br></pre></td></tr></table></figure>

<p>C style casts should be avoided in C++. If you must cast, use the C++ cast.</p>
<p>4 kinds:</p>
<h5 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h5><p>Sensible casts with well defined semantics.</p>
<p>Ex. <code>float</code> -&gt; <code>int</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> f;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">float</span> f)</span></span>;</span><br><span class="line"><span class="built_in">g</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(f)); <span class="comment">// calls the int version of g</span></span><br></pre></td></tr></table></figure>

<p>static_cast allows us to down cast: <code>Superclass * -&gt; Subclass</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Book *pb = ...;</span><br><span class="line">Text *pt = <span class="built_in">static_cast</span>&lt;Text *&gt;(pb);</span><br><span class="line">cout &lt;&lt; pt-&gt;topic &lt;&lt; endl;</span><br></pre></td></tr></table></figure>





<h5 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h5><p>unsafe, implementation dependent, “weird” conversions</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student s;</span><br><span class="line">Turtle *t = <span class="built_in">reinterpret_cast</span>&lt;Turtle *&gt;(&amp;s);</span><br></pre></td></tr></table></figure>



<h5 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h5><p>for converting between const &amp; non-const</p>
<ul>
<li>the only C++ cast that an cast away const</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">int</span> *p)</span></span>; <span class="comment">// suppose you know that g won&#x27;t modify *p in the circumstances when f would call g</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *p)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">	<span class="built_in">g</span>(p); <span class="comment">// won&#x27;t compile</span></span><br><span class="line">    <span class="built_in">g</span>(<span class="built_in">const_cast</span>&lt;<span class="type">int</span> *&gt;(p));</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h5><p>is it safe to convert a <code>Book *</code> to a <code>Text *</code>?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Book *bp = ...;</span><br><span class="line"><span class="keyword">static_cast</span>&lt;Text *&gt; pb -&gt;<span class="built_in">getTopic</span>(); <span class="comment">// safe?</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Depends on whether pb actually points to a Text.</li>
<li>Better to do a tentative cast - try it and see if it succceeds.</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Text *pt = <span class="built_in">dynamic_cast</span>&lt;Text *&gt;(pb);</span><br></pre></td></tr></table></figure>

<p>If the cast works (<code>pb</code> actually points at a Text, or a subclass of Text), <code>pt</code> points at the object.</p>
<p>If the cast fails, <code>pt</code> will be <code>nullptr</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pt) cout &lt;&lt; pt-&gt;<span class="built_in">getTopic</span>();</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Not a Text&quot;</span>;</span><br></pre></td></tr></table></figure>



<p>These are options on raw pointers - can they be done on smart pointer?</p>
<p>Yes - static_pointer_cast, dynamic_pointer_cast, etc.</p>
<ul>
<li>cast <code>shared_ptrs</code> to <code>shared_ptrs</code></li>
<li>Dynamic casting also works with references.<ul>
<li>Text t{…}</li>
<li>Book &amp;b &#x3D; t;</li>
<li>Text &amp;t2 &#x3D; dynamic_cast&lt;Text&amp;&gt;(b);</li>
</ul>
</li>
</ul>
<p>Note: dynamic casting only works on classes with at least one virtual methods.</p>
<p>Dynamic reference casting others a possible solution to the polymorphic assignment problem.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Text &amp;Text::operaator=(<span class="type">const</span> Book &amp;other) &#123;</span><br><span class="line">    <span class="type">const</span> Text&amp; tother = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Text&amp;&gt;(other);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;other) <span class="keyword">return</span>;</span><br><span class="line">    Book::<span class="keyword">operator</span>=(other);</span><br><span class="line">    topic = tother.topic;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Is dynamic casting good style?</p>
<p>Example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">whatIsIt</span><span class="params">(Book *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dynamic_cast</span>&lt;Comic*&gt;(b)) cout &lt;&lt; <span class="string">&quot;comic&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">dynamic_cast</span>&lt;Text*&gt;(b)) cout &lt;&lt; <span class="string">&quot;Text&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Book&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tightly coupled to the class hierarchy &amp; may indicate bad design.</p>
<p>Why? What if you create a new subclass of book</p>
<ul>
<li>You need to update whatIsIt and all functions like it that query for types.</li>
</ul>
<p><strong>Better</strong>: Use virtual methods</p>
<p><strong>Note</strong>: Text::operator&#x3D; doesn’t have this problem (only comparing with your own type, not all types)</p>
<p>Fix whatIsIt?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">clcass Book &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">identify</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Book&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">whatIsIt</span><span class="params">(Book *b)</span> </span>&#123;</span><br><span class="line">    b-&gt;<span class="built_in">identify</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Works by creating an interface function that is uniform across all Book types.</p>
<ul>
<li>But what if the interface isn’t uniform across all types in the hiearchy?</li>
</ul>
<p>Inheritance &amp; virtual methods work well when</p>
<ul>
<li>There is an unlimited number of potential specializations of a basic abstraction</li>
<li>Each following the same interface</li>
</ul>
<p>What about the opposite case?</p>
<ul>
<li>limited number of specialization, all known in advance, unlikely to change</li>
<li>with possibly different interfaces</li>
</ul>
<p>In the first case - adding a new subclass - minimal work.</p>
<p>In the second case - adding a new subclass - reworking existing code to use the new interface, but that is fine, because you aren’t expecting to add new subclasses, or you are expecting to do the work.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Turtle</span> : <span class="keyword">public</span> Enemy &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">stealShell</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bullet</span> : <span class="keyword">public</span> Enemy &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">deflect</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>These interfaces aren’t uniform. In this case a new enemy type &#x3D; new interface + unavailable work. So we could regard the set of Enemy classes as fixed, and maybe dynamic casting on enemies is justified.</p>
<p><strong>But</strong> - in this case, maybe inheritance is not the right abstraction mechanism.</p>
<p>If you know that an enemy will only be a Turtle or a Bullet, and you accept that adding new enemy types requires widespread changes anyway, then consider:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;variant&gt;;</span><br><span class="line"><span class="keyword">typedef</span> variant &lt;Turtle, Bullet&gt; Enemy; <span class="comment">// An emeny is a Turtle or a Bullet</span></span><br><span class="line"><span class="comment">//equal: using Enemy = variant&lt;Turtle, Bullet&gt;;</span></span><br><span class="line">Enemy = &#123;Turtle&#123;&#125;&#125;; <span class="comment">// On bullet&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>Discriminating the value:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">holds_alternative</span>&lt;Turtle&gt;(e)) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Turtle&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Extracting the value:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Turtle t = <span class="built_in">get</span>&lt;Turtle&gt;(e);</span><br><span class="line">    <span class="comment">// use t...</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (bad_variant_access &amp;)&#123;</span><br><span class="line">    <span class="comment">// it&#x27;s not a Turtle...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A variant is like a union, but type_safe. Attempting to store as one type &amp; fetch as another will throw.</p>
<p>If a variant is left uninitialized, the first option in the variant is default-constructed to initialize the variant - compile error it 1st potion not default.</p>
<h4 id="How-Virtual-Methods-Work"><a href="#How-Virtual-Methods-Work" class="headerlink" title="How Virtual Methods Work"></a>How Virtual Methods Work</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vec</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vec2</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">f</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>What’s the difference?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vec v&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">Vec2 w&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>Do they look the same in memory?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(v) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(w) &lt;&lt; endl; <span class="comment">// 8 16</span></span><br></pre></td></tr></table></figure>

<p>First note 8 &#x3D; space for 2 integers, there’s no space for the f method.</p>
<p>Compiler turns methods into ordinary functions &amp; stores them separately from objects.</p>
<p><u>Recall</u>:</p>
<p><code>Book *pb = new (Book/Text/Comic);</code></p>
<p><code>pb-&gt;isHeavy();</code></p>
<p>If <code>isHeavy</code> is virtual, choice of version to run is based on the type of the actual object, which the compiler won’t know in advance.</p>
<p>Therefore the correct <code>isHeavy</code> must be chosen at runtime.</p>
<p>For each class with virtual method, the compiler creates a table of functions pointers (the <code>vtable</code>).</p>
<p><strong>Example:</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">C</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202412031449266.png" alt="Vtable fig.1"></p>
<p>Calling a virtual method (At runtime)</p>
<ul>
<li>follow <code>vptr</code> to <code>vtable</code></li>
<li>fetch pointer to actual method from <code>vtable</code></li>
<li>follow the pointer &amp; call the function</li>
</ul>
<p><u>Also:</u> Declaring at least one virtual method adds a <code>vptr</code> to the object.</p>
<p>Classes without virtual methods produce smaller objects than if some methods were virtual.</p>
<p>Concretely, how is an object laid out? It is Compiler-depedent.</p>
<p>Why did we put the <code>vptr</code> first in the object and not somewhere else (e.g. last)?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, c;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="type">int</span> b, d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>vptr</code> were put at the first because we need to access the <code>vptr</code> to know the type of the object, and putting <code>vptr</code> to the front is easiest for it to be accessed.</p>
<p><u>BUT:</u></p>
<h4 id="Multiple-Inheritance"><a href="#Multiple-Inheritance" class="headerlink" title="Multiple Inheritance"></a>Multiple Inheritance</h4><p>A class can inherit from more than one class.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>Challenges:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="type">int</span> d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D dobj;</span><br><span class="line">dobj.a <span class="comment">// which a is this?</span></span><br><span class="line"><span class="comment">// ambiguous - compiler error</span></span><br><span class="line"><span class="comment">// we need to specify</span></span><br><span class="line">dobj.B::a <span class="keyword">or</span> dobj.c::a</span><br></pre></td></tr></table></figure>

<p>But if B &amp; C inherit from A, should there be only one A part of D, or two?</p>
<ul>
<li>Should B::a &amp; C::a be the same or different?</li>
<li>What if we want (deadly diamond)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202412031522160.png"></p>
<p>Make A a <u>virtual base</u> class - use <u>virtual inheritance</u>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;...&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> B &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>Example:</strong> IO stream library</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202412031528959.png"></p>
<p>How will this be laid out</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202412031534688.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://raw.githubusercontent.com/M4cr0Chen/MyPic/refs/heads/main/img/202412031544403.png"></p>
<p>Diagram doesn’t look like all of A, B, C, D.</p>
<ul>
<li>but slices of it do look like A, B, C, D.</li>
</ul>
<p>Therefore pointer assignment among A, B, C, D changes the address shared in the pointer.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D *d = <span class="keyword">new</span> D&#123; ... &#125;;</span><br><span class="line">A *a = d; <span class="comment">// changes the address to point at the A part.</span></span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">Zhenghong Chen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/09/05/CS246%20Object-Oriented%20Software%20Dev/">http://example.com/2024/09/05/CS246%20Object-Oriented%20Software%20Dev/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Course-Notes/">Course Notes</a></div><div class="post_share"><div class="social-share" data-image="https://miro.medium.com/v2/resize:fit:1400/1*GRljCZx9fe_t_4vL_1imAQ.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/01/09/CS136Notes/" title=""><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/goodPictures/1536a1ad880511ebb6edd017c2d2eca2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info"></div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/12/14/Math135Notes/" title="Math 135 Notes"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-media.byjusfutureschool.com/bfs-blog/2022/09/21090501/Article-Page-86.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-14</div><div class="title">Math 135 Notes</div></div></a></div><div><a href="/2023/12/14/Math137Notes/" title="Math 137 Notes"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.thoughtco.com/thmb/irSi_hwriBZL3QbGsCiiNsgaSWI=/1500x0/filters:no_upscale():max_bytes(150000):strip_icc()/calculus-on-blackboard-79338340-5be4695946e0fb0026d6856f.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-14</div><div class="title">Math 137 Notes</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="card-info-avatar"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/goodPictures/suitNtie.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-status-box"><div class="author-status"><g-emoji class="g-emoji" alias="palm_tree" fallback-src="https://lskypro.acozycotage.net/LightPicture/2022/12/fe1dc0402e623096.jpg">🐟</g-emoji><span>认真摸鱼中</span></div></div></div><div class="author-info__name">Zhenghong Chen</div><div class="author-info__description">macrochen05@gmail.com</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/M4cr0Chen"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/M4cr0Chen" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="https://www.instagram.com/m4cr0ch4n/" target="_blank" title="Instagram"><i class="fab fa-instagram" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://www.facebook.com/chen.macro.75" target="_blank" title="Facebook"><i class="fab fa-facebook" style="color: #24292e;"></i></a><a class="social-icon" href="https://www.linkedin.com/in/zhenghong-chen-974102245/" target="_blank" title="Linkedin"><i class="fab fa-linkedin-in" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Welcome to Macro's blog. Macro is having a hard time studying in University of Waterloo, so if you can offer him a job he'll be better!😄</div><div id="welcome-info"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CS246-Object-Oriented-Software-Dev"><span class="toc-text">CS246 Object-Oriented Software Dev</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-text">Introduction</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Comparison-between-C-and-C"><span class="toc-text">Comparison between C and C++:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Input-x2F-Output"><span class="toc-text">Input&#x2F;Output</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-Features"><span class="toc-text">C++ Features</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-text">String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File-Stream-x2F-1"><span class="toc-text">File Stream&#x2F;1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-x2F-2"><span class="toc-text">String&#x2F;2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Command-Line-Arguments"><span class="toc-text">Command Line Arguments</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Default-Function-Parameters"><span class="toc-text">Default Function Parameters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Overloading"><span class="toc-text">Overloading</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Structs"><span class="toc-text">Structs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constants"><span class="toc-text">Constants</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parameter-Passing"><span class="toc-text">Parameter Passing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#References-Important"><span class="toc-text">References - Important</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dynamic-Memory"><span class="toc-text">Dynamic Memory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Methods-of-returning-values"><span class="toc-text">Methods of returning values</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Operator-Overloading"><span class="toc-text">Operator Overloading</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modules"><span class="toc-text">Modules</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Separate-Compilation"><span class="toc-text">Separate Compilation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Classes"><span class="toc-text">Classes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Big-Five"><span class="toc-text">Big Five</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Constructors-Initializing-Objects"><span class="toc-text">Constructors (Initializing Objects)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Copy-Constructors"><span class="toc-text">Copy Constructors</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Explicit-x2F-Implicit-Constructors"><span class="toc-text">Explicit &#x2F; Implicit Constructors</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Destructors"><span class="toc-text">Destructors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Copy-Assignment-Operator"><span class="toc-text">Copy Assignment Operator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Copy-x2F-Swap-Idiom"><span class="toc-text">Copy&#x2F;Swap Idiom</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Move-Constructors"><span class="toc-text">Move Constructors</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Move-Assignment-Operator"><span class="toc-text">Move Assignment Operator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Copy-x2F-Move-Elision"><span class="toc-text">Copy&#x2F;Move Elision</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Summary-Rule-of-5-Big-5"><span class="toc-text">Summary: Rule of 5 (Big 5)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Features-of-Objects"><span class="toc-text">Features of Objects</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Member-Operators"><span class="toc-text">Member Operators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays-of-Objects"><span class="toc-text">Arrays of Objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Const-Objects"><span class="toc-text">Const Objects</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Static-fields-and-methods"><span class="toc-text">Static fields and methods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Three-Way-Comparison"><span class="toc-text">Three-Way Comparison</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Encapsulation"><span class="toc-text">Encapsulation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator-Pattern"><span class="toc-text">Iterator Pattern</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SE-Topic-Design-Patterns"><span class="toc-text">SE Topic: Design Patterns</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Equality-Revisited"><span class="toc-text">Equality Revisited</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#System-Modelling"><span class="toc-text">System Modelling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Relationships-Between-Classes"><span class="toc-text">Relationships Between Classes</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Composition"><span class="toc-text">Composition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Aggregation"><span class="toc-text">Aggregation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Specialization-x2F-Inheritance"><span class="toc-text">Specialization &#x2F; Inheritance</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Protected-Variables-and-Methods"><span class="toc-text">Protected Variables and Methods</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Virtual-Methodss"><span class="toc-text">Virtual Methodss</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Destructor-Revisited"><span class="toc-text">Destructor Revisited</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pure-Virtual-Methods"><span class="toc-text">Pure Virtual Methods</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Templates"><span class="toc-text">Templates</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Standard-Template-Library-STL"><span class="toc-text">Standard Template Library (STL)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Design-Patterns-Continued"><span class="toc-text">Design Patterns (Continued)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Iterator-Pattern-1"><span class="toc-text">Iterator Pattern</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Observer-Pattern"><span class="toc-text">Observer Pattern</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Decorator-Pattern"><span class="toc-text">Decorator Pattern</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Factoring-Method-Pattern"><span class="toc-text">Factoring Method Pattern</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Template-Method-Pattern"><span class="toc-text">Template Method Pattern</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reviewing-Big-5-with-Inheritance"><span class="toc-text">Reviewing Big 5 with Inheritance</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Advanced-C-Features"><span class="toc-text">Advanced C++ Features</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Coupling-x2F-Cohesion"><span class="toc-text">Coupling &#x2F; Cohesion</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Decoupling-the-Interface-MVC"><span class="toc-text">Decoupling the Interface (MVC)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Model-View-Controller-MVC"><span class="toc-text">Model View Controller (MVC)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exception-Safety"><span class="toc-text">Exception Safety</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RAII-Resource-Acquisition-is-Initialization"><span class="toc-text">RAII - Resource Acquisition is Initialization</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Constructor-Delegation"><span class="toc-text">Constructor Delegation</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Exception-Safety-amp-the-STL-vector"><span class="toc-text">Exception Safety &amp; the STL - vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Casting"><span class="toc-text">Casting</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#static-cast"><span class="toc-text">static_cast</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reinterpret-cast"><span class="toc-text">reinterpret_cast</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#const-cast"><span class="toc-text">const_cast</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dynamic-cast"><span class="toc-text">dynamic_cast</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#How-Virtual-Methods-Work"><span class="toc-text">How Virtual Methods Work</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Multiple-Inheritance"><span class="toc-text">Multiple Inheritance</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/05/CS246%20Object-Oriented%20Software%20Dev/" title="CS 246 Notes"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://miro.medium.com/v2/resize:fit:1400/1*GRljCZx9fe_t_4vL_1imAQ.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CS 246 Notes"/></a><div class="content"><a class="title" href="/2024/09/05/CS246%20Object-Oriented%20Software%20Dev/" title="CS 246 Notes">CS 246 Notes</a><time datetime="2024-09-05T04:00:00.000Z" title="Created 2024-09-05 00:00:00">2024-09-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/01/09/CS136Notes/" title="No title"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/goodPictures/1536a1ad880511ebb6edd017c2d2eca2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="No title"/></a><div class="content"><a class="title" href="/2024/01/09/CS136Notes/" title="No title">No title</a><time datetime="2024-01-09T16:35:47.912Z" title="Created 2024-01-09 11:35:47">2024-01-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/20/2023-12-20/" title="My PVZ Development Log"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://play-lh.googleusercontent.com/hO7716hh7NCcFauJedDclX-R3Zh9JmbSs8AUU6TP2edGVILlZM7gmyt_8WPCZELiPQA" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="My PVZ Development Log"/></a><div class="content"><a class="title" href="/2023/12/20/2023-12-20/" title="My PVZ Development Log">My PVZ Development Log</a><time datetime="2023-12-20T22:11:00.000Z" title="Created 2023-12-20 17:11:00">2023-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/17/2023-12-17/" title="My PVZ Development Log"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://play-lh.googleusercontent.com/hO7716hh7NCcFauJedDclX-R3Zh9JmbSs8AUU6TP2edGVILlZM7gmyt_8WPCZELiPQA" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="My PVZ Development Log"/></a><div class="content"><a class="title" href="/2023/12/17/2023-12-17/" title="My PVZ Development Log">My PVZ Development Log</a><time datetime="2023-12-17T16:15:23.000Z" title="Created 2023-12-17 11:15:23">2023-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/12/14/Math135Notes/" title="Math 135 Notes"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog-media.byjusfutureschool.com/bfs-blog/2022/09/21090501/Article-Page-86.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Math 135 Notes"/></a><div class="content"><a class="title" href="/2023/12/14/Math135Notes/" title="Math 135 Notes">Math 135 Notes</a><time datetime="2023-12-14T20:46:00.000Z" title="Created 2023-12-14 15:46:00">2023-12-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">公益广告</p><div class="bg-ad"><div>国家反诈中心是国务院打击治理电信网络新型违法犯罪工作部际联席会议合成作战平台，集资源整合、情报研判、侦查指挥为一体，在打击、防范、治理电信网络诈骗等新型违法犯罪中发挥着重要作用。</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://www.macrochen.top/">点击跳转</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">修仙导航</p><ul class="ft-links"><li><a target="_blank" rel="noopener" href="https://fe32.top/articles/hexo1600/">建站指南</a><a target="_blank" rel="noopener" href="https://fe32.top/nav.html">网址导航</a></li><li><a target="_blank" rel="noopener" href="https://fe32.top/sponsorWall/">来杯咖啡</a><a target="_blank" rel="noopener" href="https://fe32.top/comments/">留点什么</a></li><li><a target="_blank" rel="noopener" href="https://www.macrochen.top/about/">关于博主</a><a target="_blank" rel="noopener" href="https://www.macrochen.top/archives/">文章归档</a></li><li><a target="_blank" rel="noopener" href="https://www.macrochen.top/categories/">文章分类</a><a target="_blank" rel="noopener" href="https://www.macrochen.top/tags/">文章标签</a></li><li><a target="_blank" rel="noopener" href="https://fe32.top/gallery/">我的相册</a><a target="_blank" rel="noopener" href="https://fe32.top/bangumis/">我的追番</a></li><li><a target="_blank" rel="noopener" href="https://fe32.top/specialEffects/">一些特效</a><a target="_blank" rel="noopener" href="https://wallhaven.cc/">精美壁纸</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://index.anheyu.com/" title="安和鱼"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img02.anheyu.com/adminuploads/1/2022/09/15/63232b7d91d22.jpg" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://fe32.top/" title="唐志远の博客"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2022/05/02/626f92e193879.jpg" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://blog.zhheo.com/" title="张洪Heo"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/guli-heo/img/avatar2.png" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://akilar.top/" title="Akilarの糖果屋"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/akilar-candyassets/image/siteicon/favicon.png" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://blog.leonus.cn/" title="Leonus"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://q1.qlogo.cn/g?b=qq&amp;nk=990320751&amp;s=5" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.yyyzyyyz.cn/" title="yyyz"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.yyyzyyyz.cn/butterflyimg/img/avatar.png" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://blog.eurkon.com/" title="Eurkon"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/eurkon-cdn/hexo/images/user/avatar.jpg" alt=""/></a></div><div class="img-group-item"><a target="_blank" rel="noopener" href="https://www.startly.cn/" title="Cartafi"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://startly.s3.bitiful.net/footer/footer-pug/cartafi.webp" alt=""/></a></div></div></div></div><div class="copyright">&copy;2023 - 2024  <i id="heartbeat" class="fa fas fa-heartbeat"></i> Zhenghong Chen</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">2</button><a class="icon-V hidden" onclick="switchNightMode()" title="Switch Between Light And Dark Mode"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"><span id="percent">0<span>%</span></span></i></button></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.macrochen.top/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.macrochen.top/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.textContent = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script async src="/js/title.js"></script><script src="/js/sun_moon.js" async></script><script type="text/javascript" src="https://cdn1.tianli0.top/npm/jquery@latest/dist/jquery.min.js"></script><script type="text/javascript" src="/js/rightmenu.js"></script><script defer src="/js/runtime.js"></script><script defer data-pjax src="/js/readPercent.js"></script><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async data-pjax src="/js/txmap.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="255,255,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>